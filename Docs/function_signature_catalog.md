# Function Signature Catalog

Generated by `tools/build_signature_catalog.py`.

The catalog lists the function declarations and definitions that appear in the C/C++ sources so maintainers can quickly find overloads, constructors, destructors, and other helpers without reading every file manually.

## Functions

### API/api.hpp

- `bool api_request(const char *ip, uint16_t port, const char *method, const char *path, const api_streaming_handler *streaming_handler, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int timeout = 60000, bool enable_http2 = true, bool *used_http2 = ft_nullptr, const api_retry_policy *retry_policy = ft_nullptr);`
- `bool api_request_json_async(const char *ip, uint16_t port, const char *method, const char *path, api_json_callback callback, void *user_data, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int timeout = 60000);`
- `bool api_request_json_http2_async(const char *ip, uint16_t port, const char *method, const char *path, api_json_callback callback, void *user_data, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int timeout = 60000, bool *used_http2 = ft_nullptr);`
- `bool api_request_json_tls_async(const char *host, uint16_t port, const char *method, const char *path, api_json_callback callback, void *user_data, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int timeout = 60000);`
- `bool api_request_json_tls_http2_async(const char *host, uint16_t port, const char *method, const char *path, api_json_callback callback, void *user_data, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int timeout = 60000, bool *used_http2 = ft_nullptr);`
- `bool api_request_stream(const char *ip, uint16_t port, const char *method, const char *path, const api_streaming_handler *streaming_handler, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `bool api_request_stream_host(const char *host, uint16_t port, const char *method, const char *path, const api_streaming_handler *streaming_handler, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `bool api_request_stream_http2(const char *ip, uint16_t port, const char *method, const char *path, const api_streaming_handler *streaming_handler, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int timeout = 60000, bool *used_http2 = ft_nullptr, const api_retry_policy *retry_policy = ft_nullptr);`
- `bool api_request_stream_tls(const char *host, uint16_t port, const char *method, const char *path, const api_streaming_handler *streaming_handler, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int timeout = 60000, const char *ca_certificate = ft_nullptr, bool verify_peer = true, const api_retry_policy *retry_policy = ft_nullptr);`
- `bool api_request_stream_tls_http2(const char *host, uint16_t port, const char *method, const char *path, const api_streaming_handler *streaming_handler, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int timeout = 60000, const char *ca_certificate = ft_nullptr, bool verify_peer = true, bool *used_http2 = ft_nullptr, const api_retry_policy *retry_policy = ft_nullptr);`
- `bool api_request_string_async(const char *ip, uint16_t port, const char *method, const char *path, api_callback callback, void *user_data, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int timeout = 60000);`
- `bool api_request_string_http2_async(const char *ip, uint16_t port, const char *method, const char *path, api_callback callback, void *user_data, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int timeout = 60000, bool *used_http2 = ft_nullptr);`
- `bool api_request_string_tls_async(const char *host, uint16_t port, const char *method, const char *path, api_callback callback, void *user_data, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int timeout = 60000);`
- `bool api_request_string_tls_http2_async(const char *host, uint16_t port, const char *method, const char *path, api_callback callback, void *user_data, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int timeout = 60000, bool *used_http2 = ft_nullptr);`
- `char *api_request_https(const char *ip, uint16_t port, const char *method, const char *path, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const char *ca_certificate = ft_nullptr, bool verify_peer = true, const api_retry_policy *retry_policy = ft_nullptr);`
- `char *api_request_https_http2(const char *ip, uint16_t port, const char *method, const char *path, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const char *ca_certificate = ft_nullptr, bool verify_peer = true, bool *used_http2 = ft_nullptr, const api_retry_policy *retry_policy = ft_nullptr);`
- `char *api_request_string(const char *ip, uint16_t port, const char *method, const char *path, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `char *api_request_string_basic(const char *ip, uint16_t port, const char *method, const char *path, const char *credentials, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `char *api_request_string_bearer(const char *ip, uint16_t port, const char *method, const char *path, const char *token, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `char *api_request_string_host(const char *host, uint16_t port, const char *method, const char *path, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `char *api_request_string_host_basic(const char *host, uint16_t port, const char *method, const char *path, const char *credentials, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `char *api_request_string_host_bearer(const char *host, uint16_t port, const char *method, const char *path, const char *token, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `char *api_request_string_http2(const char *ip, uint16_t port, const char *method, const char *path, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, bool *used_http2 = ft_nullptr, const api_retry_policy *retry_policy = ft_nullptr);`
- `char *api_request_string_tls(const char *host, uint16_t port, const char *method, const char *path, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `char *api_request_string_tls_basic(const char *host, uint16_t port, const char *method, const char *path, const char *credentials, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `char *api_request_string_tls_bearer(const char *host, uint16_t port, const char *method, const char *path, const char *token, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `char *api_request_string_tls_http2(const char *host, uint16_t port, const char *method, const char *path, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, bool *used_http2 = ft_nullptr, const api_retry_policy *retry_policy = ft_nullptr);`
- `char *api_request_string_url(const char *url, const char *method, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `const api_transport_hooks *api_get_transport_hooks(void);`
- `int api_debug_get_last_async_receive_state(void);`
- `int api_debug_get_last_async_receive_timeout(void);`
- `int api_debug_get_last_async_send_state(void);`
- `int api_debug_get_last_async_send_timeout(void);`
- `json_group *api_request_json(const char *ip, uint16_t port, const char *method, const char *path, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `json_group *api_request_json_basic(const char *ip, uint16_t port, const char *method, const char *path, const char *credentials, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `json_group *api_request_json_bearer(const char *ip, uint16_t port, const char *method, const char *path, const char *token, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `json_group *api_request_json_host(const char *host, uint16_t port, const char *method, const char *path, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `json_group *api_request_json_host_basic(const char *host, uint16_t port, const char *method, const char *path, const char *credentials, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `json_group *api_request_json_host_bearer(const char *host, uint16_t port, const char *method, const char *path, const char *token, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `json_group *api_request_json_http2(const char *ip, uint16_t port, const char *method, const char *path, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, bool *used_http2 = ft_nullptr, const api_retry_policy *retry_policy = ft_nullptr);`
- `json_group *api_request_json_tls(const char *host, uint16_t port, const char *method, const char *path, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `json_group *api_request_json_tls_basic(const char *host, uint16_t port, const char *method, const char *path, const char *credentials, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `json_group *api_request_json_tls_bearer(const char *host, uint16_t port, const char *method, const char *path, const char *token, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `json_group *api_request_json_tls_http2(const char *host, uint16_t port, const char *method, const char *path, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, bool *used_http2 = ft_nullptr, const api_retry_policy *retry_policy = ft_nullptr);`
- `json_group *api_request_json_url(const char *url, const char *method, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000, const api_retry_policy *retry_policy = ft_nullptr);`
- `long long api_connection_pool_get_idle_timeout(void);`
- `size_t api_connection_pool_get_max_idle(void);`
- `size_t api_debug_get_connection_pool_acquires(void);`
- `size_t api_debug_get_connection_pool_misses(void);`
- `size_t api_debug_get_connection_pool_reuses(void);`
- `size_t api_debug_get_last_async_bytes_received(void);`
- `size_t api_debug_get_last_async_bytes_sent(void);`
- `size_t api_debug_get_last_async_request_size(void);`
- `void api_clear_transport_hooks(void);`
- `void api_connection_pool_flush(void);`
- `void api_connection_pool_set_idle_timeout(long long idle_timeout_ms);`
- `void api_connection_pool_set_max_idle(size_t max_idle);`
- `void api_debug_reset_connection_pool_counters(void);`
- `void api_set_transport_hooks(const api_transport_hooks *hooks);`

### API/api_connection_pool.cpp

- `bool api_connection_pool_acquire(api_connection_pool_handle &handle, const char *host, uint16_t port, api_connection_security_mode security_mode, const char *security_identity)`
- `bool api_connection_pool_is_enabled(void)`
- `bool api_connection_pool_track_tls_session(SSL *tls_session)`
- `bool api_connection_pool_untrack_tls_session(SSL *tls_session)`
- `long long api_connection_pool_get_idle_timeout(void)`
- `size_t api_connection_pool_get_max_idle(void)`
- `size_t api_debug_get_connection_pool_acquires(void)`
- `size_t api_debug_get_connection_pool_misses(void)`
- `size_t api_debug_get_connection_pool_reuses(void)`
- `static bool api_connection_pool_bucket_erase(t_api_connection_bucket &entries, size_t index)`
- `static bool api_connection_pool_key_is_valid(const std::string &key)`
- `static bool api_connection_pool_map_erase(t_api_connection_map &buckets, size_t index)`
- `static bool api_connection_pool_socket_is_alive(ft_socket &socket)`
- `static bool api_connection_pool_socket_is_alive(ft_socket &socket);`
- `static bool api_connection_pool_tls_register(SSL *tls_session)`
- `static bool api_connection_pool_tls_unregister(SSL *tls_session)`
- `static ft_string api_connection_pool_build_key(const char *host, uint16_t port, api_connection_security_mode security_mode, const char *security_identity)`
- `static long long api_connection_pool_now_ms(void)`
- `static pt_mutex &api_connection_pool_get_mutex(void)`
- `static pt_mutex &api_connection_pool_get_tls_mutex(void)`
- `static std::set<SSL*> &api_connection_pool_get_tls_registry(void)`
- `static std::string api_connection_pool_to_std_key(const ft_string &key)`
- `static t_api_connection_map &api_connection_pool_get_buckets(void)`
- `static t_api_connection_map::iterator api_connection_pool_find_entry( t_api_connection_map &buckets, const std::string &key)`
- `static void api_connection_pool_clear_buckets(t_api_connection_map &buckets)`
- `static void api_connection_pool_dispose_entry(api_pooled_connection &entry)`
- `static void api_connection_pool_dispose_entry(api_pooled_connection &entry);`
- `static void api_connection_pool_drop_tls_duplicates(SSL *tls_session)`
- `static void api_connection_pool_free_tls(SSL *tls_session, SSL_CTX *tls_context)`
- `static void api_connection_pool_prune_expired(t_api_connection_bucket &entries, long long now_ms)`
- `static void api_connection_pool_record_dispose_snapshot( bool socket_cleanup_allowed, bool socket_is_open, int socket_error, size_t client_count)`
- `static void api_connection_pool_remove_oldest(t_api_connection_bucket &entries)`
- `void api_connection_pool_disable_store(api_connection_pool_handle &handle)`
- `void api_connection_pool_evict(api_connection_pool_handle &handle)`
- `void api_connection_pool_flush(void)`
- `void api_connection_pool_mark_idle(api_connection_pool_handle &handle)`
- `void api_connection_pool_set_enabled(bool enabled)`
- `void api_connection_pool_set_idle_timeout(long long idle_timeout_ms)`
- `void api_connection_pool_set_max_idle(size_t max_idle)`
- `void api_debug_reset_connection_pool_counters(void)`

### API/api_connection_pool_handle.cpp

- `bool api_connection_pool_handle_lock_guard::is_locked() const`
- `const char *api_connection_pool_handle::get_error_str() const`
- `int api_connection_pool_handle::get_error() const`
- `int api_connection_pool_handle::initialize_thread_safety()`
- `int api_connection_pool_handle::lock(bool *lock_acquired) const`
- `int api_connection_pool_handle::lock_internal(bool *lock_acquired) const`
- `void api_connection_pool_handle::record_operation_error_unlocked(int error_code)`
- `void api_connection_pool_handle::set_error(int error) const`
- `void api_connection_pool_handle::teardown_thread_safety()`
- `void api_connection_pool_handle::unlock(bool lock_acquired) const`
- `void api_connection_pool_handle::unlock_internal(bool lock_acquired) const`

### API/api_http_common.cpp

- `bool api_http_chunked_body_complete(const char *body_start, size_t body_size, size_t &consumed_length)`
- `bool api_http_decode_chunked(const char *body_start, size_t body_size, ft_string &decoded_body, size_t &consumed_length)`
- `bool api_http_is_whitespace(char character)`
- `bool api_http_line_starts_with(const char *line_start, size_t line_length, const char *name)`
- `bool api_http_measure_json_payload(json_group *payload, size_t &payload_length)`
- `bool api_http_parse_decimal(const char *start, const char *end, long long &value)`
- `bool api_http_parse_hex(const char *start, const char *end, long long &value)`
- `bool api_http_stream_json_payload(json_group *payload, api_http_send_callback send_callback, void *context, int &error_code)`
- `const char *api_http_find_crlf(const char *start, const char *end)`
- `static bool api_http_measure_add(size_t &total, size_t increment)`
- `static bool api_http_stream_literal(api_http_send_callback send_callback, void *context, const char *literal, size_t literal_length, int &error_code)`
- `void api_http_parse_headers(const char *headers_start, const char *headers_end, bool &connection_close, bool &chunked_encoding, bool &has_length, long long &content_length)`
- `void api_http_trim_header_value(const char **value_start, const char **value_end)`

### API/api_http_common.hpp

- `bool api_http_chunked_body_complete(const char *body_start, size_t body_size, size_t &consumed_length);`
- `bool api_http_decode_chunked(const char *body_start, size_t body_size, ft_string &decoded_body, size_t &consumed_length);`
- `bool api_http_is_whitespace(char character);`
- `bool api_http_line_starts_with(const char *line_start, size_t line_length, const char *name);`
- `bool api_http_measure_json_payload(json_group *payload, size_t &payload_length);`
- `bool api_http_parse_decimal(const char *start, const char *end, long long &value);`
- `bool api_http_parse_hex(const char *start, const char *end, long long &value);`
- `bool api_http_stream_json_payload(json_group *payload, api_http_send_callback send_callback, void *context, int &error_code);`
- `const char *api_http_find_crlf(const char *start, const char *end);`
- `void api_http_parse_headers(const char *headers_start, const char *headers_end, bool &connection_close, bool &chunked_encoding, bool &has_length, long long &content_length);`
- `void api_http_trim_header_value(const char **value_start, const char **value_end);`

### API/api_http_internal.hpp

- `bool api_http_execute_plain_http2_streaming( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int timeout, const char *host, uint16_t port, const api_retry_policy *retry_policy, const api_streaming_handler *streaming_handler, bool &used_http2, int &error_code);`
- `bool api_http_execute_plain_streaming(api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int timeout, const char *host, uint16_t port, const api_retry_policy *retry_policy, const api_streaming_handler *streaming_handler, int &error_code);`
- `bool api_http_plain_socket_is_alive(api_connection_pool_handle &connection_handle);`
- `bool api_http_prepare_plain_socket(api_connection_pool_handle &connection_handle, const char *host, uint16_t port, int timeout, int &error_code);`
- `bool api_http_should_retry_plain(int error_code);`
- `bool api_http_stream_invoke_body(const api_streaming_handler *streaming_handler, const char *chunk_data, size_t chunk_size, bool is_final_chunk, int &error_code);`
- `bool api_http_stream_process_chunked_buffer(ft_string &buffer, long long &chunk_remaining, bool &trailers_pending, bool &final_chunk_sent, const api_streaming_handler *streaming_handler, int &error_code);`
- `bool api_https_execute_http2_streaming( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int timeout, const char *ca_certificate, bool verify_peer, const char *host, uint16_t port, const char *security_identity, const api_retry_policy *retry_policy, const api_streaming_handler *streaming_handler, bool &used_http2, int &error_code);`
- `bool api_https_execute_streaming(api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int timeout, const char *ca_certificate, bool verify_peer, const char *host, uint16_t port, const char *security_identity, const api_retry_policy *retry_policy, const api_streaming_handler *streaming_handler, int &error_code);`
- `bool api_retry_circuit_allow(const api_connection_pool_handle &handle, const api_retry_policy *retry_policy, int &error_code);`
- `char *api_http_execute_plain(api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int *status, int timeout, const char *host, uint16_t port, const api_retry_policy *retry_policy, int &error_code);`
- `char *api_http_execute_plain_http2(api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int *status, int timeout, const char *host, uint16_t port, const api_retry_policy *retry_policy, bool &used_http2, int &error_code);`
- `char *api_https_execute(api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int *status, int timeout, const char *ca_certificate, bool verify_peer, const char *host, uint16_t port, const char *security_identity, const api_retry_policy *retry_policy, int &error_code);`
- `char *api_https_execute_http2(api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int *status, int timeout, const char *ca_certificate, bool verify_peer, const char *host, uint16_t port, const char *security_identity, const api_retry_policy *retry_policy, bool &used_http2, int &error_code);`
- `inline int api_retry_get_circuit_cooldown(const api_retry_policy *retry_policy)`
- `inline int api_retry_get_circuit_threshold(const api_retry_policy *retry_policy)`
- `inline int api_retry_get_half_open_successes(const api_retry_policy *retry_policy)`
- `inline int api_retry_get_initial_delay(const api_retry_policy *retry_policy)`
- `inline int api_retry_get_max_attempts(const api_retry_policy *retry_policy)`
- `inline int api_retry_get_max_delay(const api_retry_policy *retry_policy)`
- `inline int api_retry_get_multiplier(const api_retry_policy *retry_policy)`
- `inline int api_retry_next_delay(int current_delay, int max_delay, int multiplier)`
- `inline int api_retry_prepare_delay(int delay, int max_delay)`
- `void api_http_stream_invoke_headers( const api_streaming_handler *streaming_handler, int status_code, const char *headers);`
- `void api_request_set_resolve_error(int resolver_status);`
- `void api_request_set_ssl_error(SSL *ssl_session, int operation_result);`
- `void api_retry_circuit_record_failure(const api_connection_pool_handle &handle, const api_retry_policy *retry_policy);`
- `void api_retry_circuit_record_success(const api_connection_pool_handle &handle, const api_retry_policy *retry_policy);`
- `void api_retry_circuit_reset(void);`

### API/api_http_plain.cpp

- `bool api_http_execute_plain_http2_streaming( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int timeout, const char *host, uint16_t port, const api_retry_policy *retry_policy, const api_streaming_handler *streaming_handler, bool &used_http2, int &error_code)`
- `bool api_http_execute_plain_streaming( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int timeout, const char *host, uint16_t port, const api_retry_policy *retry_policy, const api_streaming_handler *streaming_handler, int &error_code)`
- `bool api_http_plain_socket_is_alive(api_connection_pool_handle &connection_handle)`
- `bool api_http_prepare_plain_socket( api_connection_pool_handle &connection_handle, const char *host, uint16_t port, int timeout, int &error_code)`
- `bool api_http_should_retry_plain(int error_code)`
- `bool api_http_stream_invoke_body( const api_streaming_handler *streaming_handler, const char *chunk_data, size_t chunk_size, bool is_final_chunk, int &error_code)`
- `bool api_http_stream_process_chunked_buffer(ft_string &buffer, long long &chunk_remaining, bool &trailers_pending, bool &final_chunk_sent, const api_streaming_handler *streaming_handler, int &error_code)`
- `char *api_http_execute_plain(api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int *status, int timeout, const char *host, uint16_t port, const api_retry_policy *retry_policy, int &error_code)`
- `char *api_http_execute_plain_http2(api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int *status, int timeout, const char *host, uint16_t port, const api_retry_policy *retry_policy, bool &used_http2, int &error_code)`
- `static bool api_http_execute_plain_http2_streaming_once( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int timeout, const char *host, uint16_t port, const api_retry_policy *retry_policy, const api_streaming_handler *streaming_handler, bool &connection_close, bool &used_http2, int &error_code)`
- `static bool api_http_execute_plain_http2_streaming_once( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int timeout, const char *host, uint16_t port, const api_retry_policy *retry_policy, const api_streaming_handler *streaming_handler, bool &connection_close, bool &used_http2, int &error_code);`
- `static bool api_http_execute_plain_streaming_once( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int timeout, const api_streaming_handler *streaming_handler, bool &connection_close, int &error_code)`
- `static bool api_http_execute_plain_streaming_once( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int timeout, const api_streaming_handler *streaming_handler, bool &connection_close, int &error_code);`
- `static bool api_http_http2_failure_requires_eviction(int error_code)`
- `static bool api_http_is_recoverable_send_error(int error_code)`
- `static bool api_http_plain_socket_is_connected(int descriptor)`
- `static bool api_http_prepare_request(const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, ft_string &request, int &error_code)`
- `static bool api_http_receive_response(api_connection_pool_handle &connection_handle, ft_socket &socket_wrapper, ft_string &response, size_t &header_length, bool &connection_close, bool &chunked_encoding, bool &has_length, long long &content_length, int &error_code, const api_streaming_handler *streaming_handler, const ft_string *prefetched_response)`
- `static bool api_http_send_payload(ft_socket &socket_wrapper, json_group *payload, int &error_code)`
- `static bool api_http_send_request(ft_socket &socket_wrapper, const ft_string &request, int &error_code)`
- `static bool api_http_socket_send_callback(const char *data_pointer, size_t data_length, void *context, int &error_code)`
- `static bool api_http_streaming_flush_buffer(ft_string &streaming_body_buffer, bool has_length, long long content_length, size_t &streaming_delivered, bool &final_chunk_sent, bool chunked_encoding, long long &chunk_stream_remaining, bool &chunk_stream_trailers, const api_streaming_handler *streaming_handler, int &error_code)`
- `static char *api_http_execute_plain_http2_once( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int *status, int timeout, const char *host, uint16_t port, bool &used_http2, int &error_code)`
- `static char *api_http_execute_plain_http2_once( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int *status, int timeout, const char *host, uint16_t port, bool &used_http2, int &error_code);`
- `static char *api_http_execute_plain_once( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int *status, int timeout, int &error_code, const ft_string *prefetched_response, bool skip_send)`
- `static char *api_http_finalize_downgrade_response( api_connection_pool_handle &connection_handle, const ft_string &handshake_buffer, size_t header_length, bool chunked_encoding, bool has_length, long long content_length, bool connection_close, int *status, int &error_code)`
- `static void api_http_map_send_error(int &send_error_code)`
- `static void api_http_reset_plain_socket(api_connection_pool_handle &connection_handle)`
- `void api_http_stream_invoke_headers( const api_streaming_handler *streaming_handler, int status_code, const char *headers)`

### API/api_http_tls.cpp

- `bool api_https_execute_http2_streaming( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int timeout, const char *ca_certificate, bool verify_peer, const char *host, uint16_t port, const char *security_identity, const api_retry_policy *retry_policy, const api_streaming_handler *streaming_handler, bool &used_http2, int &error_code)`
- `bool api_https_execute_streaming(api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int timeout, const char *ca_certificate, bool verify_peer, const char *host, uint16_t port, const char *security_identity, const api_retry_policy *retry_policy, const api_streaming_handler *streaming_handler, int &error_code)`
- `char *api_https_execute(api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int *status, int timeout, const char *ca_certificate, bool verify_peer, const char *host, uint16_t port, const char *security_identity, const api_retry_policy *retry_policy, int &error_code)`
- `char *api_https_execute_http2(api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int *status, int timeout, const char *ca_certificate, bool verify_peer, const char *host, uint16_t port, const char *security_identity, const api_retry_policy *retry_policy, bool &used_http2, int &error_code)`
- `static bool api_http_apply_timeouts(ft_socket &socket_wrapper, int timeout)`
- `static bool api_https_ensure_session( api_connection_pool_handle &connection_handle, int timeout, const char *ca_certificate, bool verify_peer, int &error_code)`
- `static bool api_https_execute_streaming_once( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int timeout, const char *ca_certificate, bool verify_peer, const api_streaming_handler *streaming_handler, bool &connection_close, int &error_code)`
- `static bool api_https_prepare_request(const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, ft_string &request, int &error_code)`
- `static bool api_https_prepare_socket(api_connection_pool_handle &connection_handle, const char *host, uint16_t port, int timeout, const char *security_identity, int &error_code)`
- `static bool api_https_receive_response(SSL *ssl_session, ft_string &response, size_t &header_length, bool &connection_close, bool &chunked_encoding, bool &has_length, long long &content_length, int &error_code, const api_streaming_handler *streaming_handler)`
- `static bool api_https_send_callback(const char *data_pointer, size_t data_length, void *context, int &error_code)`
- `static bool api_https_send_payload(SSL *ssl_session, json_group *payload, int &error_code)`
- `static bool api_https_send_request(SSL *ssl_session, const ft_string &request, int &error_code)`
- `static bool api_https_should_retry(int error_code)`
- `static bool api_https_streaming_flush_buffer(ft_string &streaming_body_buffer, bool has_length, long long content_length, size_t &streaming_delivered, bool &final_chunk_sent, bool chunked_encoding, long long &chunk_stream_remaining, bool &chunk_stream_trailers, const api_streaming_handler *streaming_handler, int &error_code)`
- `static bool ssl_pointer_supports_network_checks(SSL *ssl)`
- `static char *api_https_execute_http2_once( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int *status, int timeout, const char *ca_certificate, bool verify_peer, bool &used_http2, int &error_code)`
- `static char *api_https_execute_http2_once( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int *status, int timeout, const char *ca_certificate, bool verify_peer, bool &used_http2, int &error_code);`
- `static char *api_https_execute_once( api_connection_pool_handle &connection_handle, const char *method, const char *path, const char *host_header, json_group *payload, const char *headers, int *status, int timeout, const char *ca_certificate, bool verify_peer, int &error_code)`
- `static ssize_t ssl_send_all(SSL *ssl, const void *data, size_t size)`
- `void api_request_set_ssl_error(SSL *ssl_session, int operation_result)`

### API/api_internal.hpp

- `bool api_append_content_length_header(ft_string &request, size_t content_length);`
- `bool api_connection_pool_acquire(api_connection_pool_handle &handle, const char *host, uint16_t port, api_connection_security_mode security_mode, const char *security_identity);`
- `bool api_connection_pool_is_enabled(void);`
- `bool api_connection_pool_track_tls_session(SSL *tls_session);`
- `bool api_connection_pool_untrack_tls_session(SSL *tls_session);`
- `bool api_is_configuration_socket_error(int error_code);`
- `int api_debug_get_last_async_receive_state(void);`
- `int api_debug_get_last_async_receive_timeout(void);`
- `int api_debug_get_last_async_send_state(void);`
- `int api_debug_get_last_async_send_timeout(void);`
- `long long api_connection_pool_get_idle_timeout(void);`
- `size_t api_connection_pool_get_max_idle(void);`
- `size_t api_debug_get_connection_pool_acquires(void);`
- `size_t api_debug_get_connection_pool_misses(void);`
- `size_t api_debug_get_connection_pool_reuses(void);`
- `size_t api_debug_get_last_async_bytes_received(void);`
- `size_t api_debug_get_last_async_bytes_sent(void);`
- `size_t api_debug_get_last_async_request_size(void);`
- `void api_connection_pool_disable_store(api_connection_pool_handle &handle);`
- `void api_connection_pool_evict(api_connection_pool_handle &handle);`
- `void api_connection_pool_flush(void);`
- `void api_connection_pool_mark_idle(api_connection_pool_handle &handle);`
- `void api_connection_pool_set_enabled(bool enabled);`
- `void api_connection_pool_set_idle_timeout(long long idle_timeout_ms);`
- `void api_connection_pool_set_max_idle(size_t max_idle);`
- `void api_debug_reset_connection_pool_counters(void);`
- `void api_request_set_downgrade_wait_hook( api_request_wait_until_ready_hook hook);`

### API/api_promise.cpp

- `bool api_string_promise::request(const char *ip, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout)`
- `bool api_tls_promise::request(const char *host, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout)`
- `bool api_tls_string_promise::request(const char *host, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout)`

### API/api_request.cpp

- `bool api_request(const char *ip, uint16_t port, const char *method, const char *path, const api_streaming_handler *streaming_handler, json_group *payload, const char *headers, int timeout, bool enable_http2, bool *used_http2, const api_retry_policy *retry_policy)`
- `bool api_request_stream(const char *ip, uint16_t port, const char *method, const char *path, const api_streaming_handler *streaming_handler, json_group *payload, const char *headers, int timeout, const api_retry_policy *retry_policy)`
- `bool api_request_stream_host(const char *host, uint16_t port, const char *method, const char *path, const api_streaming_handler *streaming_handler, json_group *payload, const char *headers, int timeout, const api_retry_policy *retry_policy)`
- `bool api_request_stream_http2(const char *ip, uint16_t port, const char *method, const char *path, const api_streaming_handler *streaming_handler, json_group *payload, const char *headers, int timeout, bool *used_http2, const api_retry_policy *retry_policy)`
- `char *api_request_string(const char *ip, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `char *api_request_string_basic(const char *ip, uint16_t port, const char *method, const char *path, const char *credentials, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `char *api_request_string_bearer(const char *ip, uint16_t port, const char *method, const char *path, const char *token, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `char *api_request_string_host(const char *host, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `char *api_request_string_host_basic(const char *host, uint16_t port, const char *method, const char *path, const char *credentials, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `char *api_request_string_host_bearer(const char *host, uint16_t port, const char *method, const char *path, const char *token, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `char *api_request_string_http2(const char *ip, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout, bool *used_http2, const api_retry_policy *retry_policy)`
- `char *api_request_string_url(const char *url, const char *method, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `json_group *api_request_json(const char *ip, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `json_group *api_request_json_basic(const char *ip, uint16_t port, const char *method, const char *path, const char *credentials, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `json_group *api_request_json_bearer(const char *ip, uint16_t port, const char *method, const char *path, const char *token, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `json_group *api_request_json_host(const char *host, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `json_group *api_request_json_host_basic(const char *host, uint16_t port, const char *method, const char *path, const char *credentials, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `json_group *api_request_json_host_bearer(const char *host, uint16_t port, const char *method, const char *path, const char *token, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `json_group *api_request_json_http2(const char *ip, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout, bool *used_http2, const api_retry_policy *retry_policy)`
- `json_group *api_request_json_url(const char *url, const char *method, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `static bool parse_url(const char *url, bool &tls, ft_string &host, uint16_t &port, ft_string &path, int &error_code)`
- `static int api_request_assign_resolve_error(int mapped_error)`
- `void api_request_set_downgrade_wait_hook( api_request_wait_until_ready_hook hook)`

### API/api_request_async.cpp

- `bool api_request_json_async(const char *ip, uint16_t port, const char *method, const char *path, api_json_callback callback, void *user_data, json_group *payload, const char *headers, int timeout)`
- `bool api_request_json_http2_async(const char *ip, uint16_t port, const char *method, const char *path, api_json_callback callback, void *user_data, json_group *payload, const char *headers, int timeout, bool *used_http2)`
- `bool api_request_json_tls_http2_async(const char *host, uint16_t port, const char *method, const char *path, api_json_callback callback, void *user_data, json_group *payload, const char *headers, int timeout, bool *used_http2)`
- `bool api_request_string_async(const char *ip, uint16_t port, const char *method, const char *path, api_callback callback, void *user_data, json_group *payload, const char *headers, int timeout)`
- `bool api_request_string_http2_async(const char *ip, uint16_t port, const char *method, const char *path, api_callback callback, void *user_data, json_group *payload, const char *headers, int timeout, bool *used_http2)`
- `bool api_request_string_tls_http2_async(const char *host, uint16_t port, const char *method, const char *path, api_callback callback, void *user_data, json_group *payload, const char *headers, int timeout, bool *used_http2)`
- `int api_debug_get_last_async_receive_state(void)`
- `int api_debug_get_last_async_receive_timeout(void)`
- `int api_debug_get_last_async_send_state(void)`
- `int api_debug_get_last_async_send_timeout(void)`
- `size_t api_debug_get_last_async_bytes_received(void)`
- `size_t api_debug_get_last_async_bytes_sent(void)`
- `size_t api_debug_get_last_async_request_size(void)`
- `static bool api_async_build_request(const api_async_request &data, ft_string &request)`
- `static bool api_request_string_ends_with_crlf(const ft_string &value)`
- `static int api_async_calculate_receive_timeout( const ft_string &request, int timeout_ms, int send_timeout_ms)`
- `static int api_async_calculate_send_timeout(const ft_string &request, int timeout_ms)`
- `static std::atomic<int> g_api_async_last_receive_state(0);`
- `static std::atomic<int> g_api_async_last_receive_timeout(0);`
- `static std::atomic<int> g_api_async_last_send_state(0);`
- `static std::atomic<int> g_api_async_last_send_timeout(0);`
- `static std::atomic<size_t> g_api_async_last_bytes_received(0);`
- `static std::atomic<size_t> g_api_async_last_bytes_sent(0);`
- `static void api_async_worker(api_async_request *data)`
- `static void api_json_async_wrapper(char *body, int status, void *user_data)`
- `static void api_request_append_header_block(ft_string &request, const ft_string &block)`
- `static void api_request_reset_async_debug_counters(void)`
- `static void api_request_trim_header_block(ft_string &headers)`

### API/api_request_error.cpp

- `bool api_is_configuration_socket_error(int error_code)`

### API/api_request_signing.cpp

- `int api_apply_hmac_signature_header(const api_hmac_signature_input &input, const unsigned char *key, std::size_t key_length, const char *header_name, ft_string &header_output) noexcept`
- `int api_build_oauth1_authorization_header( const api_oauth1_parameters &parameters, ft_string &header_output) noexcept`
- `int api_request_signing_add_parameter( std::vector<api_oauth_parameter_entry> &entries, const char *key, const char *value) noexcept`
- `int api_request_signing_append(ft_string &target, const char *value) noexcept`
- `int api_request_signing_append_character(ft_string &target, char value) noexcept`
- `int api_request_signing_append_header_parameter(ft_string &target, const char *key, const char *value, int &is_first) noexcept`
- `int api_request_signing_append_normalized( ft_string &target, const std::vector<api_oauth_parameter_entry> &entries) noexcept`
- `int api_request_signing_build_canonical( const api_hmac_signature_input &input, ft_string &canonical) noexcept`
- `int api_request_signing_finish(int result) noexcept`
- `int api_request_signing_get_error() noexcept`
- `int api_request_signing_percent_encode(const char *input, ft_string &output) noexcept`
- `int api_request_signing_uppercase(const char *input, ft_string &output) noexcept`
- `int api_sign_request_hmac_sha256(const api_hmac_signature_input &input, const unsigned char *key, std::size_t key_length, ft_string &signature_output) noexcept`
- `void api_request_signing_set_error(int error_code) noexcept`

### API/api_request_signing.hpp

- `int api_apply_hmac_signature_header(const api_hmac_signature_input &input, const unsigned char *key, std::size_t key_length, const char *header_name, ft_string &header_output) noexcept;`
- `int api_build_oauth1_authorization_header( const api_oauth1_parameters &parameters, ft_string &header_output) noexcept;`
- `int api_sign_request_hmac_sha256(const api_hmac_signature_input &input, const unsigned char *key, std::size_t key_length, ft_string &signature_output) noexcept;`

### API/api_request_tls.cpp

- `bool api_request_json_tls_async(const char *host, uint16_t port, const char *method, const char *path, api_json_callback callback, void *user_data, json_group *payload, const char *headers, int timeout)`
- `bool api_request_stream_tls(const char *host, uint16_t port, const char *method, const char *path, const api_streaming_handler *streaming_handler, json_group *payload, const char *headers, int timeout, const char *ca_certificate, bool verify_peer, const api_retry_policy *retry_policy)`
- `bool api_request_stream_tls_http2(const char *host, uint16_t port, const char *method, const char *path, const api_streaming_handler *streaming_handler, json_group *payload, const char *headers, int timeout, const char *ca_certificate, bool verify_peer, bool *used_http2, const api_retry_policy *retry_policy)`
- `bool api_request_string_tls_async(const char *host, uint16_t port, const char *method, const char *path, api_callback callback, void *user_data, json_group *payload, const char *headers, int timeout)`
- `char *api_request_https(const char *ip, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout, const char *ca_certificate, bool verify_peer, const api_retry_policy *retry_policy)`
- `char *api_request_https_http2(const char *ip, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout, const char *ca_certificate, bool verify_peer, bool *used_http2, const api_retry_policy *retry_policy)`
- `char *api_request_string_tls(const char *host, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `char *api_request_string_tls_basic(const char *host, uint16_t port, const char *method, const char *path, const char *credentials, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `char *api_request_string_tls_bearer(const char *host, uint16_t port, const char *method, const char *path, const char *token, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `char *api_request_string_tls_http2(const char *host, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout, bool *used_http2, const api_retry_policy *retry_policy)`
- `json_group *api_request_json_tls(const char *host, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `json_group *api_request_json_tls_basic(const char *host, uint16_t port, const char *method, const char *path, const char *credentials, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `json_group *api_request_json_tls_bearer(const char *host, uint16_t port, const char *method, const char *path, const char *token, json_group *payload, const char *headers, int *status, int timeout, const api_retry_policy *retry_policy)`
- `json_group *api_request_json_tls_http2(const char *host, uint16_t port, const char *method, const char *path, json_group *payload, const char *headers, int *status, int timeout, bool *used_http2, const api_retry_policy *retry_policy)`
- `static void api_json_async_wrapper(char *body, int status, void *user_data)`
- `static void api_request_assign_network_error(int mapped_error, int fallback)`
- `static void api_tls_async_worker(api_tls_async_request *data)`

### API/api_retry.cpp

- `bool api_retry_circuit_allow(const api_connection_pool_handle &handle, const api_retry_policy *retry_policy, int &error_code)`
- `static api_circuit_state *api_retry_circuit_find_state( ft_vector<api_circuit_state> &states, const ft_string &key)`
- `static api_circuit_state *api_retry_circuit_get_state( ft_vector<api_circuit_state> &states, const ft_string &key)`
- `static bool api_retry_circuit_keys_match(const ft_string &lhs, const char *rhs)`
- `static ft_vector<api_circuit_state> &api_retry_circuit_get_states(void)`
- `static long long api_retry_circuit_compute_deadline(long long now_ms, int cooldown_ms)`
- `static long long api_retry_circuit_now(void)`
- `static pt_mutex &api_retry_circuit_get_mutex(void)`
- `void api_retry_circuit_record_failure(const api_connection_pool_handle &handle, const api_retry_policy *retry_policy)`
- `void api_retry_circuit_record_success(const api_connection_pool_handle &handle, const api_retry_policy *retry_policy)`
- `void api_retry_circuit_reset(void)`

### API/api_retry_policy.cpp

- `const char *api_retry_policy::get_error_str() const noexcept`
- `int api_retry_policy::get_backoff_multiplier() const noexcept`
- `int api_retry_policy::get_circuit_breaker_cooldown_ms() const noexcept`
- `int api_retry_policy::get_circuit_breaker_half_open_successes() const noexcept`
- `int api_retry_policy::get_circuit_breaker_threshold() const noexcept`
- `int api_retry_policy::get_error() const noexcept`
- `int api_retry_policy::get_initial_delay_ms() const noexcept`
- `int api_retry_policy::get_max_attempts() const noexcept`
- `int api_retry_policy::get_max_delay_ms() const noexcept`
- `int api_retry_policy::lock_pair(const api_retry_policy &first, const api_retry_policy &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard) noexcept`
- `void api_retry_policy::record_operation_error_unlocked(int error_code) noexcept`
- `void api_retry_policy::reset() noexcept`
- `void api_retry_policy::set_backoff_multiplier(int value) noexcept`
- `void api_retry_policy::set_circuit_breaker_cooldown_ms(int value) noexcept`
- `void api_retry_policy::set_circuit_breaker_half_open_successes(int value) noexcept`
- `void api_retry_policy::set_circuit_breaker_threshold(int value) noexcept`
- `void api_retry_policy::set_error(int error) const noexcept`
- `void api_retry_policy::set_initial_delay_ms(int value) noexcept`
- `void api_retry_policy::set_max_attempts(int value) noexcept`
- `void api_retry_policy::set_max_delay_ms(int value) noexcept`

### API/api_streaming_handler.cpp

- `bool api_streaming_handler::invoke_body_callback(const char *chunk_data, size_t chunk_size, bool is_final_chunk, bool &should_continue) const noexcept`
- `bool api_streaming_handler::invoke_headers_callback(int status_code, const char *headers) const noexcept`
- `const char *api_streaming_handler::get_error_str() const noexcept`
- `int api_streaming_handler::get_error() const noexcept`
- `int api_streaming_handler::lock_pair(const api_streaming_handler &first, const api_streaming_handler &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard) noexcept`
- `static void api_streaming_handler_sleep_backoff() noexcept`
- `void api_streaming_handler::record_operation_error_unlocked(int error_code) noexcept`
- `void api_streaming_handler::reset() noexcept`
- `void api_streaming_handler::set_body_callback( api_stream_body_callback callback) noexcept`
- `void api_streaming_handler::set_error(int error) const noexcept`
- `void api_streaming_handler::set_headers_callback( api_stream_headers_callback callback) noexcept`
- `void api_streaming_handler::set_user_data(void *user_data) noexcept`

### API/api_tls_client.cpp

- `bool api_tls_client::is_valid() const`
- `bool api_tls_client::populate_handshake_diagnostics()`
- `bool api_tls_client::refresh_handshake_diagnostics()`
- `bool api_tls_client::request_async(const char *method, const char *path, json_group *payload, const char *headers, api_callback callback, void *user_data)`
- `char *api_tls_client::request(const char *method, const char *path, json_group *payload, const char *headers, int *status)`
- `const api_tls_handshake_diagnostics &api_tls_client::get_handshake_diagnostics() const noexcept`
- `const char *api_tls_client::get_error_str() const noexcept`
- `ft_thread worker([this, method, path, payload, headers, callback, user_data]()`
- `int api_tls_client::get_error() const noexcept`
- `json_group *api_tls_client::request_json(const char *method, const char *path, json_group *payload, const char *headers, int *status)`
- `static bool ssl_pointer_supports_network_checks(SSL *ssl)`
- `static bool tls_append_certificate_diagnostic( api_tls_handshake_diagnostics &diagnostics, X509 *certificate)`
- `static bool tls_compute_certificate_fingerprint(X509 *certificate, ft_string &output)`
- `static bool tls_copy_bio_to_string(BIO *memory, ft_string &output)`
- `static bool tls_extract_asn1_time(const ASN1_TIME *time_value, ft_string &output)`
- `static bool tls_extract_serial_number(const ASN1_INTEGER *serial_value, ft_string &output)`
- `static bool tls_extract_x509_name(X509_NAME *name, ft_string &output)`
- `static bool tls_fill_certificate_diagnostic(X509 *certificate, api_tls_certificate_diagnostics &diagnostic)`
- `static bool tls_header_equals(const ft_string &header_name, const char *target_name)`
- `static char tls_ascii_to_lower(char character)`
- `static char tls_string_char_at(const ft_string &value, size_t index)`
- `static ft_string tls_string_substr(const ft_string &value, size_t start_index, size_t length)`
- `static size_t tls_string_find_char(const ft_string &value, char needle, size_t start_index)`
- `static size_t tls_string_find_substring(const ft_string &value, const char *needle, size_t start_index)`
- `static ssize_t ssl_send_all(SSL *ssl, const void *data, size_t size)`
- `static void tls_log_handshake_diagnostics( const api_tls_handshake_diagnostics &diagnostics, const ft_string &host)`
- `static void tls_string_to_lower(ft_string &value)`
- `static void tls_trim_whitespace(ft_string &value)`
- `void api_tls_client::record_operation_error_unlocked(int error_code) noexcept`
- `void api_tls_client::set_error(int error_code) const noexcept`

### API/api_transport_hooks.cpp

- `const api_transport_hooks *api_get_transport_hooks(void)`
- `static void api_transport_reset_hooks(api_transport_hooks &hooks)`
- `void api_clear_transport_hooks(void)`
- `void api_set_transport_hooks(const api_transport_hooks *hooks)`

### API/promise.hpp

- `public: bool request(const char *ip, uint16_t port, const char *method, const char *path, json_group *payload = ft_nullptr, const char *headers = ft_nullptr, int *status = ft_nullptr, int timeout = 60000);`

### CMA/CMA.hpp

- `char **cma_split(char const *string, char delimiter) __attribute__ ((warn_unused_result));`
- `char *cma_itoa(int number) __attribute__ ((warn_unused_result));`
- `char *cma_itoa_base(int number, int base) __attribute__ ((warn_unused_result));`
- `char *cma_strdup(const char *string) __attribute__ ((warn_unused_result));`
- `char *cma_strjoin(char const *string_1, char const *string_2) __attribute__ ((warn_unused_result));`
- `char *cma_strjoin_multiple(int count, ...) __attribute__ ((warn_unused_result));`
- `char *cma_strndup(const char *string, size_t maximum_length) __attribute__ ((warn_unused_result));`
- `char *cma_strtrim(const char *string, const char *set) __attribute__ ((warn_unused_result));`
- `char *cma_substr(const char *source, unsigned int start, size_t length) __attribute__ ((warn_unused_result));`
- `ft_size_t cma_alloc_size(const void* ptr) __attribute__ ((warn_unused_result, hot));`
- `ft_size_t cma_block_size(const void *memory_pointer) __attribute__ ((warn_unused_result, hot));`
- `int *cma_atoi(const char *string) __attribute__ ((warn_unused_result));`
- `int cma_backend_is_enabled(void) __attribute__ ((warn_unused_result));`
- `int cma_checked_block_size(const void *memory_pointer, ft_size_t *block_size) __attribute__ ((warn_unused_result, hot));`
- `int cma_checked_free(void* ptr) __attribute__ ((warn_unused_result, hot));`
- `int cma_set_backend(const cma_backend_hooks *hooks) __attribute__ ((warn_unused_result));`
- `void *cma_aligned_alloc(ft_size_t alignment, ft_size_t size) __attribute__ ((warn_unused_result, hot));`
- `void *cma_calloc(ft_size_t count, ft_size_t size) __attribute__ ((warn_unused_result));`
- `void *cma_malloc(ft_size_t size) __attribute__ ((warn_unused_result, hot));`
- `void *cma_memdup(const void *source, size_t size) __attribute__ ((warn_unused_result));`
- `void *cma_realloc(void* ptr, ft_size_t new_size) __attribute__ ((warn_unused_result));`
- `void cma_clear_backend(void);`
- `void cma_free(void* ptr) __attribute__ ((hot));`
- `void cma_free_double(char **content);`
- `void cma_get_extended_stats(ft_size_t *allocation_count, ft_size_t *free_count, ft_size_t *current_bytes, ft_size_t *peak_bytes);`
- `void cma_get_stats(ft_size_t *allocation_count, ft_size_t *free_count);`
- `void cma_set_alloc_limit(ft_size_t limit);`
- `void cma_set_thread_safety(bool enable);`

### CMA/cma_aligned_alloc.cpp

- `static Block *find_aligned_free_block(ft_size_t aligned_size, ft_size_t alignment, ft_size_t *padding)`
- `static ft_size_t calculate_alignment_padding(Block *block, ft_size_t alignment)`
- `static ft_size_t compute_extended_page_request(ft_size_t aligned_size, ft_size_t alignment)`
- `static int block_supports_aligned_request(Block *block, ft_size_t aligned_size, ft_size_t alignment, ft_size_t *padding)`
- `static void *aligned_alloc_offswitch(ft_size_t alignment, ft_size_t request_size, int *error_code)`
- `void *cma_aligned_alloc(ft_size_t alignment, ft_size_t size)`

### CMA/cma_alloc_limit_guard.cpp

- `bool cma_alloc_limit_guard::is_active() const`
- `cma_alloc_limit_guard cma_make_alloc_limit_guard(ft_size_t new_limit)`
- `const char *cma_alloc_limit_guard::get_error_str() const`
- `int cma_alloc_limit_guard::get_error() const`
- `void cma_alloc_limit_guard::reset(ft_size_t new_limit)`
- `void cma_alloc_limit_guard::set_error(int error_code) const`

### CMA/cma_alloc_limit_guard.hpp

- `bool is_active() const;`
- `cma_alloc_limit_guard cma_make_alloc_limit_guard(ft_size_t new_limit);`
- `const char *get_error_str() const;`
- `int get_error() const;`
- `public: explicit cma_alloc_limit_guard(ft_size_t new_limit);`
- `void reset(ft_size_t new_limit);`
- `void set_error(int error_code) const;`

### CMA/cma_alloc_size.cpp

- `ft_size_t cma_alloc_size(const void *memory_pointer)`
- `int cma_checked_block_size(const void *memory_pointer, ft_size_t *block_size)`

### CMA/cma_allocation_guard.cpp

- `bool cma_allocation_guard::owns_allocation() const`
- `cma_allocation_guard cma_make_allocation_guard(void *memory_pointer)`
- `const char *cma_allocation_guard::get_error_str() const`
- `int cma_allocation_guard::get_error() const`
- `static int cma_allocation_guard_release_allocation(void *memory_pointer, bool *invalid_state_detected)`
- `void *cma_allocation_guard::get() const`
- `void *cma_allocation_guard::release()`
- `void cma_allocation_guard::reset(void *memory_pointer)`
- `void cma_allocation_guard::set_error(int error_code) const`

### CMA/cma_allocation_guard.hpp

- `bool owns_allocation() const;`
- `cma_allocation_guard cma_make_allocation_guard(void *memory_pointer);`
- `const char *get_error_str() const;`
- `explicit cma_allocation_guard(void *memory_pointer);`
- `int get_error() const;`
- `public: cma_allocation_guard();`
- `void *get() const;`
- `void *release();`
- `void reset(void *memory_pointer);`
- `void set_error(int error_code) const;`

### CMA/cma_allocator_guard.cpp

- `bool cma_allocator_guard::acquire_allocator_mutex()`
- `bool cma_allocator_guard::acquire_mutex(pthread_mutex_t *mutex_pointer)`
- `bool cma_allocator_guard::is_active() const`
- `bool cma_allocator_guard::lock_acquired() const`
- `bool cma_allocator_guard::mutex_vector_contains(const pt_mutex_vector &mutexes, pthread_mutex_t *mutex_pointer) const`
- `bool cma_allocator_guard::reacquire_mutexes(const cma_guard_vector<s_mutex_entry> &previous_mutexes)`
- `bool cma_allocator_guard::track_mutex_acquisition(pthread_mutex_t *mutex_pointer, bool lock_acquired)`
- `const char *cma_allocator_guard::get_error_str() const`
- `int cma_allocator_guard::get_error() const`
- `int cma_allocator_guard::release_all_mutexes()`
- `int cma_lock_allocator(bool *lock_acquired)`
- `int cma_unlock_allocator(bool lock_acquired)`
- `pt_mutex_vector cma_allocator_guard::owned_mutex_pointers() const`
- `static bool initialize_cma_allocator_mutex(pthread_mutex_t **mutex_storage)`
- `static int cma_allocator_mutex_get_error()`
- `static pthread_mutex_t *cma_allocator_mutex(void)`
- `static void cma_allocator_mutex_set_error(int error_code)`
- `void cma_allocator_guard::log_inactive_guard(void *return_address) const`
- `void cma_allocator_guard::set_error(int error) const`
- `void cma_allocator_guard::sleep_random_backoff() const`
- `void cma_allocator_guard::unlock()`

### CMA/cma_backend.cpp

- `ft_size_t cma_backend_block_size(const void *memory_pointer)`
- `int cma_backend_checked_block_size(const void *memory_pointer, ft_size_t *block_size)`
- `int cma_backend_deallocate(void *memory_pointer)`
- `int cma_backend_is_enabled(void)`
- `int cma_backend_owns_pointer(const void *memory_pointer)`
- `int cma_set_backend(const cma_backend_hooks *hooks)`
- `static ft_size_t cma_backend_query_size(const void *memory_pointer)`
- `static int cma_backend_query_ownership(const void *memory_pointer)`
- `static void cma_backend_set_error(int *error_code, int value)`
- `static void cma_backend_track_allocation(ft_size_t allocation_size)`
- `static void cma_backend_track_free(ft_size_t allocation_size)`
- `static void cma_backend_update_stats_for_resize(ft_size_t previous_size, ft_size_t new_size)`
- `void *cma_backend_aligned_allocate(ft_size_t alignment, ft_size_t size, int *error_code)`
- `void *cma_backend_allocate(ft_size_t size, int *error_code)`
- `void *cma_backend_reallocate(void *memory_pointer, ft_size_t size, int *error_code)`
- `void cma_clear_backend(void)`

### CMA/cma_debug.cpp

- `ft_size_t cma_debug_allocation_size(ft_size_t requested_size)`
- `ft_size_t cma_debug_guard_size(void)`
- `ft_size_t cma_debug_user_size(const Block *block)`
- `static unsigned char *cma_debug_base_pointer(Block *block)`
- `static unsigned char *cma_debug_const_base_pointer(const Block *block)`
- `static void cma_debug_abort(void)`
- `unsigned char *cma_debug_user_pointer(const Block *block)`
- `void cma_debug_initialize_block(Block *block)`
- `void cma_debug_prepare_allocation(Block *block, ft_size_t user_size)`
- `void cma_debug_release_allocation(Block *block, const char *context, const void *user_pointer)`

### CMA/cma_error_stack.cpp

- `void cma_record_internal_operation_error(int error_code)`
- `void cma_record_operation_error(int error_code)`

### CMA/cma_internal.hpp

- `Block *cma_find_block_for_pointer(const void *memory_pointer);`
- `Block *cma_metadata_allocate_block(void) __attribute__ ((warn_unused_result));`
- `Block *find_free_block(ft_size_t size);`
- `Block *merge_block(Block *block);`
- `Block *split_block(Block *block, ft_size_t size);`
- `Page *create_page(ft_size_t size);`
- `Page *find_page_of_block(Block *block);`
- `__attribute__ ((aligned(16)));`
- `bool cma_metadata_guard_decrement(void);`
- `bool cma_metadata_guard_increment(void);`
- `ft_size_t cma_backend_block_size(const void *memory_pointer) __attribute__ ((warn_unused_result, hot));`
- `ft_size_t cma_debug_guard_size(void);`
- `ft_size_t cma_debug_user_size(const Block *block);`
- `inline __attribute__((always_inline, hot)) bool cma_block_is_free(const Block *block)`
- `inline __attribute__((always_inline, hot)) ft_size_t align16(ft_size_t size)`
- `inline __attribute__((always_inline, hot)) void cma_mark_block_allocated(Block *block)`
- `inline __attribute__((always_inline, hot)) void cma_mark_block_free(Block *block)`
- `inline __attribute__((always_inline, hot)) void cma_update_block_magic(Block *block)`
- `inline ft_size_t cma_block_user_size(const Block *block)`
- `inline ft_size_t cma_debug_guard_size(void)`
- `inline ft_size_t cma_debug_user_size(const Block *block)`
- `inline unsigned char *cma_debug_user_pointer(const Block *block)`
- `inline void cma_debug_initialize_block(Block *block)`
- `inline void cma_debug_prepare_allocation(Block *block, ft_size_t user_size)`
- `inline void cma_debug_release_allocation(Block *block, const char *context, const void *user_pointer)`
- `int cma_backend_checked_block_size(const void *memory_pointer, ft_size_t *block_size) __attribute__ ((warn_unused_result, hot));`
- `int cma_backend_deallocate(void *memory_pointer) __attribute__ ((hot));`
- `int cma_backend_is_enabled(void) __attribute__ ((warn_unused_result));`
- `int cma_backend_owns_pointer(const void *memory_pointer) __attribute__ ((warn_unused_result));`
- `int cma_lock_allocator(bool *lock_acquired);`
- `int cma_unlock_allocator(bool lock_acquired);`
- `unsigned char *cma_debug_user_pointer(const Block *block);`
- `void *cma_backend_aligned_allocate(ft_size_t alignment, ft_size_t size, int *error_code) __attribute__ ((warn_unused_result, hot));`
- `void *cma_backend_allocate(ft_size_t size, int *error_code) __attribute__ ((warn_unused_result, hot));`
- `void *cma_backend_reallocate(void *memory_pointer, ft_size_t size, int *error_code) __attribute__ ((warn_unused_result, hot));`
- `void cma_debug_initialize_block(Block *block);`
- `void cma_debug_prepare_allocation(Block *block, ft_size_t user_size);`
- `void cma_debug_release_allocation(Block *block, const char *context, const void *user_pointer);`
- `void cma_metadata_make_inaccessible(void);`
- `void cma_metadata_release_block(Block *block);`
- `void cma_metadata_reset(void);`
- `void cma_record_internal_operation_error(int error_code);`
- `void cma_record_operation_error(int error_code);`
- `void cma_validate_block(Block *block, const char *context, void *user_pointer);`
- `void free_page_if_empty(Page *page);`

### CMA/cma_itoa.cpp

- `char *cma_itoa(int number)`
- `static char *convert_int(int number, int is_negative, int *error_code)`
- `static char *fill_digits(char *characters, unsigned int number, int start_index)`

### CMA/cma_itoa_base.cpp

- `char *cma_itoa_base(int number, int base)`

### CMA/cma_metadata.cpp

- `bool cma_metadata_guard_decrement(void)`
- `bool cma_metadata_guard_increment(void)`
- `int cma_metadata_make_writable(void)`
- `static bool cma_metadata_add_chunk(void)`
- `static bool cma_metadata_add_chunk(void);`
- `static ft_size_t cma_metadata_compute_page_size(void)`
- `void cma_metadata_make_inaccessible(void)`
- `void cma_metadata_release_block(Block *block)`
- `void cma_metadata_reset(void)`

### CMA/cma_realloc.cpp

- `static void *allocate_block_locked(ft_size_t aligned_size, ft_size_t user_size)`
- `static void release_block_locked(Block *block)`
- `void *cma_realloc(void* ptr, ft_size_t new_size)`

### CMA/cma_split.cpp

- `char **cma_split(char const *string, char delimiter)`
- `static char **ft_copy_strings(char **strings, const char *string, char delimiter)`
- `static char **ft_malloc_strings(char **strings, const char *string, char delimiter, int *error_code)`
- `static char **ft_memory_error(char **strings)`

### CMA/cma_strjoin.cpp

- `char *cma_strjoin(char const *string_1, char const *string_2)`

### CMA/cma_strtrim.cpp

- `char *cma_strtrim(const char *input_string, const char *set)`

### CMA/cma_utils.cpp

- `Block *cma_find_block_for_pointer(const void *memory_pointer)`
- `Block *find_free_block(ft_size_t size)`
- `Block *merge_block(Block *block)`
- `Block* split_block(Block* block, ft_size_t size)`
- `Page *create_page(ft_size_t size)`
- `Page *find_page_of_block(Block *block)`
- `static ft_size_t minimum_split_payload(void)`
- `static int are_blocks_adjacent(Block *left_block, Block *right_block)`
- `static int8_t determine_which_block_to_use(ft_size_t size)`
- `static void *create_stack_block(void)`
- `static void determine_page_use(Page *page)`
- `static void report_corrupted_block(Block *block, const char *context, void *user_pointer)`
- `static void verify_backward_link(Block *block, Block *previous_block)`
- `static void verify_forward_link(Block *block, Block *next_block)`
- `void cma_get_extended_stats(ft_size_t *allocation_count, ft_size_t *free_count, ft_size_t *current_bytes, ft_size_t *peak_bytes)`
- `void cma_get_stats(ft_size_t *allocation_count, ft_size_t *free_count)`
- `void cma_validate_block(Block *block, const char *context, void *user_pointer)`
- `void free_page_if_empty(Page *page)`

### CPP_class/class_big_number.hpp

- `ft_big_number big_number_from_hex_string(const char* hex_digits) noexcept;`
- `ft_string big_number_to_hex_string(const ft_big_number& number) noexcept;`

### CPP_class/class_data_buffer.hpp

- `bool bad() const noexcept;`
- `bool good() const noexcept;`
- `bool seek(size_t pos) noexcept;`
- `const ft_vector<uint8_t>& data() const noexcept;`
- `ft_operation_error_stack &operation_error_stack() const noexcept;`
- `int lock_self() const noexcept;`
- `int read_length_locked(size_t &len) noexcept;`
- `int unlock_self() const noexcept;`
- `int write_length_locked(size_t len) noexcept;`
- `public: DataBuffer() noexcept;`
- `size_t size() const noexcept;`
- `size_t tell() const noexcept;`
- `static int lock_pair(const DataBuffer &first, const DataBuffer &second, const DataBuffer *&lower, const DataBuffer *&upper) noexcept;`
- `static int unlock_pair(const DataBuffer *lower, const DataBuffer *upper) noexcept;`
- `static void sleep_backoff() noexcept;`
- `void clear() noexcept;`
- `void record_operation_error(int error_code) const;`

### CPP_class/class_fd_istream.hpp

- `int get_fd() const noexcept;`
- `int lock_self(ft_unique_lock<pt_mutex> &guard) const noexcept;`
- `protected: std::size_t do_read(char *buffer, std::size_t count);`
- `public: ft_fd_istream(int fd) noexcept;`
- `void record_operation_error(int error_code) const noexcept;`
- `void set_fd(int fd) noexcept;`

### CPP_class/class_file.hpp

- `const char *get_error_str() const noexcept;`
- `ft_operation_error_stack &operation_error_stack() const noexcept;`
- `int copy_to(const char *destination_path) noexcept;`
- `int copy_to_with_buffer(const char *destination_path, size_t buffer_size) noexcept;`
- `int get_error() const noexcept;`
- `int get_fd() const;`
- `int open(const char* filename, int flags) noexcept;`
- `int open(const char* filename, int flags, mode_t mode) noexcept;`
- `int printf(const char *format, ...) __attribute__((format(printf, 2, 3), hot));`
- `int seek(off_t offset, int whence) noexcept;`
- `pt_recursive_mutex &recursive_mutex() noexcept;`
- `public: ft_file() noexcept;`
- `ssize_t read(char *buffer, int count) noexcept;`
- `ssize_t write(const char *string) noexcept;`
- `ssize_t write_buffer(const char *buffer, size_t length) noexcept;`
- `static int lock_pair(const ft_file &first, const ft_file &second, const ft_file *&lower, const ft_file *&upper);`
- `static int unlock_pair(const ft_file *lower, const ft_file *upper);`
- `static void sleep_backoff();`
- `void close() noexcept;`
- `void record_operation_error(int error_code) const;`

### CPP_class/class_file_stream.hpp

- `int ft_file_stream_copy(ft_file &source_file, ft_file &destination_file, size_t buffer_size) noexcept;`

### CPP_class/class_istream.hpp

- `bool bad() const noexcept;`
- `const char *get_error_str() const noexcept;`
- `int get_error() const noexcept;`
- `int lock_self(ft_unique_lock<pt_recursive_mutex> &guard) const noexcept;`
- `protected: ft_istream() noexcept;`
- `pt_recursive_mutex *get_mutex_for_validation() const noexcept;`
- `public: virtual ~ft_istream() noexcept;`
- `static const char *last_operation_error_str() noexcept;`
- `static const char *operation_error_str_at(ft_size_t index) noexcept;`
- `static int last_operation_error() noexcept;`
- `static int lock_pair(const ft_istream &first, const ft_istream &second, ft_unique_lock<pt_recursive_mutex> &first_guard, ft_unique_lock<pt_recursive_mutex> &second_guard) noexcept;`
- `static int operation_error_at(ft_size_t index) noexcept;`
- `static int operation_error_index() noexcept;`
- `static int pop_oldest_operation_error() noexcept;`
- `static void pop_operation_errors() noexcept;`
- `static void record_operation_error(int error_code) noexcept;`
- `std::size_t gcount() const noexcept;`
- `virtual std::size_t do_read(char *buffer, std::size_t count) = 0;`
- `void read(char *buffer, std::size_t count);`
- `void set_error(int error_code) const noexcept;`
- `void set_error_unlocked(int error_code) const noexcept;`

### CPP_class/class_istringstream.hpp

- `ft_string str() const;`
- `protected: std::size_t do_read(char *buffer, std::size_t count);`
- `public: ft_istringstream(const ft_string &string) noexcept;`

### CPP_class/class_nullptr.hpp

- `public: ft_nullptr_t() noexcept;`

### CPP_class/class_ofstream.hpp

- `int lock_self(ft_unique_lock<pt_recursive_mutex> &guard) const noexcept;`
- `int open(const char *filename) noexcept;`
- `public: ft_ofstream() noexcept;`
- `ssize_t write(const char *string) noexcept;`
- `static int capture_guard_error() noexcept;`
- `static int finalize_lock(ft_unique_lock<pt_recursive_mutex> &guard) noexcept;`
- `void close() noexcept;`
- `void record_operation_error(int error_code) const noexcept;`

### CPP_class/class_string.hpp

- `bool empty() const noexcept;`
- `char *data() noexcept;`
- `char back() noexcept;`
- `char* print() noexcept;`
- `const char *at(size_t index) const noexcept;`
- `const char *c_str() const noexcept;`
- `const char *data() const noexcept;`
- `explicit ft_string(int error_code) noexcept;`
- `ft_operation_error_stack *operation_error_stack_handle() const noexcept;`
- `ft_string substr(size_t index, size_t count = npos) const noexcept;`
- `int lock_self(mutex_guard &guard) const noexcept;`
- `int pop_operation_error(unsigned long long operation_id) const noexcept;`
- `pt_recursive_mutex *get_mutex_for_validation() const noexcept;`
- `public: ft_string() noexcept;`
- `size_t find(const char *substring) const noexcept;`
- `size_t find(const ft_string &substring) const noexcept;`
- `size_t size() const noexcept;`
- `static const char *last_operation_error_str() noexcept;`
- `static const char *operation_error_str_at(size_t index) noexcept;`
- `static int last_operation_error() noexcept;`
- `static int lock_pair(const ft_string &first, const ft_string &second, mutex_guard &first_guard, mutex_guard &second_guard) noexcept;`
- `static int operation_error_at(size_t index) noexcept;`
- `static int operation_error_index() noexcept;`
- `static int pop_oldest_operation_error() noexcept;`
- `static void pop_operation_errors() noexcept;`
- `static void reset_error_owner(const ft_string *owner) noexcept;`
- `static void sleep_backoff() noexcept;`
- `unsigned long long last_operation_id() const noexcept;`
- `unsigned long long push_error(int error_code) const noexcept;`
- `unsigned long long push_error_unlocked(int error_code) const noexcept;`
- `void append(char character) noexcept;`
- `void append(const char *string) noexcept;`
- `void append(const char *string, size_t length) noexcept;`
- `void append(const ft_string &string) noexcept;`
- `void append_char_unlocked(char character) noexcept;`
- `void append_unlocked(const char *string, size_t length) noexcept;`
- `void assign(const char *string, size_t length) noexcept;`
- `void assign(size_t count, char character) noexcept;`
- `void assign_unlocked(const char *string, size_t length) noexcept;`
- `void assign_unlocked(size_t count, char character) noexcept;`
- `void clear() noexcept;`
- `void clear_unlocked() noexcept;`
- `void ensure_empty_buffer_unlocked() noexcept;`
- `void erase(std::size_t index, std::size_t count) noexcept;`
- `void erase_unlocked(std::size_t index, std::size_t count) noexcept;`
- `void move(ft_string& other) noexcept;`
- `void move_unlocked(ft_string &other) noexcept;`
- `void push_back(char character) noexcept;`
- `void resize(size_t new_capacity) noexcept;`
- `void resize_length(size_t new_length) noexcept;`
- `void resize_length_unlocked(size_t new_length) noexcept;`
- `void resize_unlocked(size_t new_capacity) noexcept;`

### CPP_class/class_stringbuf.hpp

- `bool is_valid() const noexcept;`
- `const char *get_error_str() const noexcept;`
- `ft_string str() const;`
- `int get_error() const noexcept;`
- `int lock_self(ft_unique_lock<pt_recursive_mutex> &guard) const noexcept;`
- `pt_recursive_mutex *get_mutex_for_validation() const noexcept;`
- `public: ft_stringbuf(const ft_string &string) noexcept;`
- `static const char *last_operation_error_str() noexcept;`
- `static const char *operation_error_str_at(ft_size_t index) noexcept;`
- `static int last_operation_error() noexcept;`
- `static int lock_pair(const ft_stringbuf &first, const ft_stringbuf &second, ft_unique_lock<pt_recursive_mutex> &first_guard, ft_unique_lock<pt_recursive_mutex> &second_guard) noexcept;`
- `static int operation_error_at(ft_size_t index) noexcept;`
- `static int operation_error_index() noexcept;`
- `static int pop_oldest_operation_error() noexcept;`
- `static void pop_operation_errors() noexcept;`
- `static void record_operation_error(int error_code) noexcept;`
- `std::size_t read(char *buffer, std::size_t count);`
- `void set_error(int error_code) const noexcept;`
- `void set_error_unlocked(int error_code) const noexcept;`

### CPP_class/cpp_class_big_number.cpp

- `bool ft_big_number::empty() const noexcept`
- `bool ft_big_number::is_negative() const noexcept`
- `bool ft_big_number::is_positive() const noexcept`
- `bool ft_big_number::is_zero_value() const noexcept`
- `cleanup_division: if (operation_error != FT_ERR_SUCCESSS)`
- `cleanup_modulus: if (operation_error != FT_ERR_SUCCESSS)`
- `const char* ft_big_number::c_str() const noexcept`
- `const char* ft_big_number::last_operation_error_str() noexcept`
- `const char* ft_big_number::operation_error_str_at(ft_size_t index) noexcept`
- `finalize_add: if (operation_error == FT_ERR_SUCCESSS && ft_big_number::last_operation_error() != FT_ERR_SUCCESSS)`
- `finalize_multiply: if (operation_error == FT_ERR_SUCCESSS && ft_big_number::last_operation_error() != FT_ERR_SUCCESSS)`
- `finalize_subtract: if (operation_error == FT_ERR_SUCCESSS && ft_big_number::last_operation_error() != FT_ERR_SUCCESSS)`
- `ft_big_number ft_big_number::add_magnitude(const ft_big_number& other) const noexcept`
- `ft_big_number ft_big_number::mod_pow(const ft_big_number& exponent, const ft_big_number& modulus) const noexcept`
- `ft_big_number ft_big_number::subtract_magnitude(const ft_big_number& other) const noexcept`
- `ft_size_t ft_big_number::size() const noexcept`
- `ft_string ft_big_number::to_string_base(int base) noexcept`
- `int ft_big_number::compare_magnitude(const ft_big_number& other) const noexcept`
- `int ft_big_number::error_for(unsigned long long operation_id) noexcept`
- `int ft_big_number::initialize_errno_keeper() noexcept`
- `int ft_big_number::last_error() noexcept`
- `int ft_big_number::last_operation_error() noexcept`
- `int ft_big_number::lock_pair(const ft_big_number &first, const ft_big_number &second, ft_big_number_mutex_guard &first_guard, ft_big_number_mutex_guard &second_guard) noexcept`
- `int ft_big_number::lock_self(ft_big_number_mutex_guard &guard) const noexcept`
- `int ft_big_number::operation_error_at(ft_size_t index) noexcept`
- `int ft_big_number::operation_error_index() noexcept`
- `int ft_big_number::pop_oldest_operation_error() noexcept`
- `static char ft_big_number_digit_symbol(int value) noexcept`
- `static int ft_big_number_digit_value(char digit) noexcept`
- `unsigned long long ft_big_number::last_op_id() noexcept`
- `void ft_big_number::append(const char* digits) noexcept`
- `void ft_big_number::append_digit(char digit) noexcept`
- `void ft_big_number::append_digit_unlocked(char digit) noexcept`
- `void ft_big_number::append_unlocked(const char* digits) noexcept`
- `void ft_big_number::append_unsigned(unsigned long value) noexcept`
- `void ft_big_number::append_unsigned_unlocked(unsigned long value) noexcept`
- `void ft_big_number::assign(const char* number) noexcept`
- `void ft_big_number::assign_base(const char* digits, int base) noexcept`
- `void ft_big_number::clear() noexcept`
- `void ft_big_number::clear_unlocked() noexcept`
- `void ft_big_number::finalize_errno_keeper(int stored_errno) noexcept`
- `void ft_big_number::pop_operation_errors() noexcept`
- `void ft_big_number::push_error(int error_code) const noexcept`
- `void ft_big_number::push_error_unlocked(int error_code) const noexcept`
- `void ft_big_number::record_operation_error(int error_code) noexcept`
- `void ft_big_number::reduce_to(ft_size_t new_size) noexcept`
- `void ft_big_number::reduce_to_unlocked(ft_size_t new_size) noexcept`
- `void ft_big_number::reserve(ft_size_t new_capacity) noexcept`
- `void ft_big_number::reset_system_error() const noexcept`
- `void ft_big_number::shrink_capacity() noexcept`
- `void ft_big_number::sleep_backoff() noexcept`
- `void ft_big_number::trim_leading_zeros() noexcept`
- `void ft_big_number::trim_leading_zeros_unlocked() noexcept`
- `void ft_big_number::update_errno_keeper(int &stored_errno, int new_value) noexcept`

### CPP_class/cpp_class_big_number_serialization.cpp

- `ft_big_number big_number_from_hex_string(const char* hex_digits) noexcept`

### CPP_class/cpp_class_data_buffer.cpp

- `bool DataBuffer::bad() const noexcept`
- `bool DataBuffer::good() const noexcept`
- `bool DataBuffer::seek(size_t pos) noexcept`
- `const ft_vector<uint8_t>& DataBuffer::data() const noexcept`
- `ft_operation_error_stack &DataBuffer::operation_error_stack() const noexcept`
- `int DataBuffer::lock_pair(const DataBuffer &first, const DataBuffer &second, const DataBuffer *&lower, const DataBuffer *&upper) noexcept`
- `int DataBuffer::lock_self() const noexcept`
- `int DataBuffer::read_length_locked(size_t &len) noexcept`
- `int DataBuffer::unlock_pair(const DataBuffer *lower, const DataBuffer *upper) noexcept`
- `int DataBuffer::unlock_self() const noexcept`
- `int DataBuffer::write_length_locked(size_t len) noexcept`
- `size_t DataBuffer::size() const noexcept`
- `size_t DataBuffer::tell() const noexcept`
- `static int data_buffer_unlock_mutex(const pt_mutex &mutex)`
- `void DataBuffer::clear() noexcept`
- `void DataBuffer::record_operation_error(int error_code) const`
- `void DataBuffer::sleep_backoff() noexcept`

### CPP_class/cpp_class_fd_istream.cpp

- `int ft_fd_istream::get_fd() const noexcept`
- `int ft_fd_istream::lock_self(ft_unique_lock<pt_mutex> &guard) const noexcept`
- `void ft_fd_istream::record_operation_error(int error_code) const noexcept`
- `void ft_fd_istream::set_fd(int fd) noexcept`

### CPP_class/cpp_class_file.cpp

- `const char *ft_file::get_error_str() const noexcept`
- `ft_operation_error_stack &ft_file::operation_error_stack() const noexcept`
- `int ft_file::copy_to(const char *destination_path) noexcept`
- `int ft_file::copy_to_with_buffer(const char *destination_path, size_t buffer_size) noexcept`
- `int ft_file::get_error() const noexcept`
- `int ft_file::get_fd() const`
- `int ft_file::lock_pair(const ft_file &first, const ft_file &second, const ft_file *&lower, const ft_file *&upper)`
- `int ft_file::open(const char* filename, int flags) noexcept`
- `int ft_file::open(const char* filename, int flags, mode_t mode) noexcept`
- `int ft_file::printf(const char *format, ...)`
- `int ft_file::seek(off_t offset, int whence) noexcept`
- `int ft_file::unlock_pair(const ft_file *lower, const ft_file *upper)`
- `pt_recursive_mutex &ft_file::recursive_mutex() noexcept`
- `ssize_t ft_file::read(char *buffer, int count) noexcept`
- `ssize_t ft_file::write(const char *string) noexcept`
- `ssize_t ft_file::write_buffer(const char *buffer, size_t length) noexcept`
- `static int ft_file_lock_mutex(const pt_recursive_mutex &mutex)`
- `static int ft_file_unlock_mutex(const pt_recursive_mutex &mutex)`
- `void ft_file::close() noexcept`
- `void ft_file::record_operation_error(int error_code) const`
- `void ft_file::sleep_backoff()`

### CPP_class/cpp_class_file_stream.cpp

- `int ft_file_stream_copy(ft_file &source_file, ft_file &destination_file, size_t buffer_size) noexcept`
- `static int ft_file_allocate_transfer_buffer(char **buffer_pointer, size_t buffer_size) noexcept`
- `static void ft_file_release_transfer_buffer(char *buffer_pointer) noexcept`

### CPP_class/cpp_class_istream.cpp

- `bool ft_istream::bad() const noexcept`
- `const char *ft_istream::get_error_str() const noexcept`
- `const char *ft_istream::last_operation_error_str() noexcept`
- `const char *ft_istream::operation_error_str_at(ft_size_t index) noexcept`
- `int ft_istream::get_error() const noexcept`
- `int ft_istream::last_operation_error() noexcept`
- `int ft_istream::lock_pair(const ft_istream &first, const ft_istream &second, ft_unique_lock<pt_recursive_mutex> &first_guard, ft_unique_lock<pt_recursive_mutex> &second_guard) noexcept`
- `int ft_istream::lock_self(ft_unique_lock<pt_recursive_mutex> &guard) const noexcept`
- `int ft_istream::operation_error_at(ft_size_t index) noexcept`
- `int ft_istream::operation_error_index() noexcept`
- `int ft_istream::pop_oldest_operation_error() noexcept`
- `pt_recursive_mutex *ft_istream::get_mutex_for_validation() const noexcept`
- `void ft_istream::pop_operation_errors() noexcept`
- `void ft_istream::read(char *buffer, std::size_t count)`
- `void ft_istream::record_operation_error(int error_code) noexcept`
- `void ft_istream::set_error(int error_code) const noexcept`
- `void ft_istream::set_error_unlocked(int error_code) const noexcept`

### CPP_class/cpp_class_istringstream.cpp

- `ft_string ft_istringstream::str() const`

### CPP_class/cpp_class_ofstream.cpp

- `int ft_ofstream::finalize_lock(ft_unique_lock<pt_recursive_mutex> &guard) noexcept`
- `int ft_ofstream::lock_self(ft_unique_lock<pt_recursive_mutex> &guard) const noexcept`
- `int ft_ofstream::open(const char *filename) noexcept`
- `ssize_t ft_ofstream::write(const char *string) noexcept`
- `void ft_ofstream::close() noexcept`
- `void ft_ofstream::record_operation_error(int error_code) const noexcept`

### CPP_class/cpp_class_string_methods.cpp

- `bool ft_string::empty() const noexcept`
- `bool ft_string::mutex_guard::owns_lock() const noexcept`
- `char ft_string::back() noexcept`
- `char* ft_string::data() noexcept`
- `char* ft_string::print() noexcept`
- `const char* ft_string::at(size_t index) const noexcept`
- `const char* ft_string::c_str() const noexcept`
- `const char* ft_string::data() const noexcept`
- `const char* ft_string::last_operation_error_str() noexcept`
- `const char* ft_string::operation_error_str_at(size_t index) noexcept`
- `ft_operation_error_stack *ft_string::operation_error_stack_handle() const noexcept`
- `ft_string ft_string::substr(size_t index, size_t count) const noexcept`
- `int ft_string::last_operation_error() noexcept`
- `int ft_string::lock_pair(const ft_string &first, const ft_string &second, mutex_guard &first_guard, mutex_guard &second_guard) noexcept`
- `int ft_string::lock_self(mutex_guard &guard) const noexcept`
- `int ft_string::mutex_guard::get_error() const noexcept`
- `int ft_string::mutex_guard::lock(pt_recursive_mutex &mutex) noexcept`
- `int ft_string::operation_error_at(size_t index) noexcept`
- `int ft_string::operation_error_index() noexcept`
- `int ft_string::pop_oldest_operation_error() noexcept`
- `int ft_string::pop_operation_error(unsigned long long operation_id) const noexcept`
- `pt_recursive_mutex *ft_string::get_mutex_for_validation() const noexcept`
- `size_t ft_string::find(const char *substring) const noexcept`
- `size_t ft_string::find(const ft_string &substring) const noexcept`
- `size_t ft_string::size() const noexcept`
- `static ft_operation_error_stack *ft_string_error_stack_owner(void) noexcept`
- `static int ft_string_current_error() noexcept`
- `unsigned long long ft_string::last_operation_id() const noexcept`
- `unsigned long long ft_string::push_error(int error_code) const noexcept`
- `unsigned long long ft_string::push_error_unlocked(int error_code) const noexcept`
- `void ft_string::append(char character) noexcept`
- `void ft_string::append(const char *string) noexcept`
- `void ft_string::append(const char *string, size_t length) noexcept`
- `void ft_string::append(const ft_string& string) noexcept`
- `void ft_string::append_char_unlocked(char character) noexcept`
- `void ft_string::append_unlocked(const char *string, size_t length) noexcept`
- `void ft_string::assign(const char *string, size_t length) noexcept`
- `void ft_string::assign(size_t count, char character) noexcept`
- `void ft_string::assign_unlocked(const char *string, size_t length) noexcept`
- `void ft_string::assign_unlocked(size_t count, char character) noexcept`
- `void ft_string::clear() noexcept`
- `void ft_string::clear_unlocked() noexcept`
- `void ft_string::ensure_empty_buffer_unlocked() noexcept`
- `void ft_string::erase(std::size_t index, std::size_t count) noexcept`
- `void ft_string::erase_unlocked(std::size_t index, std::size_t count) noexcept`
- `void ft_string::move(ft_string& other) noexcept`
- `void ft_string::move_unlocked(ft_string &other) noexcept`
- `void ft_string::mutex_guard::unlock() noexcept`
- `void ft_string::pop_operation_errors() noexcept`
- `void ft_string::push_back(char character) noexcept`
- `void ft_string::reset_error_owner(const ft_string *owner) noexcept`
- `void ft_string::resize(size_t new_capacity) noexcept`
- `void ft_string::resize_length(size_t new_length) noexcept`
- `void ft_string::resize_length_unlocked(size_t new_length) noexcept`
- `void ft_string::resize_unlocked(size_t new_capacity) noexcept`
- `void ft_string::sleep_backoff() noexcept`

### CPP_class/cpp_class_stringbuf.cpp

- `bool ft_stringbuf::is_valid() const noexcept`
- `const char *ft_stringbuf::get_error_str() const noexcept`
- `const char *ft_stringbuf::last_operation_error_str() noexcept`
- `const char *ft_stringbuf::operation_error_str_at(ft_size_t index) noexcept`
- `ft_string ft_stringbuf::str() const`
- `int ft_stringbuf::get_error() const noexcept`
- `int ft_stringbuf::last_operation_error() noexcept`
- `int ft_stringbuf::lock_pair(const ft_stringbuf &first, const ft_stringbuf &second, ft_unique_lock<pt_recursive_mutex> &first_guard, ft_unique_lock<pt_recursive_mutex> &second_guard) noexcept`
- `int ft_stringbuf::lock_self(ft_unique_lock<pt_recursive_mutex> &guard) const noexcept`
- `int ft_stringbuf::operation_error_at(ft_size_t index) noexcept`
- `int ft_stringbuf::operation_error_index() noexcept`
- `int ft_stringbuf::pop_oldest_operation_error() noexcept`
- `pt_recursive_mutex *ft_stringbuf::get_mutex_for_validation() const noexcept`
- `void ft_stringbuf::pop_operation_errors() noexcept`
- `void ft_stringbuf::record_operation_error(int error_code) noexcept`
- `void ft_stringbuf::set_error(int error_code) const noexcept`
- `void ft_stringbuf::set_error_unlocked(int error_code) const noexcept`

### Compatebility/Compatebility_cross_process_posix.cpp

- `int cmp_cross_process_close_mapping(cmp_cross_process_mapping *mapping)`
- `int cmp_cross_process_lock_mutex(const cross_process_message &message, cmp_cross_process_mapping *mapping, cmp_cross_process_mutex_state *mutex_state)`
- `int cmp_cross_process_open_mapping(const cross_process_message &message, cmp_cross_process_mapping *mapping)`
- `int cmp_cross_process_receive_descriptor(int socket_fd, cross_process_message &message)`
- `int cmp_cross_process_send_descriptor(int socket_fd, const cross_process_message &message)`
- `int cmp_cross_process_unlock_mutex(const cross_process_message &message, cmp_cross_process_mapping *mapping, cmp_cross_process_mutex_state *mutex_state)`

### Compatebility/Compatebility_cross_process_windows.cpp

- `int cmp_cross_process_close_mapping(cmp_cross_process_mapping *mapping)`
- `int cmp_cross_process_lock_mutex(const cross_process_message &message, cmp_cross_process_mapping *mapping, cmp_cross_process_mutex_state *mutex_state)`
- `int cmp_cross_process_open_mapping(const cross_process_message &message, cmp_cross_process_mapping *mapping)`
- `int cmp_cross_process_receive_descriptor(int socket_fd, cross_process_message &message)`
- `int cmp_cross_process_send_descriptor(int socket_fd, const cross_process_message &message)`
- `int cmp_cross_process_unlock_mutex(const cross_process_message &message, cmp_cross_process_mapping *mapping, cmp_cross_process_mutex_state *mutex_state)`

### Compatebility/Compatebility_dumb_render_linux_x11.cpp

- `ft_render_platform_result ft_render_platform_create_window( void **out_platform_state, ft_render_framebuffer *out_framebuffer, const ft_render_window_desc &desc )`
- `ft_render_platform_result ft_render_platform_destroy_window( void **platform_state, ft_render_framebuffer *framebuffer )`
- `ft_render_platform_result ft_render_platform_get_primary_screen_size(ft_render_screen_size *out_size)`
- `ft_render_platform_result ft_render_platform_poll_events( void *platform_state, bool *out_should_close )`
- `ft_render_platform_result ft_render_platform_present( void *platform_state, ft_render_framebuffer *framebuffer )`
- `ft_render_platform_result ft_render_platform_set_fullscreen( void *platform_state, bool enabled )`
- `static ft_render_platform_result ft_render_x11_create_image( ft_render_x11_state *state, ft_render_framebuffer *out_framebuffer )`
- `static void ft_render_x11_send_fullscreen_message(ft_render_x11_state *state, bool enabled)`

### Compatebility/Compatebility_dumb_render_win32.cpp

- `ft_render_platform_result ft_render_platform_create_window( void **out_platform_state, ft_render_framebuffer *out_framebuffer, const ft_render_window_desc &desc )`
- `ft_render_platform_result ft_render_platform_destroy_window( void **platform_state, ft_render_framebuffer *framebuffer )`
- `ft_render_platform_result ft_render_platform_get_primary_screen_size(ft_render_screen_size *out_size)`
- `ft_render_platform_result ft_render_platform_poll_events( void *platform_state, bool *out_should_close )`
- `ft_render_platform_result ft_render_platform_present( void *platform_state, ft_render_framebuffer *framebuffer )`
- `ft_render_platform_result ft_render_platform_set_fullscreen( void *platform_state, bool enabled )`
- `static LRESULT CALLBACK ft_render_win32_wndproc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)`
- `static ft_render_platform_result ft_render_win32_create_dib( ft_render_win32_state *state, ft_render_framebuffer *out_framebuffer )`
- `static void ft_render_win32_enter_fullscreen(ft_render_win32_state *state)`
- `static void ft_render_win32_leave_fullscreen(ft_render_win32_state *state)`

### Compatebility/Compatebility_file_dir.cpp

- `file_dirent *cmp_dir_read(file_dir *directory_stream, int *error_code_out)`
- `int cmp_dir_close(file_dir *directory_stream, int *error_code_out)`
- `int cmp_directory_exists(const char *path, int *error_code_out)`

### Compatebility/Compatebility_file_io.cpp

- `int cmp_close(int file_descriptor)`
- `int cmp_open(const char *path_name)`
- `int cmp_open(const char *path_name, int flags)`
- `int cmp_open(const char *path_name, int flags, int mode)`
- `int cmp_open(const char *path_name, int flags, mode_t mode)`
- `ssize_t cmp_read(int file_descriptor, void *buffer, size_t count)`
- `ssize_t cmp_read(int file_descriptor, void *buffer, unsigned int count)`
- `ssize_t cmp_write(int file_descriptor, const void *buffer, size_t count)`
- `ssize_t cmp_write(int file_descriptor, const void *buffer, unsigned int count)`
- `static HANDLE cmp_retrieve_handle(int file_descriptor)`
- `static int cmp_open_internal(const char *path_name, int flags, int mode)`
- `static int cmp_store_handle(HANDLE file_handle)`
- `static void cmp_clear_handle(int file_descriptor)`
- `void cmp_initialize_standard_file_descriptors()`

### Compatebility/Compatebility_file_ops.cpp

- `int cmp_file_copy(const char *source_path, const char *destination_path, int *error_code_out)`
- `int cmp_file_create_directory(const char *path, mode_t mode, int *error_code_out)`
- `int cmp_file_delete(const char *path, int *error_code_out)`
- `int cmp_file_exists(const char *path, int *error_code_out)`
- `int cmp_file_get_permissions(const char *path, mode_t *mode_out, int *error_code_out)`
- `int cmp_file_move(const char *source_path, const char *destination_path, int *error_code_out)`
- `void cmp_set_force_cross_device_move(int force_cross_device_move)`

### Compatebility/Compatebility_file_path.cpp

- `void cmp_normalize_slashes(char *data)`

### Compatebility/Compatebility_pthread.cpp

- `int cmp_thread_cancel(pthread_t thread)`
- `int cmp_thread_sleep(unsigned int milliseconds)`
- `int cmp_thread_wait_uint32(std::atomic<uint32_t> *address, uint32_t expected_value)`
- `int cmp_thread_wake_one_uint32(std::atomic<uint32_t> *address)`
- `int cmp_thread_yield()`
- `static cmp_wait_entry *cmp_wait_lookup_entry(std::atomic<uint32_t> *address) noexcept`
- `static int cmp_wait_create_entry(std::atomic<uint32_t> *address, cmp_wait_entry **entry_out) noexcept`
- `static int cmp_wait_remove_entry(cmp_wait_entry *entry) noexcept`

### Compatebility/Compatebility_readline.cpp

- `int cmp_readline_enable_raw_mode()`
- `int cmp_readline_terminal_dimensions(unsigned short *rows, unsigned short *cols, unsigned short *x_pixels, unsigned short *y_pixels)`
- `int cmp_readline_terminal_width()`
- `static int cmp_set_errno_from_errno()`
- `static int cmp_set_errno_from_last_error()`
- `void cmp_readline_disable_raw_mode()`

### Compatebility/Compatebility_rng.cpp

- `int cmp_rng_secure_bytes(unsigned char *buffer, size_t length)`
- `void cmp_clear_force_rng_failures(void)`
- `void cmp_clear_force_rng_failures(void);`
- `void cmp_force_rng_close_failure(int error_code)`
- `void cmp_force_rng_close_failure(int error_code);`
- `void cmp_force_rng_open_failure(int error_code)`
- `void cmp_force_rng_read_eof(void)`
- `void cmp_force_rng_read_eof(void);`
- `void cmp_force_rng_read_failure(int error_code)`
- `void cmp_force_rng_read_failure(int error_code);`

### Compatebility/Compatebility_syslog.cpp

- `void cmp_syslog_close(void)`
- `void cmp_syslog_write(const char *message)`

### Compatebility/Compatebility_system.cpp

- `char **cmp_get_environ_entries(void)`
- `char *cmp_get_home_directory(void)`
- `const char *cmp_system_strerror(int error_code)`
- `int cmp_get_total_memory(unsigned long long *total_memory)`
- `int cmp_last_error(void)`
- `int cmp_normalize_ft_errno(int error_code)`
- `int cmp_putenv(char *string)`
- `int cmp_secure_memzero(void *buffer, size_t length)`
- `int cmp_setenv(const char *name, const char *value, int overwrite)`
- `int cmp_unsetenv(const char *name)`
- `static inline void cmp_set_last_error(int error_code)`
- `std::time_t cmp_timegm(std::tm *time_pointer)`
- `unsigned int cmp_get_cpu_count(void)`
- `void cmp_clear_force_cpu_count_result(void)`
- `void cmp_clear_force_cpu_count_result(void);`
- `void cmp_clear_force_putenv_result(void)`
- `void cmp_clear_force_putenv_result(void);`
- `void cmp_clear_force_unsetenv_result(void)`
- `void cmp_clear_force_unsetenv_result(void);`
- `void cmp_set_force_cpu_count_failure(int errno_value)`
- `void cmp_set_force_cpu_count_failure(int errno_value);`
- `void cmp_set_force_cpu_count_success(unsigned int cpu_count)`
- `void cmp_set_force_cpu_count_success(unsigned int cpu_count);`
- `void cmp_set_force_putenv_result(int result, int errno_value)`
- `void cmp_set_force_putenv_result(int result, int errno_value);`
- `void cmp_set_force_putenv_windows_error(int last_error)`
- `void cmp_set_force_putenv_windows_error(int last_error);`
- `void cmp_set_force_total_memory_failure(int errno_value)`
- `void cmp_set_force_total_memory_failure(int errno_value);`
- `void cmp_set_force_total_memory_success(unsigned long long memory_size)`
- `void cmp_set_force_total_memory_success(unsigned long long memory_size);`
- `void cmp_set_force_unsetenv_result(int result, int errno_value)`
- `void cmp_set_force_unsetenv_result(int result, int errno_value);`
- `void cmp_set_force_unsetenv_windows_errors(int last_error, int socket_error)`
- `void cmp_set_force_unsetenv_windows_errors(int last_error, int socket_error);`

### Compatebility/Compatebility_time.cpp

- `int cmp_high_resolution_time(long long *nanoseconds_out)`
- `int cmp_time_get_time_of_day(struct timeval *time_value)`
- `static int cmp_timespec_to_nanoseconds(const struct timespec *time_value, long long *nanoseconds_out)`

### Compatebility/compatebility_cross_process.hpp

- `int cmp_cross_process_close_mapping(cmp_cross_process_mapping *mapping);`
- `int cmp_cross_process_lock_mutex(const cross_process_message &message, cmp_cross_process_mapping *mapping, cmp_cross_process_mutex_state *mutex_state);`
- `int cmp_cross_process_open_mapping(const cross_process_message &message, cmp_cross_process_mapping *mapping);`
- `int cmp_cross_process_receive_descriptor(int socket_fd, cross_process_message &message);`
- `int cmp_cross_process_send_descriptor(int socket_fd, const cross_process_message &message);`
- `int cmp_cross_process_unlock_mutex(const cross_process_message &message, cmp_cross_process_mapping *mapping, cmp_cross_process_mutex_state *mutex_state);`

### Compatebility/compatebility_internal.hpp

- `char **cmp_get_environ_entries(void);`
- `char *cmp_get_home_directory(void);`
- `char cmp_path_separator(void);`
- `const char *cmp_system_strerror(int error_code);`
- `file_dir *cmp_dir_open(const char *directory_path, int *error_code_out);`
- `file_dirent *cmp_dir_read(file_dir *directory_stream, int *error_code_out);`
- `int cmp_dir_close(file_dir *directory_stream, int *error_code_out);`
- `int cmp_directory_exists(const char *path, int *error_code_out);`
- `int cmp_file_copy(const char *source_path, const char *destination_path, int *error_code_out);`
- `int cmp_file_create_directory(const char *path, mode_t mode, int *error_code_out);`
- `int cmp_file_delete(const char *path, int *error_code_out);`
- `int cmp_file_exists(const char *path, int *error_code_out);`
- `int cmp_file_get_permissions(const char *path, mode_t *mode_out, int *error_code_out);`
- `int cmp_file_move(const char *source_path, const char *destination_path, int *error_code_out);`
- `int cmp_get_total_memory(unsigned long long *total_memory);`
- `int cmp_high_resolution_time(long long *nanoseconds_out);`
- `int cmp_last_error(void);`
- `int cmp_localtime(const std::time_t *time_value, std::tm *output);`
- `int cmp_map_system_error_to_ft(int error_code);`
- `int cmp_normalize_ft_errno(int error_code);`
- `int cmp_open(const char *path_name);`
- `int cmp_open(const char *path_name, int flags);`
- `int cmp_open(const char *path_name, int flags, int mode);`
- `int cmp_open(const char *path_name, int flags, mode_t mode);`
- `int cmp_putenv(char *string);`
- `int cmp_readline_enable_raw_mode(void);`
- `int cmp_readline_terminal_dimensions(unsigned short *rows, unsigned short *cols, unsigned short *x_pixels, unsigned short *y_pixels);`
- `int cmp_readline_terminal_width(void);`
- `int cmp_rng_secure_bytes(unsigned char *buffer, size_t length);`
- `int cmp_secure_memzero(void *buffer, size_t length);`
- `int cmp_setenv(const char *name, const char *value, int overwrite);`
- `int cmp_syslog_open(const char *identifier);`
- `int cmp_thread_cancel(pthread_t thread);`
- `int cmp_thread_equal(pthread_t thread1, pthread_t thread2);`
- `int cmp_thread_sleep(unsigned int milliseconds);`
- `int cmp_thread_wait_uint32(std::atomic<uint32_t> *address, uint32_t expected_value);`
- `int cmp_thread_wake_one_uint32(std::atomic<uint32_t> *address);`
- `int cmp_thread_yield(void);`
- `int cmp_time_get_time_of_day(struct timeval *time_value);`
- `int cmp_unsetenv(const char *name);`
- `ssize_t cmp_read(int file_descriptor, void *buffer, size_t count);`
- `ssize_t cmp_read(int file_descriptor, void *buffer, unsigned int count);`
- `ssize_t cmp_socket_send_all(ft_socket *socket_object, const void *buffer, size_t length, int flags);`
- `ssize_t cmp_su_write(int file_descriptor, const char *buffer, size_t length);`
- `ssize_t cmp_write(int file_descriptor, const void *buffer, size_t count);`
- `ssize_t cmp_write(int file_descriptor, const void *buffer, unsigned int count);`
- `std::time_t cmp_timegm(std::tm *time_pointer);`
- `unsigned int cmp_get_cpu_count(void);`
- `void cmp_initialize_standard_file_descriptors();`
- `void cmp_normalize_slashes(char *data);`
- `void cmp_readline_disable_raw_mode(void);`
- `void cmp_syslog_close(void);`
- `void cmp_syslog_write(const char *message);`

### Compression/compression.hpp

- `int ft_compress_stream(int input_fd, int output_fd);`
- `int ft_compress_stream_with_options(int input_fd, int output_fd, const t_compress_stream_options *options);`
- `int ft_compress_string_to_vector(const ft_string &input, ft_vector<unsigned char> &output);`
- `int ft_compress_vector_to_vector(const ft_vector<unsigned char> &input, ft_vector<unsigned char> &output);`
- `int ft_decompress_stream(int input_fd, int output_fd);`
- `int ft_decompress_stream_with_options(int input_fd, int output_fd, const t_compress_stream_options *options);`
- `int ft_decompress_vector_to_string(const ft_vector<unsigned char> &input, ft_string &output);`
- `int ft_decompress_vector_to_vector(const ft_vector<unsigned char> &input, ft_vector<unsigned char> &output);`
- `unsigned char *compress_buffer(const unsigned char *input_buffer, std::size_t input_size, std::size_t *compressed_size);`
- `unsigned char *decompress_buffer(const unsigned char *input_buffer, std::size_t input_size, std::size_t *decompressed_size);`
- `unsigned char *ft_base64_decode(const unsigned char *input_buffer, std::size_t input_size, std::size_t *decoded_size);`
- `unsigned char *ft_base64_encode(const unsigned char *input_buffer, std::size_t input_size, std::size_t *encoded_size);`
- `unsigned char *ft_compress(const unsigned char *input_buffer, std::size_t input_size, std::size_t *compressed_size);`
- `unsigned char *ft_decompress(const unsigned char *input_buffer, std::size_t input_size, std::size_t *decompressed_size);`
- `void ft_compress_stream_apply_ratio_preset(t_compress_stream_options *options);`
- `void ft_compress_stream_apply_speed_preset(t_compress_stream_options *options);`

### Compression/compression_base64.cpp

- `static int is_base64_whitespace(unsigned char character)`
- `unsigned char *ft_base64_decode(const unsigned char *input_buffer, std::size_t input_size, std::size_t *decoded_size)`
- `unsigned char *ft_base64_encode(const unsigned char *input_buffer, std::size_t input_size, std::size_t *encoded_size)`

### Compression/compression_stream.cpp

- `const char *t_compress_stream_options::get_error_str() const`
- `int ft_compress_stream(int input_fd, int output_fd)`
- `int ft_compress_stream_with_options(int input_fd, int output_fd, const t_compress_stream_options *options)`
- `int ft_decompress_stream(int input_fd, int output_fd)`
- `int ft_decompress_stream_with_options(int input_fd, int output_fd, const t_compress_stream_options *options)`
- `int t_compress_stream_options::get_compression_level() const`
- `int t_compress_stream_options::get_error() const`
- `int t_compress_stream_options::get_memory_level() const`
- `int t_compress_stream_options::get_strategy() const`
- `int t_compress_stream_options::get_window_bits() const`
- `int t_compress_stream_options::reset(void)`
- `int t_compress_stream_options::set_callbacks(t_compress_stream_progress_callback progress_callback, t_compress_stream_cancel_callback cancel_callback, void *user_data)`
- `int t_compress_stream_options::set_cancel_callback(t_compress_stream_cancel_callback callback, void *user_data)`
- `int t_compress_stream_options::set_compression_level(int compression_level)`
- `int t_compress_stream_options::set_input_buffer_size(std::size_t input_buffer_size)`
- `int t_compress_stream_options::set_memory_level(int memory_level)`
- `int t_compress_stream_options::set_output_buffer_size(std::size_t output_buffer_size)`
- `int t_compress_stream_options::set_progress_callback(t_compress_stream_progress_callback callback, void *user_data)`
- `int t_compress_stream_options::set_strategy(int strategy)`
- `int t_compress_stream_options::set_window_bits(int window_bits)`
- `int t_compress_stream_options::snapshot(struct s_compress_stream_options_snapshot *snapshot) const`
- `static int compress_stream_default_deflate(z_stream *stream, int flush_mode)`
- `static int compress_stream_default_deflate_init(z_stream *stream, int compression_level)`
- `static int compression_stream_allocate_buffers(const t_compress_stream_options *options, unsigned char **input_buffer, std::size_t *input_buffer_size, unsigned char **output_buffer, std::size_t *output_buffer_size)`
- `static int compression_stream_begin_deflate(z_stream *stream, const t_compress_stream_options *options)`
- `static int compression_stream_check_cancel(const t_compress_stream_options *options, const t_compress_stream_progress *progress)`
- `static int compression_stream_dispatch_progress(const t_compress_stream_options *options, const t_compress_stream_progress *progress)`
- `static int compression_stream_validate_tuning(const t_compress_stream_options *options)`
- `static int decompress_stream_default_inflate(z_stream *stream, int flush_mode)`
- `static int decompress_stream_default_inflate_init(z_stream *stream)`
- `static int map_zlib_error(int zlib_status)`
- `static t_compress_stream_deflate_init_hook compression_stream_get_deflate_init_hook(void)`
- `static t_compress_stream_deflate_init_hook compression_stream_get_deflate_init_hook(void);`
- `static void compression_stream_init_snapshot(struct s_compress_stream_options_snapshot *snapshot)`
- `static void compression_stream_release_buffers(unsigned char *input_buffer, unsigned char *output_buffer)`
- `t_compress_stream_cancel_callback t_compress_stream_options::get_cancel_callback() const`
- `t_compress_stream_progress_callback t_compress_stream_options::get_progress_callback() const`
- `void *t_compress_stream_options::get_callback_user_data() const`
- `void ft_compress_stream_apply_ratio_preset(t_compress_stream_options *options)`
- `void ft_compress_stream_apply_speed_preset(t_compress_stream_options *options)`
- `void ft_compress_stream_set_deflate_hook(t_compress_stream_deflate_hook hook)`
- `void ft_compress_stream_set_deflate_init_hook(t_compress_stream_deflate_init_hook hook)`
- `void ft_decompress_stream_set_inflate_hook(t_decompress_stream_inflate_hook hook)`
- `void ft_decompress_stream_set_inflate_init_hook(t_decompress_stream_inflate_init_hook hook)`
- `void t_compress_stream_options::set_error(int error_code) const`

### Compression/compression_stream_test_hooks.hpp

- `void ft_compress_stream_set_deflate_hook(t_compress_stream_deflate_hook hook);`
- `void ft_compress_stream_set_deflate_init_hook(t_compress_stream_deflate_init_hook hook);`
- `void ft_decompress_stream_set_inflate_hook(t_decompress_stream_inflate_hook hook);`
- `void ft_decompress_stream_set_inflate_init_hook(t_decompress_stream_inflate_init_hook hook);`

### Compression/compression_zlib.cpp

- `int ft_compress_string_to_vector(const ft_string &input, ft_vector<unsigned char> &output)`
- `int ft_compress_vector_to_vector(const ft_vector<unsigned char> &input, ft_vector<unsigned char> &output)`
- `int ft_decompress_vector_to_string(const ft_vector<unsigned char> &input, ft_string &output)`
- `int ft_decompress_vector_to_vector(const ft_vector<unsigned char> &input, ft_vector<unsigned char> &output)`
- `static int compression_assign_string(ft_string &destination, const unsigned char *buffer, std::size_t size)`
- `static int compression_store_in_vector(ft_vector<unsigned char> &destination, const unsigned char *buffer, std::size_t size)`
- `static int compression_string_pop_error(const ft_string &string_value)`
- `unsigned char *compress_buffer(const unsigned char *input_buffer, std::size_t input_size, std::size_t *compressed_size)`
- `unsigned char *decompress_buffer(const unsigned char *input_buffer, std::size_t input_size, std::size_t *decompressed_size)`
- `unsigned char *ft_compress(const unsigned char *input_buffer, std::size_t input_size, std::size_t *compressed_size)`
- `unsigned char *ft_decompress(const unsigned char *input_buffer, std::size_t input_size, std::size_t *decompressed_size)`

### Config/config.hpp

- `char **cnfg_parse_long_flags(int argument_count, char **argument_values);`
- `char *cnfg_parse_flags(int argument_count, char **argument_values);`
- `cnfg_config *cnfg_config_create();`
- `cnfg_config *cnfg_parse(const char *filename);`
- `cnfg_config *config_load_env();`
- `cnfg_config *config_load_file(const char *filename);`
- `cnfg_config *config_merge(const cnfg_config *base_config, const cnfg_config *override_config);`
- `int cnfg_config_prepare_thread_safety(cnfg_config *config);`
- `int cnfg_entry_lock(cnfg_entry *entry, bool *lock_acquired);`
- `int cnfg_entry_prepare_thread_safety(cnfg_entry *entry);`
- `int config_write_file(const cnfg_config *config, const char *filename);`
- `void cnfg_config_teardown_thread_safety(cnfg_config *config);`
- `void cnfg_entry_teardown_thread_safety(cnfg_entry *entry);`
- `void cnfg_entry_unlock(cnfg_entry *entry, bool lock_acquired);`
- `void cnfg_free(cnfg_config *config);`

### Config/config_entry_thread_safety.cpp

- `int cnfg_entry_lock(cnfg_entry *entry, bool *lock_acquired)`
- `int cnfg_entry_prepare_thread_safety(cnfg_entry *entry)`
- `static void cnfg_entry_push_error(int error_code)`
- `void cnfg_entry_teardown_thread_safety(cnfg_entry *entry)`
- `void cnfg_entry_unlock(cnfg_entry *entry, bool lock_acquired)`

### Config/config_flag_parser.cpp

- `bool cnfg_flag_parser::has_long_flag(const char *flag)`
- `bool cnfg_flag_parser::has_short_flag(char flag)`
- `bool cnfg_flag_parser::parse(int argument_count, char **argument_values)`
- `cnfg_config *config_merge_sources(int argument_count, char **argument_values, const char *filename)`
- `const char *cnfg_flag_parser::get_error_str() const`
- `int cnfg_flag_parser::get_error() const`
- `size_t cnfg_flag_parser::get_long_flag_count()`
- `size_t cnfg_flag_parser::get_short_flag_count()`
- `size_t cnfg_flag_parser::get_total_flag_count()`
- `static cnfg_config *append_flag_entry(cnfg_config *config, const char *flag)`
- `static cnfg_config *merge_configs(cnfg_config *base_config, cnfg_config *override_config)`
- `static void cnfg_config_unlock_guard(ft_unique_lock<pt_mutex> &mutex_guard)`
- `void cnfg_flag_parser::free_flags()`
- `void cnfg_flag_parser::free_flags_locked()`
- `void cnfg_flag_parser::set_error(int error_code)`

### Config/config_flags.cpp

- `char **cnfg_parse_long_flags(int argument_count, char **argument_values)`

### Config/config_merge.cpp

- `cnfg_config *config_merge(const cnfg_config *base_config, const cnfg_config *override_config)`
- `static cnfg_entry *config_find_matching_entry(cnfg_config *config, const cnfg_entry *entry)`
- `static int config_append_entry(cnfg_config *destination, const cnfg_entry *source)`
- `static int config_copy_entries(cnfg_config *destination, const cnfg_config *source)`
- `static int config_duplicate_entry(const cnfg_entry *source, cnfg_entry *destination)`
- `static int config_strings_equal(const char *left, const char *right)`
- `static void cnfg_config_unlock_guard(ft_unique_lock<pt_mutex> &mutex_guard)`
- `static void config_free_entry_contents(cnfg_entry *entry)`
- `static void config_free_entry_contents_unlocked(cnfg_entry *entry)`

### Config/config_parse.cpp

- `cnfg_config *cnfg_config_create()`
- `cnfg_config *cnfg_parse(const char *filename)`
- `cnfg_config *config_load_env()`
- `cnfg_config *config_load_file(const char *filename)`
- `int cnfg_config_prepare_thread_safety(cnfg_config *config)`
- `static char *trim_whitespace(char *string)`
- `static cnfg_config *cnfg_parse_json(const char *filename)`
- `static void cnfg_config_unlock_guard(ft_unique_lock<pt_mutex> &mutex_guard)`
- `void cnfg_config_teardown_thread_safety(cnfg_config *config)`
- `void cnfg_free(cnfg_config *config)`

### Config/config_write.cpp

- `int config_write_file(const cnfg_config *config, const char *filename)`
- `static int config_handle_write_failure(FILE *file)`
- `static int config_write_ini(const cnfg_config *config, const char *filename)`
- `static int config_write_json(const cnfg_config *config, const char *filename)`
- `static json_group *config_find_or_create_group(json_group **groups_head, const char *section_name)`
- `static void cnfg_config_unlock_guard(ft_unique_lock<pt_mutex> &mutex_guard)`

### Config/flag_parser.hpp

- `bool has_long_flag(const char *flag);`
- `bool has_short_flag(char flag);`
- `bool parse(int argument_count, char **argument_values);`
- `cnfg_config *config_merge_sources(int argument_count, char **argument_values, const char *filename);`
- `const char *get_error_str() const;`
- `int get_error() const;`
- `public: cnfg_flag_parser();`
- `size_t get_long_flag_count();`
- `size_t get_short_flag_count();`
- `size_t get_total_flag_count();`
- `void free_flags();`
- `void free_flags_locked();`
- `void set_error(int error_code);`

### CrossProcess/cross_process.hpp

- `int cp_receive_descriptor(int socket_fd, cross_process_message &message);`
- `int cp_receive_memory(int socket_fd, cross_process_read_result &result);`
- `int cp_send_descriptor(int socket_fd, const cross_process_message &message);`
- `int cp_write_memory(const cross_process_message &message, const unsigned char *payload, ft_size_t payload_length, int error_code);`

### CrossProcess/cross_process_receive_memory.cpp

- `int cp_receive_memory(int socket_fd, cross_process_read_result &result)`
- `static ft_size_t compute_offset(uint64_t pointer_value, uint64_t base_value)`

### CrossProcess/cross_process_write_memory.cpp

- `int cp_write_memory(const cross_process_message &message, const unsigned char *payload, ft_size_t payload_length, int error_code)`
- `static ft_size_t compute_offset(uint64_t pointer_value, uint64_t base_value)`

### DUMB/dumb_console.cpp

- `int ft_read_line(char *buffer, size_t buffer_size)`
- `void ft_print_line(const char *str)`
- `void ft_print_string(const char *str)`

### DUMB/dumb_console.hpp

- `int ft_read_line(char *buffer, size_t buffer_size);`
- `void ft_print_line(const char *str);`
- `void ft_print_string(const char *str);`

### DUMB/dumb_io.cpp

- `int ft_write_file(const char *path, const char *buffer, size_t size)`

### DUMB/dumb_io.hpp

- `int ft_read_file(const char *path, char **out_buffer, size_t *out_size);`
- `int ft_write_file(const char *path, const char *buffer, size_t size);`

### DUMB/dumb_render.cpp

- `bool ft_render_window::should_close(void) const`
- `ft_render_framebuffer &ft_render_window::framebuffer(void)`
- `ft_render_screen_size ft_render_get_primary_screen_size(void)`
- `int ft_render_window::clear(uint32_t color)`
- `int ft_render_window::initialize(const ft_render_window_desc &desc)`
- `int ft_render_window::poll_events(void)`
- `int ft_render_window::present(void)`
- `int ft_render_window::put_pixel(int x, int y, uint32_t color)`
- `int ft_render_window::set_fullscreen(bool enabled)`
- `static void ft_render_push_error(int error_code, int system_error_code)`
- `void ft_render_window::shutdown(void)`

### DUMB/dumb_render.hpp

- `ft_render_screen_size ft_render_get_primary_screen_size(void);`

### DUMB/dumb_render_internal.hpp

- `ft_render_platform_result ft_render_platform_create_window( void **platform_state, ft_render_framebuffer *framebuffer, const ft_render_window_desc &desc );`
- `ft_render_platform_result ft_render_platform_destroy_window( void **platform_state, ft_render_framebuffer *framebuffer );`
- `ft_render_platform_result ft_render_platform_get_primary_screen_size( ft_render_screen_size *size );`
- `ft_render_platform_result ft_render_platform_poll_events( void *platform_state, bool *should_close );`
- `ft_render_platform_result ft_render_platform_present( void *platform_state, ft_render_framebuffer *framebuffer );`
- `ft_render_platform_result ft_render_platform_set_fullscreen( void *platform_state, bool enabled );`

### DUMB/dumb_sound.hpp

- `ft_sound_device *ft_create_sound_device(void);`

### DUMB/dumb_sound_clip.cpp

- `const ft_sound_spec *ft_sound_clip::get_spec(void) const`
- `const uint8_t *ft_sound_clip::get_data(void) const`
- `int ft_sound_clip::load_wav(const char *file_path)`
- `size_t ft_sound_clip::get_size(void) const`

### DUMB/dumb_sound_linux_alsa.cpp

- `ft_sound_device *ft_create_sound_device_alsa(void)`

### DUMB/dumb_sound_macos_coreaudio.cpp

- `ft_sound_device *ft_create_sound_device_coreaudio(void)`
- `int open(const ft_sound_spec *spec)`
- `public: ft_sound_device_coreaudio(void)`
- `static void audio_queue_callback(void *inUserData, AudioQueueRef inAQ, AudioQueueBufferRef inBuffer)`
- `void close(void)`
- `void pause(int pause_on)`
- `void play(const ft_sound_clip *clip)`
- `void stop(void)`

### DUMB/dumb_sound_win32.cpp

- `ft_sound_device *ft_create_sound_device_win32(void)`
- `int open(const ft_sound_spec *spec)`
- `public: ft_sound_device_win32(void)`
- `static void CALLBACK wave_out_proc(HWAVEOUT hwo, UINT uMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2)`
- `void close(void)`
- `void pause(int pause_on)`
- `void play(const ft_sound_clip *clip)`
- `void stop(void)`

### Encryption/aes.hpp

- `void aes_decrypt(uint8_t *block, const uint8_t *key);`
- `void aes_decrypt_software(uint8_t *block, const uint8_t *key);`
- `void aes_encrypt_software(uint8_t *block, const uint8_t *key);`

### Encryption/basic_encryption.hpp

- `char **be_DecryptData(char **data, const char *key);`
- `const char *be_getEncryptionKey();`
- `int be_saveGame(const char *filename, const char *data, const char *key);`
- `void be_set_save_game_hooks(t_be_open_function open_function, t_be_write_function write_function);`

### Encryption/encryption_aead.cpp

- `bool encryption_aead_decrypt(const unsigned char *key, size_t key_length, const unsigned char *iv, size_t iv_length, const unsigned char *aad, size_t aad_length, const unsigned char *ciphertext, size_t ciphertext_length, const unsigned char *tag, size_t tag_length, unsigned char *plaintext)`
- `bool encryption_aead_encrypt(const unsigned char *key, size_t key_length, const unsigned char *iv, size_t iv_length, const unsigned char *aad, size_t aad_length, const unsigned char *plaintext, size_t plaintext_length, unsigned char *ciphertext, unsigned char *tag, size_t tag_length)`
- `const char *encryption_aead_context::get_error_str() const`
- `int encryption_aead_context::configure_cipher(const unsigned char *key, size_t key_length, const unsigned char *iv, size_t iv_length, bool encrypt_mode)`
- `int encryption_aead_context::finalize(unsigned char *tag, size_t tag_length)`
- `int encryption_aead_context::get_error() const`
- `int encryption_aead_context::initialize_decrypt(const unsigned char *key, size_t key_length, const unsigned char *iv, size_t iv_length)`
- `int encryption_aead_context::initialize_encrypt(const unsigned char *key, size_t key_length, const unsigned char *iv, size_t iv_length)`
- `int encryption_aead_context::lock_self(ft_unique_lock<pt_mutex> &guard) const`
- `int encryption_aead_context::set_tag(const unsigned char *tag, size_t tag_length)`
- `int encryption_aead_context::update(const unsigned char *input, size_t input_length, unsigned char *output, size_t &output_length)`
- `int encryption_aead_context::update_aad(const unsigned char *aad, size_t aad_length)`
- `void encryption_aead_context::reset()`
- `void encryption_aead_context::set_error(int error_code) const`
- `void encryption_aead_context::set_error_unlocked(int error_code) const`

### Encryption/encryption_aead.hpp

- `bool encryption_aead_decrypt(const unsigned char *key, size_t key_length, const unsigned char *iv, size_t iv_length, const unsigned char *aad, size_t aad_length, const unsigned char *ciphertext, size_t ciphertext_length, const unsigned char *tag, size_t tag_length, unsigned char *plaintext);`
- `bool encryption_aead_encrypt(const unsigned char *key, size_t key_length, const unsigned char *iv, size_t iv_length, const unsigned char *aad, size_t aad_length, const unsigned char *plaintext, size_t plaintext_length, unsigned char *ciphertext, unsigned char *tag, size_t tag_length);`
- `const char *get_error_str() const;`
- `int configure_cipher(const unsigned char *key, size_t key_length, const unsigned char *iv, size_t iv_length, bool encrypt_mode);`
- `int finalize(unsigned char *tag, size_t tag_length);`
- `int get_error() const;`
- `int initialize_decrypt(const unsigned char *key, size_t key_length, const unsigned char *iv, size_t iv_length);`
- `int initialize_encrypt(const unsigned char *key, size_t key_length, const unsigned char *iv, size_t iv_length);`
- `int lock_self(ft_unique_lock<pt_mutex> &guard) const;`
- `int set_tag(const unsigned char *tag, size_t tag_length);`
- `int update(const unsigned char *input, size_t input_length, unsigned char *output, size_t &output_length);`
- `int update_aad(const unsigned char *aad, size_t aad_length);`
- `public: encryption_aead_context();`
- `void reset();`
- `void set_error(int error_code) const;`
- `void set_error_unlocked(int error_code) const;`

### Encryption/encryption_aes.cpp

- `static uint8_t multiply(uint8_t value, uint8_t multiplier)`
- `static uint8_t xtime(uint8_t value)`
- `static void add_round_key(uint8_t *state, const uint8_t *round_key)`
- `static void inv_mix_columns(uint8_t *state)`
- `static void inv_shift_rows(uint8_t *state)`
- `static void inv_sub_bytes(uint8_t *state)`
- `static void key_expansion(const uint8_t *key, uint8_t *round_keys)`
- `static void mix_columns(uint8_t *state)`
- `static void shift_rows(uint8_t *state)`
- `static void sub_bytes(uint8_t *state)`
- `void aes_decrypt(uint8_t *block, const uint8_t *key)`
- `void aes_decrypt_software(uint8_t *block, const uint8_t *key)`
- `void aes_encrypt(uint8_t *block, const uint8_t *key)`
- `void aes_encrypt_software(uint8_t *block, const uint8_t *key)`

### Encryption/encryption_basic_encryption.cpp

- `char **be_DecryptData(char **data, const char *key)`
- `int be_saveGame(const char *filename, const char *data, const char *key)`
- `static ssize_t be_default_write(int file_descriptor, const void *buffer, size_t count)`
- `static void be_encrypt(char *data, size_t data_length, const char *key)`
- `void be_set_save_game_hooks(t_be_open_function open_function, t_be_write_function write_function)`

### Encryption/encryption_blake2.cpp

- `void blake2b_hash(const void *data, size_t length, unsigned char *digest, size_t digest_length)`
- `void blake2s_hash(const void *data, size_t length, unsigned char *digest, size_t digest_length)`

### Encryption/encryption_blake2.hpp

- `void blake2s_hash(const void *data, size_t length, unsigned char *digest, size_t digest_length);`

### Encryption/encryption_hardware_acceleration.cpp

- `bool encryption_try_hardware_aes_decrypt(uint8_t *block, const uint8_t *key)`
- `bool encryption_try_hardware_aes_encrypt(uint8_t *block, const uint8_t *key)`
- `int encryption_register_hardware_hooks(const s_encryption_hardware_hooks &hooks)`
- `static void encryption_hardware_report(int error_code)`
- `void encryption_clear_hardware_hooks(void)`
- `void encryption_get_hardware_hooks(s_encryption_hardware_hooks &out_hooks)`

### Encryption/encryption_hardware_acceleration.hpp

- `bool encryption_try_hardware_aes_decrypt(uint8_t *block, const uint8_t *key);`
- `bool encryption_try_hardware_aes_encrypt(uint8_t *block, const uint8_t *key);`
- `int encryption_register_hardware_hooks(const s_encryption_hardware_hooks &hooks);`
- `void encryption_clear_hardware_hooks(void);`
- `void encryption_get_hardware_hooks(s_encryption_hardware_hooks &out_hooks);`

### Encryption/encryption_hmac_sha256.cpp

- `int hmac_sha256_stream_final(hmac_sha256_stream &stream, unsigned char *digest, size_t digest_length)`
- `int hmac_sha256_stream_init(hmac_sha256_stream &stream, const unsigned char *key, size_t key_length)`
- `int hmac_sha256_stream_update(hmac_sha256_stream &stream, const void *data, size_t length)`
- `static void hmac_sha256_stream_release(hmac_sha256_stream &stream)`
- `void hmac_sha256(const unsigned char *key, size_t key_len, const void *data, size_t len, unsigned char *digest)`
- `void hmac_sha256_stream_cleanup(hmac_sha256_stream &stream)`

### Encryption/encryption_hmac_sha256.hpp

- `int hmac_sha256_stream_final(hmac_sha256_stream &stream, unsigned char *digest, size_t digest_length);`
- `int hmac_sha256_stream_init(hmac_sha256_stream &stream, const unsigned char *key, size_t key_length);`
- `int hmac_sha256_stream_update(hmac_sha256_stream &stream, const void *data, size_t length);`
- `void hmac_sha256(const unsigned char *key, size_t key_len, const void *data, size_t len, unsigned char *digest);`
- `void hmac_sha256_stream_cleanup(hmac_sha256_stream &stream);`

### Encryption/encryption_key.cpp

- `const char *be_getEncryptionKey(void)`

### Encryption/encryption_key_management.cpp

- `int encryption_fill_secure_buffer(unsigned char *buffer, size_t buffer_length)`
- `static int encryption_fill_secure_buffer_internal(unsigned char *buffer, size_t buffer_length)`
- `static unsigned char *encryption_allocate_key(size_t key_length, int *error_code)`
- `static unsigned char *encryption_generate_symmetric_key_internal(size_t key_length, int *error_code)`
- `static unsigned char *encryption_key_pointer_report(int error_code, unsigned char *result)`
- `static void encryption_discard_key(unsigned char *key_buffer, size_t key_length)`
- `unsigned char *encryption_generate_initialization_vector(size_t iv_length)`
- `unsigned char *encryption_generate_symmetric_key(size_t key_length)`

### Encryption/encryption_key_management.hpp

- `int encryption_fill_secure_buffer(unsigned char *buffer, size_t buffer_length);`
- `unsigned char *encryption_generate_initialization_vector(size_t iv_length);`

### Encryption/encryption_rsa.cpp

- `int rsa_generate_key_pair(uint64_t *public_key, uint64_t *private_key, uint64_t *modulus, int bit_size)`
- `static bool rsa_is_prime(uint64_t value)`
- `static uint64_t rsa_gcd(uint64_t first_value, uint64_t second_value)`
- `static uint64_t rsa_generate_prime(uint64_t limit)`
- `static uint64_t rsa_mod_inverse(uint64_t value, uint64_t modulus)`
- `static uint64_t rsa_mod_pow(uint64_t base_value, uint64_t exponent_value, uint64_t modulus_value)`
- `uint64_t rsa_decrypt(uint64_t cipher, uint64_t private_key, uint64_t modulus)`
- `uint64_t rsa_encrypt(uint64_t message, uint64_t public_key, uint64_t modulus)`
- `void rsa_set_force_mod_inverse_failure(bool enable)`

### Encryption/encryption_secure_wipe.cpp

- `int encryption_secure_wipe(void *buffer, std::size_t buffer_size)`
- `int encryption_secure_wipe_string(char *string_buffer)`

### Encryption/encryption_secure_wipe.hpp

- `int encryption_secure_wipe_string(char *string_buffer);`

### Encryption/encryption_sha1.cpp

- `void sha1_hash(const void *data, size_t length, unsigned char *digest)`

### Encryption/encryption_sha256.cpp

- `void sha256_hash(const void *data, size_t length, unsigned char *digest)`

### Encryption/encryption_sha3.cpp

- `void sha3_256_hash(const void *data, size_t length, unsigned char *digest)`
- `void sha3_512_hash(const void *data, size_t length, unsigned char *digest)`

### Encryption/encryption_sha3.hpp

- `void sha3_512_hash(const void *data, size_t length, unsigned char *digest);`

### Encryption/rsa.hpp

- `uint64_t rsa_decrypt(uint64_t cipher, uint64_t private_key, uint64_t modulus);`
- `uint64_t rsa_encrypt(uint64_t message, uint64_t public_key, uint64_t modulus);`
- `void rsa_set_force_mod_inverse_failure(bool enable);`

### Errno/errno.hpp

- `const char *ft_global_error_stack_error_str_at(ft_size_t index);`
- `const char *ft_global_error_stack_peek_last_error_str(void);`
- `ft_size_t ft_global_error_stack_depth(void);`
- `ft_size_t ft_global_error_stack_find_by_id(unsigned long long id);`
- `int ft_global_error_stack_error_at(ft_size_t index);`
- `int ft_global_error_stack_peek_last_error(void);`
- `int ft_global_error_stack_pop_entry_with_id(unsigned long long op_id);`
- `int ft_global_error_stack_pop_last(void);`
- `int ft_global_error_stack_drop_last_error(void);`
- `int ft_set_errno_from_system_error(int error_code);`
- `unsigned long long ft_errno_next_operation_id(void);`
- `unsigned long long ft_global_error_stack_get_id_at(ft_size_t index);`
- `unsigned long long ft_global_error_stack_push_entry(int error_code);`
- `unsigned long long ft_global_error_stack_push_entry_with_id(int error_code, unsigned long long op_id);`
- `void ft_exit(const char *error_msg, int exit_code);`
- `void ft_global_error_stack_pop_all(void);`
- `void ft_global_error_stack_push(int error_code);`
- `void ft_perror(const char *error_msg);`

### Errno/errno_code.cpp

- `const char *ft_error_stack_error_str_at(const ft_error_stack *error_stack, ft_size_t index)`
- `const char *ft_error_stack_last_error_str(const ft_error_stack *error_stack)`
- `const char *ft_global_error_stack_error_str_at(ft_size_t index)`
- `const char *ft_global_error_stack_peek_last_error_str(void)`
- `ft_errno_mutex_wrapper &ft_errno_mutex()`
- `ft_size_t ft_error_stack_depth(const ft_error_stack *error_stack)`
- `ft_size_t ft_error_stack_find_by_id(const ft_error_stack *error_stack, unsigned long long id)`
- `ft_size_t ft_global_error_stack_depth(void)`
- `ft_size_t ft_global_error_stack_find_by_id(unsigned long long id)`
- `ft_size_t ft_operation_error_stack_depth(const ft_operation_error_stack *error_stack)`
- `ft_size_t ft_operation_error_stack_find_by_id( const ft_operation_error_stack *error_stack, unsigned long long id)`
- `int ft_error_stack_error_at(const ft_error_stack *error_stack, ft_size_t index)`
- `int ft_error_stack_last_error(const ft_error_stack *error_stack)`
- `int ft_error_stack_pop_entry_with_id(ft_error_stack *error_stack, unsigned long long op_id)`
- `int ft_error_stack_pop_last(ft_error_stack *error_stack)`
- `int ft_error_stack_pop_newest(ft_error_stack *error_stack)`
- `int ft_global_error_stack_error_at(ft_size_t index)`
- `int ft_global_error_stack_peek_last_error(void)`
- `int ft_global_error_stack_pop_entry_with_id(unsigned long long op_id)`
- `int ft_global_error_stack_pop_last(void)`
- `int ft_global_error_stack_drop_last_error(void)`
- `int ft_operation_error_stack_error_at(const ft_operation_error_stack *error_stack, ft_size_t index)`
- `int ft_operation_error_stack_last_error(const ft_operation_error_stack *error_stack)`
- `int ft_operation_error_stack_pop_by_id(ft_operation_error_stack *error_stack, unsigned long long op_id)`
- `int ft_operation_error_stack_pop_last(ft_operation_error_stack *error_stack)`
- `int ft_operation_error_stack_pop_newest(ft_operation_error_stack *error_stack)`
- `static ft_error_stack &ft_global_error_stack()`
- `static ft_size_t ft_error_stack_depth_internal(const ft_error_stack *error_stack)`
- `static ft_size_t ft_error_stack_find_by_id_internal(const ft_error_stack *error_stack, unsigned long long id)`
- `static ft_size_t ft_operation_error_stack_find_by_id_internal( const ft_operation_error_stack *error_stack, unsigned long long id)`
- `static int ft_error_stack_error_at_internal(const ft_error_stack *error_stack, ft_size_t index)`
- `static int ft_error_stack_last_error_internal(const ft_error_stack *error_stack)`
- `static int ft_error_stack_pop_entry_with_id_internal(ft_error_stack *error_stack, unsigned long long op_id)`
- `static int ft_error_stack_pop_last_internal(ft_error_stack *error_stack)`
- `static int ft_error_stack_pop_newest_internal(ft_error_stack *error_stack)`
- `static int ft_operation_error_stack_error_at_internal(const ft_operation_error_stack *error_stack, ft_size_t index)`
- `static int ft_operation_error_stack_last_error_internal(const ft_operation_error_stack *error_stack)`
- `static int ft_operation_error_stack_pop_by_id_internal(ft_operation_error_stack *error_stack, unsigned long long op_id)`
- `static int ft_operation_error_stack_pop_last_internal(ft_operation_error_stack *error_stack)`
- `static int ft_operation_error_stack_pop_newest_internal(ft_operation_error_stack *error_stack)`
- `static unsigned long long ft_error_stack_get_id_at_internal(const ft_error_stack *error_stack, ft_size_t index)`
- `static unsigned long long ft_operation_error_stack_get_id_at_internal( const ft_operation_error_stack *error_stack, ft_size_t index)`
- `static unsigned long long ft_operation_error_stack_last_id_internal( const ft_operation_error_stack *error_stack)`
- `static void ft_error_stack_pop_all_internal(ft_error_stack *error_stack)`
- `static void ft_error_stack_push_entry_with_id_internal(ft_error_stack *error_stack, int error_code, unsigned long long op_id)`
- `static void ft_error_stack_shift_frames(ft_error_frame frames[], uint32_t &depth, ft_size_t capacity)`
- `static void ft_operation_error_stack_pop_all_internal(ft_operation_error_stack *error_stack)`
- `static void ft_operation_error_stack_push_internal(ft_operation_error_stack *error_stack, int error_code, unsigned long long op_id)`
- `static void ft_operation_error_stack_shift_entries(ft_operation_error_stack *error_stack)`
- `unsigned long long ft_errno_next_operation_id(void)`
- `unsigned long long ft_error_stack_get_id_at(const ft_error_stack *error_stack, ft_size_t index)`
- `unsigned long long ft_global_error_stack_get_id_at(ft_size_t index)`
- `unsigned long long ft_global_error_stack_push_entry(int error_code)`
- `unsigned long long ft_global_error_stack_push_entry_with_id(int error_code, unsigned long long op_id)`
- `unsigned long long ft_operation_error_stack_get_id_at( const ft_operation_error_stack *error_stack, ft_size_t index)`
- `unsigned long long ft_operation_error_stack_last_id(const ft_operation_error_stack *error_stack)`
- `void ft_errno_mutex_wrapper::lock(void)`
- `void ft_errno_mutex_wrapper::unlock(void)`
- `void ft_error_stack_pop_all(ft_error_stack *error_stack)`
- `void ft_error_stack_push_entry_with_id(ft_error_stack *error_stack, int error_code, unsigned long long op_id)`
- `void ft_global_error_stack_pop_all(void)`
- `void ft_global_error_stack_push(int error_code)`
- `void ft_operation_error_stack_pop_all(ft_operation_error_stack *error_stack)`
- `void ft_operation_error_stack_push(ft_operation_error_stack *error_stack, int error_code, unsigned long long op_id)`

### Errno/errno_internal.hpp

- `const char *ft_error_stack_error_str_at(const ft_error_stack *error_stack, ft_size_t index);`
- `const char *ft_error_stack_last_error_str(const ft_error_stack *error_stack);`
- `ft_errno_mutex_wrapper &ft_errno_mutex();`
- `ft_size_t ft_error_stack_depth(const ft_error_stack *error_stack);`
- `ft_size_t ft_error_stack_find_by_id(const ft_error_stack *error_stack, unsigned long long id);`
- `ft_size_t ft_operation_error_stack_depth( const ft_operation_error_stack *error_stack);`
- `ft_size_t ft_operation_error_stack_find_by_id( const ft_operation_error_stack *error_stack, unsigned long long id);`
- `int ft_error_stack_error_at(const ft_error_stack *error_stack, ft_size_t index);`
- `int ft_error_stack_last_error(const ft_error_stack *error_stack);`
- `int ft_error_stack_pop_entry_with_id(ft_error_stack *error_stack, unsigned long long op_id);`
- `int ft_error_stack_pop_last(ft_error_stack *error_stack);`
- `int ft_error_stack_pop_newest(ft_error_stack *error_stack);`
- `int ft_operation_error_stack_error_at(const ft_operation_error_stack *error_stack, ft_size_t index);`
- `int ft_operation_error_stack_last_error(const ft_operation_error_stack *error_stack);`
- `int ft_operation_error_stack_pop_by_id(ft_operation_error_stack *error_stack, unsigned long long op_id);`
- `int ft_operation_error_stack_pop_last(ft_operation_error_stack *error_stack);`
- `int ft_operation_error_stack_pop_newest(ft_operation_error_stack *error_stack);`
- `public: ft_errno_mutex_wrapper(void);`
- `unsigned long long ft_error_stack_get_id_at(const ft_error_stack *error_stack, ft_size_t index);`
- `unsigned long long ft_operation_error_stack_get_id_at( const ft_operation_error_stack *error_stack, ft_size_t index);`
- `unsigned long long ft_operation_error_stack_last_id( const ft_operation_error_stack *error_stack);`
- `void ft_error_stack_pop_all(ft_error_stack *error_stack);`
- `void ft_error_stack_push_entry_with_id(ft_error_stack *error_stack, int error_code, unsigned long long op_id);`
- `void lock(void);`
- `void unlock(void);`

### Errno/errno_map.cpp

- `int ft_set_errno_from_system_error(int error_code)`

### Errno/errno_strerror.cpp

- `const char* ft_strerror(int error_code)`
- `static const char *ft_find_custom_error(int error_code)`

### File/file_check_directory.cpp

- `int file_dir_exists(const char *rel_path)`
- `static ft_string normalize_path(ft_string path)`

### File/file_copy.cpp

- `int file_copy(const char *source_path, const char *destination_path)`
- `int file_copy_with_buffer(const char *source_path, const char *destination_path, size_t buffer_size)`

### File/file_opendir.cpp

- `file_dirent *file_readdir(file_dir *directory_stream)`
- `int file_closedir(file_dir *directory_stream)`

### File/file_path_join.cpp

- `ft_string file_path_join(const char *path_left, const char *path_right)`

### File/file_path_normalize.cpp

- `ft_string file_path_normalize(const char *path)`

### File/file_utils.hpp

- `ft_string file_path_join(const char *path_left, const char *path_right);`
- `ft_string file_path_normalize(const char *path);`
- `int file_copy_with_buffer(const char *source_path, const char *destination_path, size_t buffer_size);`
- `int file_delete(const char *path);`
- `int file_exists(const char *path);`
- `int file_move(const char *source_path, const char *destination_path);`
- `size_t file_default_copy_buffer_size(void) noexcept;`

### File/file_watch.cpp

- `bool ft_file_watch::snapshot_callback(void (**callback)(const char *, int, void *), void *&user_data, ft_string &path_snapshot) const`
- `ft_operation_error_stack *ft_file_watch::operation_error_stack_handle() const noexcept`
- `int ft_file_watch::watch_directory(const char *path, void (*callback)(const char *, int, void *), void *user_data)`
- `void ft_file_watch::close_handles_locked()`
- `void ft_file_watch::event_loop()`
- `void ft_file_watch::record_operation_error(int error_code) const`
- `void ft_file_watch::stop()`

### File/open_dir.hpp

- `file_dir *file_opendir(const char *directory_path);`
- `file_dirent *file_readdir(file_dir *directory_stream);`
- `int file_closedir(file_dir *directory_stream);`
- `int file_create_directory(const char *path, mode_t mode);`
- `int file_dir_exists(const char *rel_path);`

### Game/ft_behavior_action.hpp

- `const char *get_error_str() const noexcept;`
- `double get_cooldown_seconds() const noexcept;`
- `double get_weight() const noexcept;`
- `int get_action_id() const noexcept;`
- `int get_error() const noexcept;`
- `public: ft_behavior_action() noexcept;`
- `static int lock_pair(const ft_behavior_action &first, const ft_behavior_action &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_behavior_action() = default;`
- `void set_action_id(int action_id) noexcept;`
- `void set_cooldown_seconds(double cooldown_seconds) noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_weight(double weight) noexcept;`

### Game/ft_behavior_profile.hpp

- `const char *get_error_str() const noexcept;`
- `const ft_vector<ft_behavior_action> &get_actions() const noexcept;`
- `double get_aggression_weight() const noexcept;`
- `double get_caution_weight() const noexcept;`
- `ft_vector<ft_behavior_action> &get_actions() noexcept;`
- `int get_error() const noexcept;`
- `int get_profile_id() const noexcept;`
- `public: ft_behavior_profile() noexcept;`
- `static int lock_pair(const ft_behavior_profile &first, const ft_behavior_profile &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_behavior_profile() = default;`
- `void clone_from_unlocked(const ft_behavior_profile &other) noexcept;`
- `void move_from_unlocked(ft_behavior_profile &other) noexcept;`
- `void set_actions(const ft_vector<ft_behavior_action> &actions) noexcept;`
- `void set_aggression_weight(double aggression_weight) noexcept;`
- `void set_caution_weight(double caution_weight) noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_profile_id(int profile_id) noexcept;`

### Game/ft_currency_rate.hpp

- `const char *get_error_str() const noexcept;`
- `double get_rate_to_base() const noexcept;`
- `int get_currency_id() const noexcept;`
- `int get_display_precision() const noexcept;`
- `int get_error() const noexcept;`
- `public: ft_currency_rate() noexcept;`
- `static int lock_pair(const ft_currency_rate &first, const ft_currency_rate &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `static void record_operation_error_unlocked(int error_code);`
- `virtual ~ft_currency_rate() = default;`
- `void set_currency_id(int currency_id) noexcept;`
- `void set_display_precision(int display_precision) noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_rate_to_base(double rate_to_base) noexcept;`

### Game/ft_dialogue_line.hpp

- `const char *get_error_str() const noexcept;`
- `const ft_string &get_speaker() const noexcept;`
- `const ft_string &get_text() const noexcept;`
- `const ft_vector<int> &get_next_line_ids() const noexcept;`
- `ft_vector<int> &get_next_line_ids() noexcept;`
- `int get_error() const noexcept;`
- `int get_line_id() const noexcept;`
- `public: ft_dialogue_line() noexcept;`
- `static int lock_pair(const ft_dialogue_line &first, const ft_dialogue_line &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_dialogue_line() noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_line_id(int line_id) noexcept;`
- `void set_next_line_ids(const ft_vector<int> &next_line_ids) noexcept;`
- `void set_speaker(const ft_string &speaker) noexcept;`
- `void set_text(const ft_string &text) noexcept;`

### Game/ft_dialogue_script.hpp

- `const char *get_error_str() const noexcept;`
- `const ft_string &get_summary() const noexcept;`
- `const ft_string &get_title() const noexcept;`
- `const ft_vector<ft_dialogue_line> &get_lines() const noexcept;`
- `ft_vector<ft_dialogue_line> &get_lines() noexcept;`
- `int get_error() const noexcept;`
- `int get_script_id() const noexcept;`
- `int get_start_line_id() const noexcept;`
- `public: ft_dialogue_script() noexcept;`
- `static int lock_pair(const ft_dialogue_script &first, const ft_dialogue_script &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `static void record_operation_error_unlocked(int error_code);`
- `virtual ~ft_dialogue_script() noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_lines(const ft_vector<ft_dialogue_line> &lines) noexcept;`
- `void set_script_id(int script_id) noexcept;`
- `void set_start_line_id(int start_line_id) noexcept;`
- `void set_summary(const ft_string &summary) noexcept;`
- `void set_title(const ft_string &title) noexcept;`

### Game/ft_price_definition.hpp

- `const char *get_error_str() const noexcept;`
- `int get_base_value() const noexcept;`
- `int get_error() const noexcept;`
- `int get_item_id() const noexcept;`
- `int get_maximum_value() const noexcept;`
- `int get_minimum_value() const noexcept;`
- `int get_rarity() const noexcept;`
- `public: ft_price_definition() noexcept;`
- `static int lock_pair(const ft_price_definition &first, const ft_price_definition &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_price_definition() = default;`
- `void set_base_value(int base_value) noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_item_id(int item_id) noexcept;`
- `void set_maximum_value(int maximum_value) noexcept;`
- `void set_minimum_value(int minimum_value) noexcept;`
- `void set_rarity(int rarity) noexcept;`

### Game/ft_rarity_band.hpp

- `const char *get_error_str() const noexcept;`
- `double get_value_multiplier() const noexcept;`
- `int get_error() const noexcept;`
- `int get_rarity() const noexcept;`
- `public: ft_rarity_band() noexcept;`
- `static int lock_pair(const ft_rarity_band &first, const ft_rarity_band &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `static void record_operation_error_unlocked(int error_code);`
- `virtual ~ft_rarity_band() = default;`
- `void set_error(int error_code) const noexcept;`
- `void set_rarity(int rarity) noexcept;`
- `void set_value_multiplier(double value_multiplier) noexcept;`

### Game/ft_region_definition.hpp

- `const char *get_error_str() const noexcept;`
- `const ft_string &get_description() const noexcept;`
- `const ft_string &get_name() const noexcept;`
- `int get_error() const noexcept;`
- `int get_recommended_level() const noexcept;`
- `int get_region_id() const noexcept;`
- `public: ft_region_definition() noexcept;`
- `static int lock_pair(const ft_region_definition &first, const ft_region_definition &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_region_definition() noexcept;`
- `void set_description(const ft_string &description) noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_name(const ft_string &name) noexcept;`
- `void set_recommended_level(int recommended_level) noexcept;`
- `void set_region_id(int region_id) noexcept;`

### Game/ft_vendor_profile.hpp

- `const char *get_error_str() const noexcept;`
- `double get_buy_markup() const noexcept;`
- `double get_sell_multiplier() const noexcept;`
- `double get_tax_rate() const noexcept;`
- `int get_error() const noexcept;`
- `int get_vendor_id() const noexcept;`
- `public: ft_vendor_profile() noexcept;`
- `static int lock_pair(const ft_vendor_profile &first, const ft_vendor_profile &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `static void record_operation_error_unlocked(int error_code);`
- `virtual ~ft_vendor_profile() = default;`
- `void set_buy_markup(double buy_markup) noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_sell_multiplier(double sell_multiplier) noexcept;`
- `void set_tax_rate(double tax_rate) noexcept;`
- `void set_vendor_id(int vendor_id) noexcept;`

### Game/ft_world_region.hpp

- `const char *get_error_str() const noexcept;`
- `const ft_vector<int> &get_region_ids() const noexcept;`
- `ft_vector<int> &get_region_ids() noexcept;`
- `int get_error() const noexcept;`
- `int get_world_id() const noexcept;`
- `public: ft_world_region() noexcept;`
- `static int lock_pair(const ft_world_region &first, const ft_world_region &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_world_region() noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_region_ids(const ft_vector<int> &region_ids) noexcept;`
- `void set_world_id(int world_id) noexcept;`

### Game/game_achievement.cpp

- `bool ft_achievement::is_complete() const noexcept`
- `bool ft_achievement::is_goal_complete(int id) const noexcept`
- `const char *ft_achievement::get_error_str() const noexcept`
- `const char *ft_goal::get_error_str() const noexcept`
- `const ft_map<int, ft_goal> &ft_achievement::get_goals() const noexcept`
- `ft_map<int, ft_goal> &ft_achievement::get_goals() noexcept`
- `int ft_achievement::get_error() const noexcept`
- `int ft_achievement::get_goal(int id) const noexcept`
- `int ft_achievement::get_id() const noexcept`
- `int ft_achievement::get_progress(int id) const noexcept`
- `int ft_achievement::lock_pair(const ft_achievement &first, const ft_achievement &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `int ft_goal::get_error() const noexcept`
- `int ft_goal::get_progress() const noexcept`
- `int ft_goal::get_target() const noexcept`
- `int ft_goal::lock_pair(const ft_goal &first, const ft_goal &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `static void game_achievement_unlock_guard(ft_unique_lock<pt_mutex> &guard)`
- `static void game_goal_sleep_backoff() noexcept`
- `static void game_goal_unlock_guard(ft_unique_lock<pt_mutex> &guard) noexcept`
- `void ft_achievement::add_progress(int id, int value) noexcept`
- `void ft_achievement::set_error(int err) const noexcept`
- `void ft_achievement::set_goal(int id, int goal) noexcept`
- `void ft_achievement::set_goals(const ft_map<int, ft_goal> &goals) noexcept`
- `void ft_achievement::set_id(int id) noexcept`
- `void ft_achievement::set_progress(int id, int progress) noexcept`
- `void ft_goal::add_progress(int delta) noexcept`
- `void ft_goal::set_error(int error) const noexcept`
- `void ft_goal::set_progress(int value) noexcept`
- `void ft_goal::set_target(int target) noexcept`

### Game/game_achievement.hpp

- `const char *get_error_str() const noexcept;`
- `int get_error() const noexcept;`
- `int get_progress() const noexcept;`
- `int get_target() const noexcept;`
- `public: ft_goal() noexcept;`
- `static int lock_pair(const ft_goal &first, const ft_goal &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `void add_progress(int delta) noexcept;`
- `void set_error(int error) const noexcept;`
- `void set_progress(int value) noexcept;`
- `void set_target(int target) noexcept;`

### Game/game_behavior_action.cpp

- `const char *ft_behavior_action::get_error_str() const noexcept`
- `double ft_behavior_action::get_cooldown_seconds() const noexcept`
- `double ft_behavior_action::get_weight() const noexcept`
- `int ft_behavior_action::get_action_id() const noexcept`
- `int ft_behavior_action::get_error() const noexcept`
- `void ft_behavior_action::set_action_id(int action_id) noexcept`
- `void ft_behavior_action::set_cooldown_seconds(double cooldown_seconds) noexcept`
- `void ft_behavior_action::set_error(int error_code) const noexcept`
- `void ft_behavior_action::set_weight(double weight) noexcept`

### Game/game_behavior_profile.cpp

- `const char *ft_behavior_profile::get_error_str() const noexcept`
- `const ft_vector<ft_behavior_action> &ft_behavior_profile::get_actions() const noexcept`
- `double ft_behavior_profile::get_aggression_weight() const noexcept`
- `double ft_behavior_profile::get_caution_weight() const noexcept`
- `ft_vector<ft_behavior_action> &ft_behavior_profile::get_actions() noexcept`
- `int ft_behavior_profile::get_error() const noexcept`
- `int ft_behavior_profile::get_profile_id() const noexcept`
- `int ft_behavior_profile::lock_pair(const ft_behavior_profile &first, const ft_behavior_profile &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `void ft_behavior_profile::clone_from_unlocked(const ft_behavior_profile &other) noexcept`
- `void ft_behavior_profile::move_from_unlocked(ft_behavior_profile &other) noexcept`
- `void ft_behavior_profile::set_actions(const ft_vector<ft_behavior_action> &actions) noexcept`
- `void ft_behavior_profile::set_aggression_weight(double aggression_weight) noexcept`
- `void ft_behavior_profile::set_caution_weight(double caution_weight) noexcept`
- `void ft_behavior_profile::set_error(int error_code) const noexcept`
- `void ft_behavior_profile::set_profile_id(int profile_id) noexcept`

### Game/game_behavior_table.cpp

- `const char *ft_behavior_table::get_error_str() const noexcept`
- `const ft_map<int, ft_behavior_profile> &ft_behavior_table::get_profiles() const noexcept`
- `ft_map<int, ft_behavior_profile> &ft_behavior_table::get_profiles() noexcept`
- `int ft_behavior_table::clone_profiles_from(const ft_behavior_table &other) noexcept`
- `int ft_behavior_table::fetch_profile(int profile_id, ft_behavior_profile &profile) const noexcept`
- `int ft_behavior_table::get_error() const noexcept`
- `int ft_behavior_table::lock_pair(const ft_behavior_table &first, const ft_behavior_table &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `int ft_behavior_table::register_profile(const ft_behavior_profile &profile) noexcept`
- `void ft_behavior_table::record_operation_error_unlocked(int error_code)`
- `void ft_behavior_table::set_error(int error_code) const noexcept`
- `void ft_behavior_table::set_profiles(const ft_map<int, ft_behavior_profile> &profiles) noexcept`

### Game/game_behavior_table.hpp

- `const char *get_error_str() const noexcept;`
- `const ft_map<int, ft_behavior_profile> &get_profiles() const noexcept;`
- `ft_map<int, ft_behavior_profile> &get_profiles() noexcept;`
- `int clone_profiles_from(const ft_behavior_table &other) noexcept;`
- `int fetch_profile(int profile_id, ft_behavior_profile &profile) const noexcept;`
- `int get_error() const noexcept;`
- `int register_profile(const ft_behavior_profile &profile) noexcept;`
- `public: ft_behavior_table() noexcept;`
- `static int lock_pair(const ft_behavior_table &first, const ft_behavior_table &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `static void record_operation_error_unlocked(int error_code);`
- `void set_error(int error_code) const noexcept;`
- `void set_profiles(const ft_map<int, ft_behavior_profile> &profiles) noexcept;`

### Game/game_behavior_tree.cpp

- `bool ft_behavior_composite::validate_child(const ft_sharedptr<ft_behavior_node> &child) const noexcept`
- `const char *ft_behavior_node::get_error_str() const noexcept`
- `const char *ft_behavior_tree::get_error_str() const noexcept`
- `const ft_function<int(ft_behavior_context &)> &ft_behavior_action::get_callback() const noexcept`
- `const ft_sharedptr<ft_behavior_node> &ft_behavior_tree::get_root() const noexcept`
- `const ft_vector<ft_sharedptr<ft_behavior_node> > &ft_behavior_composite::get_children() const noexcept`
- `ft_character *ft_behavior_context::get_character() const noexcept`
- `ft_sharedptr<ft_behavior_node> &ft_behavior_tree::get_root() noexcept`
- `ft_vector<ft_sharedptr<ft_behavior_node> > &ft_behavior_composite::get_children() noexcept`
- `int ft_behavior_action::tick(ft_behavior_context &context) noexcept`
- `int ft_behavior_node::get_error() const noexcept`
- `int ft_behavior_selector::tick(ft_behavior_context &context) noexcept`
- `int ft_behavior_sequence::tick(ft_behavior_context &context) noexcept`
- `int ft_behavior_tree::get_error() const noexcept`
- `int ft_behavior_tree::tick(ft_behavior_context &context) noexcept`
- `void *ft_behavior_context::get_user_data() const noexcept`
- `void ft_behavior_action::set_callback(const ft_function<int(ft_behavior_context &)> &callback) noexcept`
- `void ft_behavior_composite::add_child(const ft_sharedptr<ft_behavior_node> &child) noexcept`
- `void ft_behavior_composite::clear_children() noexcept`
- `void ft_behavior_context::set_character(ft_character *character) noexcept`
- `void ft_behavior_context::set_user_data(void *user_data) noexcept`
- `void ft_behavior_node::set_error(int error_code) const noexcept`
- `void ft_behavior_tree::set_error(int error_code) const noexcept`
- `void ft_behavior_tree::set_root(const ft_sharedptr<ft_behavior_node> &root) noexcept`

### Game/game_behavior_tree.hpp

- `ft_character *get_character() const noexcept;`
- `public: ft_behavior_context() noexcept;`
- `void *get_user_data() const noexcept;`
- `void set_character(ft_character *character) noexcept;`
- `void set_user_data(void *user_data) noexcept;`

### Game/game_buff.cpp

- `const char *ft_buff::get_error_str() const noexcept`
- `int ft_buff::get_duration() const noexcept`
- `int ft_buff::get_error() const noexcept`
- `int ft_buff::get_id() const noexcept`
- `int ft_buff::get_modifier1() const noexcept`
- `int ft_buff::get_modifier2() const noexcept`
- `int ft_buff::get_modifier3() const noexcept`
- `int ft_buff::get_modifier4() const noexcept`
- `int ft_buff::lock_pair(const ft_buff &first, const ft_buff &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `static void game_buff_finalize_lock(ft_unique_lock<pt_mutex> &guard)`
- `void ft_buff::add_duration(int duration) noexcept`
- `void ft_buff::add_modifier1(int mod) noexcept`
- `void ft_buff::add_modifier2(int mod) noexcept`
- `void ft_buff::add_modifier3(int mod) noexcept`
- `void ft_buff::add_modifier4(int mod) noexcept`
- `void ft_buff::set_duration(int duration) noexcept`
- `void ft_buff::set_error(int err) const noexcept`
- `void ft_buff::set_id(int id) noexcept`
- `void ft_buff::set_modifier1(int mod) noexcept`
- `void ft_buff::set_modifier2(int mod) noexcept`
- `void ft_buff::set_modifier3(int mod) noexcept`
- `void ft_buff::set_modifier4(int mod) noexcept`
- `void ft_buff::sub_duration(int duration) noexcept`
- `void ft_buff::sub_modifier1(int mod) noexcept`
- `void ft_buff::sub_modifier2(int mod) noexcept`
- `void ft_buff::sub_modifier3(int mod) noexcept`
- `void ft_buff::sub_modifier4(int mod) noexcept`

### Game/game_buff.hpp

- `const char *get_error_str() const noexcept;`
- `int get_duration() const noexcept;`
- `int get_error() const noexcept;`
- `int get_id() const noexcept;`
- `int get_modifier1() const noexcept;`
- `int get_modifier2() const noexcept;`
- `int get_modifier3() const noexcept;`
- `int get_modifier4() const noexcept;`
- `public: ft_buff() noexcept;`
- `static int lock_pair(const ft_buff &first, const ft_buff &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_buff() = default;`
- `void add_duration(int duration) noexcept;`
- `void add_modifier1(int mod) noexcept;`
- `void add_modifier2(int mod) noexcept;`
- `void add_modifier3(int mod) noexcept;`
- `void add_modifier4(int mod) noexcept;`
- `void set_duration(int duration) noexcept;`
- `void set_error(int err) const noexcept;`
- `void set_id(int id) noexcept;`
- `void set_modifier1(int mod) noexcept;`
- `void set_modifier2(int mod) noexcept;`
- `void set_modifier3(int mod) noexcept;`
- `void set_modifier4(int mod) noexcept;`
- `void sub_duration(int duration) noexcept;`
- `void sub_modifier1(int mod) noexcept;`
- `void sub_modifier2(int mod) noexcept;`
- `void sub_modifier3(int mod) noexcept;`
- `void sub_modifier4(int mod) noexcept;`

### Game/game_character.hpp

- `int deserialize_character(ft_character &character, json_group *group);`
- `json_group *serialize_character(const ft_character &character);`

### Game/game_character_add_remove.cpp

- `int ft_character::add_skill(const ft_skill &skill) noexcept`
- `void ft_character::add_experience(int experience) noexcept`
- `void ft_character::add_valor(int valor) noexcept`
- `void ft_character::remove_skill(int id) noexcept`
- `void ft_character::sub_coins(int coins) noexcept`
- `void ft_character::sub_experience(int experience) noexcept`
- `void ft_character::sub_valor(int valor) noexcept`

### Game/game_character_constructor.cpp

- `bool ft_character::check_internal_errors() noexcept`
- `bool ft_character::handle_component_error(int error) noexcept`
- `int ft_character::lock_pair(const ft_character &first, const ft_character &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `static void game_character_restore_errno(ft_unique_lock<pt_mutex> &guard)`

### Game/game_character_getters_setters.cpp

- `bool ft_character::is_alive() const noexcept`
- `const char *ft_character::get_error_str() const noexcept`
- `const ft_experience_table &ft_character::get_experience_table() const noexcept`
- `const ft_map<int, ft_achievement> &ft_character::get_achievements() const noexcept`
- `const ft_map<int, ft_buff> &ft_character::get_buffs() const noexcept`
- `const ft_map<int, ft_debuff> &ft_character::get_debuffs() const noexcept`
- `const ft_map<int, ft_quest> &ft_character::get_quests() const noexcept`
- `const ft_map<int, ft_skill> &ft_character::get_skills() const noexcept`
- `const ft_map<int, ft_upgrade> &ft_character::get_upgrades() const noexcept`
- `const ft_operation_error_stack *ft_character::get_operation_error_stack_for_validation() const noexcept`
- `const ft_reputation &ft_character::get_reputation() const noexcept`
- `const ft_skill *ft_character::get_skill(int id) const noexcept`
- `ft_experience_table &ft_character::get_experience_table() noexcept`
- `ft_map<int, ft_achievement> &ft_character::get_achievements() noexcept`
- `ft_map<int, ft_buff> &ft_character::get_buffs() noexcept`
- `ft_map<int, ft_debuff> &ft_character::get_debuffs() noexcept`
- `ft_map<int, ft_quest> &ft_character::get_quests() noexcept`
- `ft_map<int, ft_skill> &ft_character::get_skills() noexcept`
- `ft_map<int, ft_upgrade> &ft_character::get_upgrades() noexcept`
- `ft_operation_error_stack *ft_character::get_operation_error_stack_for_validation() noexcept`
- `ft_reputation &ft_character::get_reputation() noexcept`
- `ft_resistance ft_character::get_air_res() const noexcept`
- `ft_resistance ft_character::get_chaos_res() const noexcept`
- `ft_resistance ft_character::get_earth_res() const noexcept`
- `ft_resistance ft_character::get_fire_res() const noexcept`
- `ft_resistance ft_character::get_frost_res() const noexcept`
- `ft_resistance ft_character::get_lightning_res() const noexcept`
- `ft_resistance ft_character::get_physical_res() const noexcept`
- `ft_sharedptr<ft_item> ft_character::get_equipped_item(int slot) const noexcept`
- `ft_sharedptr<ft_item> ft_character::get_equipped_item(int slot) noexcept`
- `ft_skill *ft_character::get_skill(int id) noexcept`
- `int ft_character::get_agility() const noexcept`
- `int ft_character::get_coins() const noexcept`
- `int ft_character::get_current_magic_armor() const noexcept`
- `int ft_character::get_current_physical_armor() const noexcept`
- `int ft_character::get_endurance() const noexcept`
- `int ft_character::get_error() const noexcept`
- `int ft_character::get_experience() const noexcept`
- `int ft_character::get_insigh() const noexcept`
- `int ft_character::get_level() const noexcept`
- `int ft_character::get_magic_armor() const noexcept`
- `int ft_character::get_might() const noexcept`
- `int ft_character::get_physical_armor() const noexcept`
- `int ft_character::get_presence() const noexcept`
- `int ft_character::get_reason() const noexcept`
- `int ft_character::get_valor() const noexcept`
- `int ft_character::get_x() const noexcept`
- `int ft_character::get_y() const noexcept`
- `int ft_character::get_z() const noexcept`
- `uint8_t ft_character::get_damage_rule() const noexcept`
- `void ft_character::record_operation_error(int error_code) const noexcept`
- `void ft_character::restore_magic_armor_internal() noexcept`
- `void ft_character::restore_physical_armor_internal() noexcept`
- `void ft_character::set_agility(int agility) noexcept`
- `void ft_character::set_air_res(int percent, int flat) noexcept`
- `void ft_character::set_chaos_res(int percent, int flat) noexcept`
- `void ft_character::set_coins(int coins) noexcept`
- `void ft_character::set_current_magic_armor(int armor) noexcept`
- `void ft_character::set_current_physical_armor(int armor) noexcept`
- `void ft_character::set_damage_rule(uint8_t rule) noexcept`
- `void ft_character::set_earth_res(int percent, int flat) noexcept`
- `void ft_character::set_endurance(int endurance) noexcept`
- `void ft_character::set_error(int err) const noexcept`
- `void ft_character::set_experience(int experience) noexcept`
- `void ft_character::set_fire_res(int percent, int flat) noexcept`
- `void ft_character::set_frost_res(int percent, int flat) noexcept`
- `void ft_character::set_hit_points(int hp) noexcept`
- `void ft_character::set_insigh(int insigh) noexcept`
- `void ft_character::set_lightning_res(int percent, int flat) noexcept`
- `void ft_character::set_magic_armor(int armor) noexcept`
- `void ft_character::set_magic_armor_internal(int armor) noexcept`
- `void ft_character::set_might(int might) noexcept`
- `void ft_character::set_physical_armor(int armor) noexcept`
- `void ft_character::set_physical_armor_internal(int armor) noexcept`
- `void ft_character::set_physical_res(int percent, int flat) noexcept`
- `void ft_character::set_presence(int presence) noexcept`
- `void ft_character::set_reason(int reason) noexcept`
- `void ft_character::set_valor(int valor) noexcept`
- `void ft_character::set_x(int x) noexcept`
- `void ft_character::set_y(int y) noexcept`
- `void ft_character::set_z(int z) noexcept`

### Game/game_character_misc.cpp

- `int ft_character::equip_item(int slot, const ft_sharedptr<ft_item> &item) noexcept`
- `long long ft_character::apply_skill_modifiers(long long damage) const noexcept`
- `long long ft_character::apply_skill_modifiers_internal(long long damage) const noexcept`
- `void ft_character::apply_modifier(const ft_item_modifier &mod, int sign) noexcept`
- `void ft_character::apply_modifier_internal(const ft_item_modifier &mod, int sign) noexcept`
- `void ft_character::move(int dx, int dy, int dz) noexcept`
- `void ft_character::restore_armor() noexcept`
- `void ft_character::restore_magic_armor() noexcept`
- `void ft_character::take_damage(long long damage, uint8_t type) noexcept`
- `void ft_character::take_damage_buffer(long long damage, uint8_t type) noexcept`
- `void ft_character::take_damage_buffer_internal(long long damage, uint8_t type) noexcept`
- `void ft_character::take_damage_flat(long long damage, uint8_t type) noexcept`
- `void ft_character::take_damage_flat_internal(long long damage, uint8_t type) noexcept`
- `void ft_character::take_damage_magic_shield(long long damage, uint8_t type) noexcept`
- `void ft_character::take_damage_magic_shield_internal(long long damage, uint8_t type) noexcept`
- `void ft_character::take_damage_scaled(long long damage, uint8_t type) noexcept`
- `void ft_character::take_damage_scaled_internal(long long damage, uint8_t type) noexcept`
- `void ft_character::unequip_item(int slot) noexcept`

### Game/game_character_save_load.cpp

- `int deserialize_character(ft_character &character, json_group *group)`

### Game/game_crafting.cpp

- `const char *ft_crafting::get_error_str() const noexcept`
- `const char *ft_crafting_ingredient::get_error_str() const noexcept`
- `const ft_map<int, ft_vector<ft_crafting_ingredient>> &ft_crafting::get_recipes() const noexcept`
- `ft_map<int, ft_vector<ft_crafting_ingredient>> &ft_crafting::get_recipes() noexcept`
- `int ft_crafting::craft_item(ft_inventory &inventory, int recipe_id, const ft_sharedptr<ft_item> &result) noexcept`
- `int ft_crafting::get_error() const noexcept`
- `int ft_crafting::lock_pair(const ft_crafting &first, const ft_crafting &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `int ft_crafting::register_recipe(int recipe_id, ft_vector<ft_crafting_ingredient> &&ingredients) noexcept`
- `int ft_crafting_ingredient::get_count() const noexcept`
- `int ft_crafting_ingredient::get_error() const noexcept`
- `int ft_crafting_ingredient::get_item_id() const noexcept`
- `int ft_crafting_ingredient::get_rarity() const noexcept`
- `int ft_crafting_ingredient::lock_pair(const ft_crafting_ingredient &first, const ft_crafting_ingredient &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `void ft_crafting::set_error(int error_code) const noexcept`
- `void ft_crafting_ingredient::set_count(int count) noexcept`
- `void ft_crafting_ingredient::set_error(int error_code) const noexcept`
- `void ft_crafting_ingredient::set_item_id(int item_id) noexcept`
- `void ft_crafting_ingredient::set_rarity(int rarity) noexcept`

### Game/game_crafting.hpp

- `const char *get_error_str() const noexcept;`
- `int get_count() const noexcept;`
- `int get_error() const noexcept;`
- `int get_item_id() const noexcept;`
- `int get_rarity() const noexcept;`
- `public: ft_crafting_ingredient() noexcept;`
- `static int lock_pair(const ft_crafting_ingredient &first, const ft_crafting_ingredient &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_crafting_ingredient() = default;`
- `void set_count(int count) noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_item_id(int item_id) noexcept;`
- `void set_rarity(int rarity) noexcept;`

### Game/game_currency_rate.cpp

- `const char *ft_currency_rate::get_error_str() const noexcept`
- `double ft_currency_rate::get_rate_to_base() const noexcept`
- `int ft_currency_rate::get_currency_id() const noexcept`
- `int ft_currency_rate::get_display_precision() const noexcept`
- `int ft_currency_rate::get_error() const noexcept`
- `int ft_currency_rate::lock_pair(const ft_currency_rate &first, const ft_currency_rate &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `void ft_currency_rate::record_operation_error_unlocked(int error_code)`
- `void ft_currency_rate::set_currency_id(int currency_id) noexcept`
- `void ft_currency_rate::set_display_precision(int display_precision) noexcept`
- `void ft_currency_rate::set_error(int error_code) const noexcept`
- `void ft_currency_rate::set_rate_to_base(double rate_to_base) noexcept`

### Game/game_data_catalog.cpp

- `const char *ft_data_catalog::get_error_str() const noexcept`
- `const char *ft_item_definition::get_error_str() const noexcept`
- `const char *ft_loadout_blueprint::get_error_str() const noexcept`
- `const char *ft_loadout_entry::get_error_str() const noexcept`
- `const char *ft_recipe_blueprint::get_error_str() const noexcept`
- `const ft_map<int, ft_item_definition> &ft_data_catalog::get_item_definitions() const noexcept`
- `const ft_map<int, ft_loadout_blueprint> &ft_data_catalog::get_loadouts() const noexcept`
- `const ft_map<int, ft_recipe_blueprint> &ft_data_catalog::get_recipes() const noexcept`
- `const ft_vector<ft_crafting_ingredient> &ft_recipe_blueprint::get_ingredients() const noexcept`
- `const ft_vector<ft_loadout_entry> &ft_loadout_blueprint::get_entries() const noexcept`
- `ft_map<int, ft_item_definition> &ft_data_catalog::get_item_definitions() noexcept`
- `ft_map<int, ft_loadout_blueprint> &ft_data_catalog::get_loadouts() noexcept`
- `ft_map<int, ft_recipe_blueprint> &ft_data_catalog::get_recipes() noexcept`
- `ft_vector<ft_crafting_ingredient> &ft_recipe_blueprint::get_ingredients() noexcept`
- `ft_vector<ft_loadout_entry> &ft_loadout_blueprint::get_entries() noexcept`
- `int ft_data_catalog::fetch_item_definition(int item_id, ft_item_definition &definition) const noexcept`
- `int ft_data_catalog::fetch_loadout(int loadout_id, ft_loadout_blueprint &loadout) const noexcept`
- `int ft_data_catalog::fetch_recipe(int recipe_id, ft_recipe_blueprint &recipe) const noexcept`
- `int ft_data_catalog::get_error() const noexcept`
- `int ft_data_catalog::lock_pair(const ft_data_catalog &first, const ft_data_catalog &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `int ft_data_catalog::register_item_definition(const ft_item_definition &definition) noexcept`
- `int ft_data_catalog::register_loadout(const ft_loadout_blueprint &loadout) noexcept`
- `int ft_data_catalog::register_recipe(const ft_recipe_blueprint &recipe) noexcept`
- `int ft_item_definition::get_error() const noexcept`
- `int ft_item_definition::get_height() const noexcept`
- `int ft_item_definition::get_item_id() const noexcept`
- `int ft_item_definition::get_max_stack() const noexcept`
- `int ft_item_definition::get_rarity() const noexcept`
- `int ft_item_definition::get_slot_requirement() const noexcept`
- `int ft_item_definition::get_weight() const noexcept`
- `int ft_item_definition::get_width() const noexcept`
- `int ft_item_definition::lock_pair(const ft_item_definition &first, const ft_item_definition &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `int ft_loadout_blueprint::get_error() const noexcept`
- `int ft_loadout_blueprint::get_loadout_id() const noexcept`
- `int ft_loadout_blueprint::lock_pair(const ft_loadout_blueprint &first, const ft_loadout_blueprint &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `int ft_loadout_entry::get_error() const noexcept`
- `int ft_loadout_entry::get_item_id() const noexcept`
- `int ft_loadout_entry::get_quantity() const noexcept`
- `int ft_loadout_entry::get_slot() const noexcept`
- `int ft_loadout_entry::lock_pair(const ft_loadout_entry &first, const ft_loadout_entry &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `int ft_recipe_blueprint::get_error() const noexcept`
- `int ft_recipe_blueprint::get_recipe_id() const noexcept`
- `int ft_recipe_blueprint::get_result_item_id() const noexcept`
- `int ft_recipe_blueprint::lock_pair(const ft_recipe_blueprint &first, const ft_recipe_blueprint &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `static void game_data_catalog_copy_crafting_vector(const ft_vector<ft_crafting_ingredient> &source, ft_vector<ft_crafting_ingredient> &destination)`
- `static void game_data_catalog_copy_loadout_vector(const ft_vector<ft_loadout_entry> &source, ft_vector<ft_loadout_entry> &destination)`
- `static void game_data_catalog_unlock_guard(ft_unique_lock<pt_mutex> &guard)`
- `void ft_data_catalog::set_error(int error_code) const noexcept`
- `void ft_item_definition::set_error(int error_code) const noexcept`
- `void ft_item_definition::set_height(int height) noexcept`
- `void ft_item_definition::set_item_id(int item_id) noexcept`
- `void ft_item_definition::set_max_stack(int max_stack) noexcept`
- `void ft_item_definition::set_rarity(int rarity) noexcept`
- `void ft_item_definition::set_slot_requirement(int slot_requirement) noexcept`
- `void ft_item_definition::set_weight(int weight) noexcept`
- `void ft_item_definition::set_width(int width) noexcept`
- `void ft_loadout_blueprint::set_entries(const ft_vector<ft_loadout_entry> &entries) noexcept`
- `void ft_loadout_blueprint::set_error(int error_code) const noexcept`
- `void ft_loadout_blueprint::set_loadout_id(int loadout_id) noexcept`
- `void ft_loadout_entry::set_error(int error_code) const noexcept`
- `void ft_loadout_entry::set_item_id(int item_id) noexcept`
- `void ft_loadout_entry::set_quantity(int quantity) noexcept`
- `void ft_loadout_entry::set_slot(int slot) noexcept`
- `void ft_recipe_blueprint::set_error(int error_code) const noexcept`
- `void ft_recipe_blueprint::set_ingredients(const ft_vector<ft_crafting_ingredient> &ingredients) noexcept`
- `void ft_recipe_blueprint::set_recipe_id(int recipe_id) noexcept`
- `void ft_recipe_blueprint::set_result_item_id(int result_item_id) noexcept`

### Game/game_data_catalog.hpp

- `const char *get_error_str() const noexcept;`
- `int get_error() const noexcept;`
- `int get_height() const noexcept;`
- `int get_item_id() const noexcept;`
- `int get_max_stack() const noexcept;`
- `int get_rarity() const noexcept;`
- `int get_slot_requirement() const noexcept;`
- `int get_weight() const noexcept;`
- `int get_width() const noexcept;`
- `public: ft_item_definition() noexcept;`
- `static int lock_pair(const ft_item_definition &first, const ft_item_definition &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_item_definition() = default;`
- `void set_error(int error_code) const noexcept;`
- `void set_height(int height) noexcept;`
- `void set_item_id(int item_id) noexcept;`
- `void set_max_stack(int max_stack) noexcept;`
- `void set_rarity(int rarity) noexcept;`
- `void set_slot_requirement(int slot_requirement) noexcept;`
- `void set_weight(int weight) noexcept;`
- `void set_width(int width) noexcept;`

### Game/game_debuff.cpp

- `const char *ft_debuff::get_error_str() const noexcept`
- `int ft_debuff::get_duration() const noexcept`
- `int ft_debuff::get_error() const noexcept`
- `int ft_debuff::get_id() const noexcept`
- `int ft_debuff::get_modifier1() const noexcept`
- `int ft_debuff::get_modifier2() const noexcept`
- `int ft_debuff::get_modifier3() const noexcept`
- `int ft_debuff::get_modifier4() const noexcept`
- `int ft_debuff::lock_pair(const ft_debuff &first, const ft_debuff &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `static void game_debuff_finalize_lock(ft_unique_lock<pt_mutex> &guard)`
- `void ft_debuff::add_duration(int duration) noexcept`
- `void ft_debuff::add_modifier1(int mod) noexcept`
- `void ft_debuff::add_modifier2(int mod) noexcept`
- `void ft_debuff::add_modifier3(int mod) noexcept`
- `void ft_debuff::add_modifier4(int mod) noexcept`
- `void ft_debuff::set_duration(int duration) noexcept`
- `void ft_debuff::set_error(int err) const noexcept`
- `void ft_debuff::set_id(int id) noexcept`
- `void ft_debuff::set_modifier1(int mod) noexcept`
- `void ft_debuff::set_modifier2(int mod) noexcept`
- `void ft_debuff::set_modifier3(int mod) noexcept`
- `void ft_debuff::set_modifier4(int mod) noexcept`
- `void ft_debuff::sub_duration(int duration) noexcept`
- `void ft_debuff::sub_modifier1(int mod) noexcept`
- `void ft_debuff::sub_modifier2(int mod) noexcept`
- `void ft_debuff::sub_modifier3(int mod) noexcept`
- `void ft_debuff::sub_modifier4(int mod) noexcept`

### Game/game_debuff.hpp

- `const char *get_error_str() const noexcept;`
- `int get_duration() const noexcept;`
- `int get_error() const noexcept;`
- `int get_id() const noexcept;`
- `int get_modifier1() const noexcept;`
- `int get_modifier2() const noexcept;`
- `int get_modifier3() const noexcept;`
- `int get_modifier4() const noexcept;`
- `public: ft_debuff() noexcept;`
- `static int lock_pair(const ft_debuff &first, const ft_debuff &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_debuff() = default;`
- `void add_duration(int duration) noexcept;`
- `void add_modifier1(int mod) noexcept;`
- `void add_modifier2(int mod) noexcept;`
- `void add_modifier3(int mod) noexcept;`
- `void add_modifier4(int mod) noexcept;`
- `void set_duration(int duration) noexcept;`
- `void set_error(int err) const noexcept;`
- `void set_id(int id) noexcept;`
- `void set_modifier1(int mod) noexcept;`
- `void set_modifier2(int mod) noexcept;`
- `void set_modifier3(int mod) noexcept;`
- `void set_modifier4(int mod) noexcept;`
- `void sub_duration(int duration) noexcept;`
- `void sub_modifier1(int mod) noexcept;`
- `void sub_modifier2(int mod) noexcept;`
- `void sub_modifier3(int mod) noexcept;`
- `void sub_modifier4(int mod) noexcept;`

### Game/game_dialogue_line.cpp

- `const char *ft_dialogue_line::get_error_str() const noexcept`
- `const ft_string &ft_dialogue_line::get_speaker() const noexcept`
- `const ft_string &ft_dialogue_line::get_text() const noexcept`
- `const ft_vector<int> &ft_dialogue_line::get_next_line_ids() const noexcept`
- `ft_vector<int> &ft_dialogue_line::get_next_line_ids() noexcept`
- `int ft_dialogue_line::get_error() const noexcept`
- `int ft_dialogue_line::get_line_id() const noexcept`
- `int ft_dialogue_line::lock_pair(const ft_dialogue_line &first, const ft_dialogue_line &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `void ft_dialogue_line::set_error(int error_code) const noexcept`
- `void ft_dialogue_line::set_line_id(int line_id) noexcept`
- `void ft_dialogue_line::set_next_line_ids(const ft_vector<int> &next_line_ids) noexcept`
- `void ft_dialogue_line::set_speaker(const ft_string &speaker) noexcept`
- `void ft_dialogue_line::set_text(const ft_string &text) noexcept`

### Game/game_dialogue_script.cpp

- `const char *ft_dialogue_script::get_error_str() const noexcept`
- `const ft_string &ft_dialogue_script::get_summary() const noexcept`
- `const ft_string &ft_dialogue_script::get_title() const noexcept`
- `const ft_vector<ft_dialogue_line> &ft_dialogue_script::get_lines() const noexcept`
- `ft_vector<ft_dialogue_line> &ft_dialogue_script::get_lines() noexcept`
- `int ft_dialogue_script::get_error() const noexcept`
- `int ft_dialogue_script::get_script_id() const noexcept`
- `int ft_dialogue_script::get_start_line_id() const noexcept`
- `int ft_dialogue_script::lock_pair(const ft_dialogue_script &first, const ft_dialogue_script &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `static void game_dialogue_copy_line_vector(const ft_vector<ft_dialogue_line> &source, ft_vector<ft_dialogue_line> &destination)`
- `void ft_dialogue_script::record_operation_error_unlocked(int error_code)`
- `void ft_dialogue_script::set_error(int error_code) const noexcept`
- `void ft_dialogue_script::set_lines(const ft_vector<ft_dialogue_line> &lines) noexcept`
- `void ft_dialogue_script::set_script_id(int script_id) noexcept`
- `void ft_dialogue_script::set_start_line_id(int start_line_id) noexcept`
- `void ft_dialogue_script::set_summary(const ft_string &summary) noexcept`
- `void ft_dialogue_script::set_title(const ft_string &title) noexcept`

### Game/game_dialogue_table.cpp

- `const char *ft_dialogue_table::get_error_str() const noexcept`
- `const ft_map<int, ft_dialogue_line> &ft_dialogue_table::get_lines() const noexcept`
- `const ft_map<int, ft_dialogue_script> &ft_dialogue_table::get_scripts() const noexcept`
- `ft_map<int, ft_dialogue_line> &ft_dialogue_table::get_lines() noexcept`
- `ft_map<int, ft_dialogue_script> &ft_dialogue_table::get_scripts() noexcept`
- `int ft_dialogue_table::clone_from(const ft_dialogue_table &other) noexcept`
- `int ft_dialogue_table::fetch_line(int line_id, ft_dialogue_line &out_line) const noexcept`
- `int ft_dialogue_table::fetch_script(int script_id, ft_dialogue_script &out_script) const noexcept`
- `int ft_dialogue_table::get_error() const noexcept`
- `int ft_dialogue_table::register_line(const ft_dialogue_line &line) noexcept`
- `int ft_dialogue_table::register_script(const ft_dialogue_script &script) noexcept`
- `static void game_dialogue_table_unlock_set_errno(ft_unique_lock<pt_mutex> &guard, int target_error)`
- `void ft_dialogue_table::record_operation_error_unlocked(int error_code)`
- `void ft_dialogue_table::set_error(int error_code) const noexcept`
- `void ft_dialogue_table::set_lines(const ft_map<int, ft_dialogue_line> &lines) noexcept`
- `void ft_dialogue_table::set_scripts(const ft_map<int, ft_dialogue_script> &scripts) noexcept`

### Game/game_dialogue_table.hpp

- `const char *get_error_str() const noexcept;`
- `const ft_map<int, ft_dialogue_line> &get_lines() const noexcept;`
- `const ft_map<int, ft_dialogue_script> &get_scripts() const noexcept;`
- `ft_map<int, ft_dialogue_line> &get_lines() noexcept;`
- `ft_map<int, ft_dialogue_script> &get_scripts() noexcept;`
- `int clone_from(const ft_dialogue_table &other) noexcept;`
- `int fetch_line(int line_id, ft_dialogue_line &out_line) const noexcept;`
- `int fetch_script(int script_id, ft_dialogue_script &out_script) const noexcept;`
- `int get_error() const noexcept;`
- `int register_line(const ft_dialogue_line &line) noexcept;`
- `int register_script(const ft_dialogue_script &script) noexcept;`
- `public: ft_dialogue_table() noexcept;`
- `static void record_operation_error_unlocked(int error_code);`
- `virtual ~ft_dialogue_table() noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_lines(const ft_map<int, ft_dialogue_line> &lines) noexcept;`
- `void set_scripts(const ft_map<int, ft_dialogue_script> &scripts) noexcept;`

### Game/game_economy_table.cpp

- `const char *ft_economy_table::get_error_str() const noexcept`
- `const ft_map<int, ft_currency_rate> &ft_economy_table::get_currency_rates() const noexcept`
- `const ft_map<int, ft_price_definition> &ft_economy_table::get_price_definitions() const noexcept`
- `const ft_map<int, ft_rarity_band> &ft_economy_table::get_rarity_bands() const noexcept`
- `const ft_map<int, ft_vendor_profile> &ft_economy_table::get_vendor_profiles() const noexcept`
- `ft_map<int, ft_currency_rate> &ft_economy_table::get_currency_rates() noexcept`
- `ft_map<int, ft_price_definition> &ft_economy_table::get_price_definitions() noexcept`
- `ft_map<int, ft_rarity_band> &ft_economy_table::get_rarity_bands() noexcept`
- `ft_map<int, ft_vendor_profile> &ft_economy_table::get_vendor_profiles() noexcept`
- `int ft_economy_table::fetch_currency_rate(int currency_id, ft_currency_rate &rate) const noexcept`
- `int ft_economy_table::fetch_price_definition(int item_id, ft_price_definition &definition) const noexcept`
- `int ft_economy_table::fetch_rarity_band(int rarity, ft_rarity_band &band) const noexcept`
- `int ft_economy_table::fetch_vendor_profile(int vendor_id, ft_vendor_profile &profile) const noexcept`
- `int ft_economy_table::get_error() const noexcept`
- `int ft_economy_table::register_currency_rate(const ft_currency_rate &rate) noexcept`
- `int ft_economy_table::register_price_definition(const ft_price_definition &definition) noexcept`
- `int ft_economy_table::register_rarity_band(const ft_rarity_band &band) noexcept`
- `int ft_economy_table::register_vendor_profile(const ft_vendor_profile &profile) noexcept`
- `void ft_economy_table::set_currency_rates(const ft_map<int, ft_currency_rate> &currency_rates) noexcept`
- `void ft_economy_table::set_error(int error_code) const noexcept`
- `void ft_economy_table::set_price_definitions(const ft_map<int, ft_price_definition> &price_definitions) noexcept`
- `void ft_economy_table::set_rarity_bands(const ft_map<int, ft_rarity_band> &rarity_bands) noexcept`
- `void ft_economy_table::set_vendor_profiles(ft_map<int, ft_vendor_profile> &&vendor_profiles) noexcept`

### Game/game_economy_table.hpp

- `const char *get_error_str() const noexcept;`
- `const ft_map<int, ft_currency_rate> &get_currency_rates() const noexcept;`
- `const ft_map<int, ft_price_definition> &get_price_definitions() const noexcept;`
- `const ft_map<int, ft_rarity_band> &get_rarity_bands() const noexcept;`
- `const ft_map<int, ft_vendor_profile> &get_vendor_profiles() const noexcept;`
- `ft_map<int, ft_currency_rate> &get_currency_rates() noexcept;`
- `ft_map<int, ft_price_definition> &get_price_definitions() noexcept;`
- `ft_map<int, ft_rarity_band> &get_rarity_bands() noexcept;`
- `ft_map<int, ft_vendor_profile> &get_vendor_profiles() noexcept;`
- `int fetch_currency_rate(int currency_id, ft_currency_rate &rate) const noexcept;`
- `int fetch_price_definition(int item_id, ft_price_definition &definition) const noexcept;`
- `int fetch_rarity_band(int rarity, ft_rarity_band &band) const noexcept;`
- `int fetch_vendor_profile(int vendor_id, ft_vendor_profile &profile) const noexcept;`
- `int get_error() const noexcept;`
- `int register_currency_rate(const ft_currency_rate &rate) noexcept;`
- `int register_price_definition(const ft_price_definition &definition) noexcept;`
- `int register_rarity_band(const ft_rarity_band &band) noexcept;`
- `int register_vendor_profile(const ft_vendor_profile &profile) noexcept;`
- `public: ft_economy_table() noexcept;`
- `static int lock_pair(const ft_economy_table &first, const ft_economy_table &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `void set_currency_rates(const ft_map<int, ft_currency_rate> &currency_rates) noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_price_definitions(const ft_map<int, ft_price_definition> &price_definitions) noexcept;`
- `void set_rarity_bands(const ft_map<int, ft_rarity_band> &rarity_bands) noexcept;`
- `void set_vendor_profiles(ft_map<int, ft_vendor_profile> &&vendor_profiles) noexcept;`

### Game/game_equipment.cpp

- `bool ft_equipment::validate_item(const ft_sharedptr<ft_item> &item) noexcept`
- `const char *ft_equipment::get_error_str() const noexcept`
- `ft_sharedptr<ft_item> ft_equipment::get_item(int slot) const noexcept`
- `ft_sharedptr<ft_item> ft_equipment::get_item(int slot) noexcept`
- `int ft_equipment::equip(int slot, const ft_sharedptr<ft_item> &item) noexcept`
- `int ft_equipment::get_error() const noexcept`
- `int ft_equipment::lock_pair(const ft_equipment &first, const ft_equipment &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `static void game_equipment_restore_errno(ft_unique_lock<pt_mutex> &guard)`
- `void ft_equipment::set_error(int err) const noexcept`
- `void ft_equipment::unequip(int slot) noexcept`

### Game/game_event.cpp

- `const char *ft_event::get_error_str() const noexcept`
- `const ft_function<void(ft_world&, ft_event&)> &ft_event::get_callback() const noexcept`
- `int ft_event::add_duration(int duration) noexcept`
- `int ft_event::get_duration() const noexcept`
- `int ft_event::get_error() const noexcept`
- `int ft_event::get_id() const noexcept`
- `int ft_event::get_modifier1() const noexcept`
- `int ft_event::get_modifier2() const noexcept`
- `int ft_event::get_modifier3() const noexcept`
- `int ft_event::get_modifier4() const noexcept`
- `int ft_event::lock_pair(const ft_event &first, const ft_event &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `static int game_event_restore_errno(ft_unique_lock<pt_mutex> &guard, int result_errno)`
- `void ft_event::add_modifier1(int mod) noexcept`
- `void ft_event::add_modifier2(int mod) noexcept`
- `void ft_event::add_modifier3(int mod) noexcept`
- `void ft_event::add_modifier4(int mod) noexcept`
- `void ft_event::set_callback(ft_function<void(ft_world&, ft_event&)> &&callback) noexcept`
- `void ft_event::set_duration(int duration) noexcept`
- `void ft_event::set_error(int err) const noexcept`
- `void ft_event::set_id(int id) noexcept`
- `void ft_event::set_modifier1(int mod) noexcept`
- `void ft_event::set_modifier2(int mod) noexcept`
- `void ft_event::set_modifier3(int mod) noexcept`
- `void ft_event::set_modifier4(int mod) noexcept`
- `void ft_event::sub_duration(int duration) noexcept`
- `void ft_event::sub_modifier1(int mod) noexcept`
- `void ft_event::sub_modifier2(int mod) noexcept`
- `void ft_event::sub_modifier3(int mod) noexcept`
- `void ft_event::sub_modifier4(int mod) noexcept`

### Game/game_event_scheduler.cpp

- `bool ft_event_scheduler::profiling_enabled() const noexcept`
- `const char *ft_event_scheduler::get_error_str() const noexcept`
- `int deserialize_event_scheduler(ft_sharedptr<ft_event_scheduler> &scheduler, json_group *group)`
- `int ft_event_scheduler::get_error() const noexcept`
- `int ft_event_scheduler::lock_pair(const ft_event_scheduler &first, const ft_event_scheduler &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `int log_event_to_file(const ft_event &event, const char *file_path) noexcept`
- `json_group *serialize_event_scheduler(const ft_sharedptr<ft_event_scheduler> &scheduler)`
- `size_t ft_event_scheduler::size() const noexcept`
- `static int add_item_field(json_group *group, const ft_string &key, int value)`
- `static void event_scheduler_profile_reset_struct(t_event_scheduler_profile &profile)`
- `static void event_scheduler_unlock(ft_unique_lock<pt_mutex> &guard)`
- `void ft_event_scheduler::cancel_event(int id) noexcept`
- `void ft_event_scheduler::clear() noexcept`
- `void ft_event_scheduler::dump_events(ft_vector<ft_sharedptr<ft_event> > &out) const noexcept`
- `void ft_event_scheduler::enable_profiling(bool enabled) noexcept`
- `void ft_event_scheduler::finalize_update(ft_vector<ft_sharedptr<ft_event> > &events, size_t ready_count, size_t rescheduled_count, size_t queue_depth, bool profiling_active, bool start_valid, t_high_resolution_time_point start_time) noexcept`
- `void ft_event_scheduler::record_profile_locked(size_t ready_count, size_t rescheduled_count, size_t queue_depth, long long duration_ns) const noexcept`
- `void ft_event_scheduler::reschedule_event(int id, int new_duration) noexcept`
- `void ft_event_scheduler::reset_profile() noexcept`
- `void ft_event_scheduler::reset_profile_locked() const noexcept`
- `void ft_event_scheduler::schedule_event(const ft_sharedptr<ft_event> &event) noexcept`
- `void ft_event_scheduler::set_error(int error) const noexcept`
- `void ft_event_scheduler::snapshot_profile(t_event_scheduler_profile &out) const noexcept`
- `void ft_event_scheduler::update_events(ft_sharedptr<ft_world> &world, int ticks, const char *log_file_path, ft_string *log_buffer) noexcept`
- `void log_event_to_buffer(const ft_event &event, ft_string &buffer) noexcept`

### Game/game_event_scheduler.hpp

- `int deserialize_event_scheduler(ft_sharedptr<ft_event_scheduler> &scheduler, json_group *group);`
- `int log_event_to_file(const ft_event &event, const char *file_path) noexcept;`
- `json_group *serialize_event_scheduler(const ft_sharedptr<ft_event_scheduler> &scheduler);`
- `void log_event_to_buffer(const ft_event &event, ft_string &buffer) noexcept;`

### Game/game_event_scheduler_telemetry.cpp

- `static void game_event_scheduler_telemetry_emit(const char *event_name, const char *attribute, long long delta_value, long long total_value, const char *unit, int error_code, bool success, const char *entity) noexcept`
- `static void game_event_scheduler_telemetry_update_state(ft_event_scheduler_telemetry_state &state, const t_event_scheduler_profile &profile) noexcept`
- `void game_event_scheduler_publish_telemetry(ft_event_scheduler &scheduler, ft_event_scheduler_telemetry_state &state) noexcept`
- `void game_event_scheduler_telemetry_record(ft_event_scheduler_telemetry_state &state, const t_event_scheduler_profile &profile) noexcept`
- `void game_event_scheduler_telemetry_state_initialize(ft_event_scheduler_telemetry_state &state, const char *scheduler_name) noexcept`
- `void game_event_scheduler_telemetry_state_reset(ft_event_scheduler_telemetry_state &state) noexcept`

### Game/game_event_scheduler_telemetry.hpp

- `void game_event_scheduler_publish_telemetry(ft_event_scheduler &scheduler, ft_event_scheduler_telemetry_state &state) noexcept;`
- `void game_event_scheduler_telemetry_record(ft_event_scheduler_telemetry_state &state, const t_event_scheduler_profile &profile) noexcept;`
- `void game_event_scheduler_telemetry_state_initialize(ft_event_scheduler_telemetry_state &state, const char *scheduler_name) noexcept;`
- `void game_event_scheduler_telemetry_state_reset(ft_event_scheduler_telemetry_state &state) noexcept;`

### Game/game_experience_table.cpp

- `bool ft_experience_table::is_valid(int count, const int *array) const noexcept`
- `const char *ft_experience_table::get_error_str() const noexcept`
- `int ft_experience_table::check_for_error() const noexcept`
- `int ft_experience_table::generate_levels_scaled(int count, int base, double multiplier) noexcept`
- `int ft_experience_table::generate_levels_total(int count, int base, double multiplier) noexcept`
- `int ft_experience_table::get_count() const noexcept`
- `int ft_experience_table::get_error() const noexcept`
- `int ft_experience_table::get_level(int experience) const noexcept`
- `int ft_experience_table::get_value(int index) const noexcept`
- `int ft_experience_table::lock_pair(const ft_experience_table &first, const ft_experience_table &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `int ft_experience_table::resize(int new_count) noexcept`
- `int ft_experience_table::resize_locked(int new_count, ft_unique_lock<pt_mutex> &guard, bool validate_existing) noexcept`
- `int ft_experience_table::set_levels(const int *levels, int count) noexcept`
- `static void game_experience_table_finalize_lock(ft_unique_lock<pt_mutex> &guard)`
- `void ft_experience_table::set_error(int err) const noexcept`
- `void ft_experience_table::set_value(int index, int value) noexcept`

### Game/game_experience_table.hpp

- `bool is_valid(int count, const int *array) const noexcept;`
- `const char *get_error_str() const noexcept;`
- `int check_for_error() const noexcept;`
- `int generate_levels_scaled(int count, int base, double multiplier) noexcept;`
- `int generate_levels_total(int count, int base, double multiplier) noexcept;`
- `int get_count() const noexcept;`
- `int get_error() const noexcept;`
- `int get_level(int experience) const noexcept;`
- `int get_value(int index) const noexcept;`
- `int resize(int new_count) noexcept;`
- `int resize_locked(int new_count, ft_unique_lock<pt_mutex> &guard, bool validate_existing = true) noexcept;`
- `int set_levels(const int *levels, int count) noexcept;`
- `public: ft_experience_table(int count = 0) noexcept;`
- `static int lock_pair(const ft_experience_table &first, const ft_experience_table &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `void set_error(int err) const noexcept;`
- `void set_value(int index, int value) noexcept;`

### Game/game_hooks.cpp

- `const char *ft_game_hooks::get_error_str() const noexcept`
- `ft_vector<ft_game_hook_metadata> ft_game_hooks::get_catalog_metadata() const noexcept`
- `ft_vector<ft_game_hook_metadata> ft_game_hooks::get_catalog_metadata_for(const ft_string &hook_identifier) const noexcept`
- `int ft_game_hooks::get_error() const noexcept`
- `int ft_game_hooks::lock_pair(const ft_game_hooks &first, const ft_game_hooks &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `static void game_hooks_sleep_backoff()`
- `static void game_hooks_unlock_guard(ft_unique_lock<pt_mutex> &guard)`
- `void ft_game_hooks::append_metadata_unlocked(const ft_game_hook_metadata &metadata) noexcept`
- `void ft_game_hooks::clone_catalog_from(const ft_game_hooks &other) noexcept`
- `void ft_game_hooks::collect_listeners_unlocked(const ft_string &hook_identifier, ft_vector<ft_game_hook_listener_entry> &out_listeners) const noexcept`
- `void ft_game_hooks::collect_metadata_unlocked(ft_vector<ft_game_hook_metadata> &out_metadata) const noexcept`
- `void ft_game_hooks::insert_listener_unlocked(const ft_game_hook_listener_entry &entry) noexcept`
- `void ft_game_hooks::invoke_hook(const ft_string &hook_identifier, ft_game_hook_context &context) const noexcept`
- `void ft_game_hooks::invoke_on_character_damaged(ft_character &character, int damage, uint8_t type) const noexcept`
- `void ft_game_hooks::invoke_on_event_triggered(ft_world &world, ft_event &event) const noexcept`
- `void ft_game_hooks::invoke_on_item_crafted(ft_character &character, ft_item &item) const noexcept`
- `void ft_game_hooks::register_listener(const ft_game_hook_metadata &metadata, int priority, ft_function<void(ft_game_hook_context&)> &&callback) noexcept`
- `void ft_game_hooks::remove_listener_unlocked(const ft_string &hook_identifier, const ft_string &listener_name) noexcept`
- `void ft_game_hooks::reset() noexcept`
- `void ft_game_hooks::set_error(int error) const noexcept`
- `void ft_game_hooks::set_on_character_damaged(ft_function<void(ft_character&, int, uint8_t)> &&callback) noexcept`
- `void ft_game_hooks::set_on_event_triggered(ft_function<void(ft_world&, ft_event&)> &&callback) noexcept`
- `void ft_game_hooks::set_on_item_crafted(ft_function<void(ft_character&, ft_item&)> &&callback) noexcept`
- `void ft_game_hooks::unregister_listener(const ft_string &hook_identifier, const ft_string &listener_name) noexcept`

### Game/game_inventory.cpp

- `bool ft_inventory::check_item_errors(const ft_sharedptr<ft_item> &item) const noexcept`
- `bool ft_inventory::handle_items_error() noexcept`
- `bool ft_inventory::has_item(int item_id) const noexcept`
- `bool ft_inventory::has_rarity(int rarity) const noexcept`
- `bool ft_inventory::is_full() const noexcept`
- `const char *ft_inventory::get_error_str() const noexcept`
- `const ft_map<int, ft_sharedptr<ft_item> > &ft_inventory::get_items() const noexcept`
- `ft_map<int, ft_sharedptr<ft_item> > &ft_inventory::get_items() noexcept`
- `int ft_inventory::add_item(const ft_sharedptr<ft_item> &item) noexcept`
- `int ft_inventory::count_item(int item_id) const noexcept`
- `int ft_inventory::count_rarity(int rarity) const noexcept`
- `int ft_inventory::get_current_weight() const noexcept`
- `int ft_inventory::get_error() const noexcept`
- `int ft_inventory::get_weight_limit() const noexcept`
- `int ft_inventory::lock_pair(const ft_inventory &first, const ft_inventory &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `size_t ft_inventory::get_capacity() const noexcept`
- `size_t ft_inventory::get_used() const noexcept`
- `static void game_inventory_set_errno(ft_unique_lock<pt_mutex> &guard, int errno_value)`
- `void ft_inventory::remove_item(int slot) noexcept`
- `void ft_inventory::resize(size_t capacity) noexcept`
- `void ft_inventory::set_current_weight(int weight) noexcept`
- `void ft_inventory::set_error(int err) const noexcept`
- `void ft_inventory::set_used_slots(size_t used) noexcept`
- `void ft_inventory::set_weight_limit(int limit) noexcept`

### Game/game_inventory.hpp

- `bool check_item_errors(const ft_sharedptr<ft_item> &item) const noexcept;`
- `bool handle_items_error() noexcept;`
- `bool has_item(int item_id) const noexcept;`
- `bool has_rarity(int rarity) const noexcept;`
- `bool is_full() const noexcept;`
- `const char *get_error_str() const noexcept;`
- `const ft_map<int, ft_sharedptr<ft_item> > &get_items() const noexcept;`
- `ft_map<int, ft_sharedptr<ft_item> > &get_items() noexcept;`
- `int add_item(const ft_sharedptr<ft_item> &item) noexcept;`
- `int count_item(int item_id) const noexcept;`
- `int count_rarity(int rarity) const noexcept;`
- `int get_current_weight() const noexcept;`
- `int get_error() const noexcept;`
- `int get_weight_limit() const noexcept;`
- `public: ft_inventory(size_t capacity = 0, int weight_limit = 0) noexcept;`
- `size_t get_capacity() const noexcept;`
- `size_t get_used() const noexcept;`
- `static int lock_pair(const ft_inventory &first, const ft_inventory &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_inventory() = default;`
- `void remove_item(int slot) noexcept;`
- `void resize(size_t capacity) noexcept;`
- `void set_current_weight(int weight) noexcept;`
- `void set_error(int err) const noexcept;`
- `void set_used_slots(size_t used) noexcept;`
- `void set_weight_limit(int limit) noexcept;`

### Game/game_item.cpp

- `const char *ft_item::get_error_str() const noexcept`
- `const char *ft_item_modifier::get_error_str() const noexcept`
- `ft_item_modifier ft_item::get_modifier1() const noexcept`
- `ft_item_modifier ft_item::get_modifier2() const noexcept`
- `ft_item_modifier ft_item::get_modifier3() const noexcept`
- `ft_item_modifier ft_item::get_modifier4() const noexcept`
- `int ft_item::get_error() const noexcept`
- `int ft_item::get_height() const noexcept`
- `int ft_item::get_item_id() const noexcept`
- `int ft_item::get_max_stack() const noexcept`
- `int ft_item::get_modifier1_id() const noexcept`
- `int ft_item::get_modifier1_value() const noexcept`
- `int ft_item::get_modifier2_id() const noexcept`
- `int ft_item::get_modifier2_value() const noexcept`
- `int ft_item::get_modifier3_id() const noexcept`
- `int ft_item::get_modifier3_value() const noexcept`
- `int ft_item::get_modifier4_id() const noexcept`
- `int ft_item::get_modifier4_value() const noexcept`
- `int ft_item::get_rarity() const noexcept`
- `int ft_item::get_stack_size() const noexcept`
- `int ft_item::get_width() const noexcept`
- `int ft_item::lock_pair(const ft_item &first, const ft_item &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `int ft_item_modifier::get_error() const noexcept`
- `int ft_item_modifier::get_id() const noexcept`
- `int ft_item_modifier::get_value() const noexcept`
- `int ft_item_modifier::lock_pair(const ft_item_modifier &first, const ft_item_modifier &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `static int game_item_reset_modifier(ft_item_modifier &modifier)`
- `static void game_item_modifier_unlock(ft_unique_lock<pt_mutex> &guard)`
- `static void game_item_sleep_backoff()`
- `static void game_item_unlock(ft_unique_lock<pt_mutex> &guard)`
- `void ft_item::add_to_stack(int amount) noexcept`
- `void ft_item::set_error(int err) const noexcept`
- `void ft_item::set_height(int height) noexcept`
- `void ft_item::set_item_id(int id) noexcept`
- `void ft_item::set_max_stack(int max) noexcept`
- `void ft_item::set_modifier1(const ft_item_modifier &mod) noexcept`
- `void ft_item::set_modifier1_id(int id) noexcept`
- `void ft_item::set_modifier1_value(int value) noexcept`
- `void ft_item::set_modifier2(const ft_item_modifier &mod) noexcept`
- `void ft_item::set_modifier2_id(int id) noexcept`
- `void ft_item::set_modifier2_value(int value) noexcept`
- `void ft_item::set_modifier3(const ft_item_modifier &mod) noexcept`
- `void ft_item::set_modifier3_id(int id) noexcept`
- `void ft_item::set_modifier3_value(int value) noexcept`
- `void ft_item::set_modifier4(const ft_item_modifier &mod) noexcept`
- `void ft_item::set_modifier4_id(int id) noexcept`
- `void ft_item::set_modifier4_value(int value) noexcept`
- `void ft_item::set_rarity(int rarity) noexcept`
- `void ft_item::set_stack_size(int amount) noexcept`
- `void ft_item::set_width(int width) noexcept`
- `void ft_item::sub_from_stack(int amount) noexcept`
- `void ft_item_modifier::set_error(int error_code) const noexcept`
- `void ft_item_modifier::set_id(int id) noexcept`
- `void ft_item_modifier::set_value(int value) noexcept`

### Game/game_item.hpp

- `const char *get_error_str() const noexcept;`
- `int get_error() const noexcept;`
- `int get_id() const noexcept;`
- `int get_value() const noexcept;`
- `public: ft_item_modifier() noexcept;`
- `static int lock_pair(const ft_item_modifier &first, const ft_item_modifier &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_item_modifier() = default;`
- `void set_error(int error_code) const noexcept;`
- `void set_id(int id) noexcept;`
- `void set_value(int value) noexcept;`

### Game/game_load.cpp

- `int deserialize_equipment(ft_character &character, json_group *group)`
- `int deserialize_equipment(ft_character &character, json_group *group);`
- `int deserialize_inventory(ft_inventory &inventory, json_group *group)`
- `int deserialize_inventory(ft_inventory &inventory, json_group *group);`
- `int deserialize_quest(ft_quest &quest, json_group *group)`
- `int deserialize_quest(ft_quest &quest, json_group *group);`
- `static int build_item_from_group(ft_item &item, json_group *group, const ft_string &item_prefix)`
- `static int parse_item_field(json_group *group, const ft_string &key, int &out_value)`

### Game/game_map3d.cpp

- `const char *ft_map3d::get_error_str() const`
- `const char *ft_map3d::last_operation_error_str() const noexcept`
- `const char *ft_map3d::operation_error_str_at(ft_size_t index) const noexcept`
- `ft_operation_error_stack *ft_map3d::get_operation_error_stack_for_validation() noexcept`
- `ft_unique_lock<pt_mutex> other_guard(other._mutex);`
- `int ft_map3d::get(size_t x, size_t y, size_t z) const`
- `int ft_map3d::get_error() const`
- `int ft_map3d::is_obstacle(size_t x, size_t y, size_t z) const`
- `int ft_map3d::last_operation_error() const noexcept`
- `int ft_map3d::lock_pair(const ft_map3d &first, const ft_map3d &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard) noexcept`
- `int ft_map3d::operation_error_at(ft_size_t index) const noexcept`
- `int ft_map3d::pop_newest_operation_error() noexcept`
- `int ft_map3d::pop_oldest_operation_error() noexcept`
- `size_t ft_map3d::get_depth() const`
- `size_t ft_map3d::get_height() const`
- `size_t ft_map3d::get_width() const`
- `size_t ft_map3d::index(size_t x, size_t y, size_t z) const`
- `void ft_map3d::allocate(size_t width, size_t height, size_t depth, int value)`
- `void ft_map3d::deallocate()`
- `void ft_map3d::finalize_lock(ft_unique_lock<pt_mutex> &guard) noexcept`
- `void ft_map3d::pop_operation_errors() noexcept`
- `void ft_map3d::record_operation_error(int error_code) const noexcept`
- `void ft_map3d::resize(size_t width, size_t height, size_t depth, int value)`
- `void ft_map3d::set(size_t x, size_t y, size_t z, int value)`
- `void ft_map3d::set_error(int err) const noexcept`
- `void ft_map3d::toggle_obstacle(size_t x, size_t y, size_t z, ft_pathfinding *listener)`

### Game/game_pathfinding.cpp

- `const char *ft_path_step::get_error_str() const noexcept`
- `const char *ft_pathfinding::get_error_str() const noexcept`
- `int ft_path_step::get_error() const noexcept`
- `int ft_path_step::lock_pair(const ft_path_step &first, const ft_path_step &second, ft_unique_lock<pt_recursive_mutex> &first_guard, ft_unique_lock<pt_recursive_mutex> &second_guard) noexcept`
- `int ft_path_step::set_coordinates(size_t x, size_t y, size_t z) noexcept`
- `int ft_path_step::set_x(size_t x) noexcept`
- `int ft_path_step::set_y(size_t y) noexcept`
- `int ft_path_step::set_z(size_t z) noexcept`
- `int ft_pathfinding::astar_grid(const ft_map3d &grid, size_t start_x, size_t start_y, size_t start_z, size_t goal_x, size_t goal_y, size_t goal_z, ft_vector<ft_path_step> &out_path) const noexcept`
- `int ft_pathfinding::dijkstra_graph(const ft_graph<int> &graph, size_t start_vertex, size_t goal_vertex, ft_vector<size_t> &out_path) const noexcept`
- `int ft_pathfinding::get_error() const noexcept`
- `int ft_pathfinding::lock_pair(const ft_pathfinding &first, const ft_pathfinding &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard) noexcept`
- `int ft_pathfinding::recalculate_path(const ft_map3d &grid, size_t start_x, size_t start_y, size_t start_z, size_t goal_x, size_t goal_y, size_t goal_z, ft_vector<ft_path_step> &out_path) noexcept`
- `size_t ft_path_step::get_x() const noexcept`
- `size_t ft_path_step::get_y() const noexcept`
- `size_t ft_path_step::get_z() const noexcept`
- `static void game_pathfinding_finalize_lock(ft_unique_lock<pt_mutex> &guard) noexcept`
- `static void game_pathfinding_finalize_lock(ft_unique_lock<pt_recursive_mutex> &guard) noexcept`
- `static void game_pathfinding_sleep_backoff() noexcept`
- `void ft_path_step::reset_system_error() const noexcept`
- `void ft_path_step::set_error(int error) const noexcept`
- `void ft_path_step::set_system_error(int error) const noexcept`
- `void ft_pathfinding::finalize_lock(ft_unique_lock<pt_mutex> &guard) noexcept`
- `void ft_pathfinding::set_error(int error) const noexcept`
- `void ft_pathfinding::sleep_backoff() noexcept`
- `void ft_pathfinding::update_obstacle(size_t x, size_t y, size_t z, int value) noexcept`

### Game/game_pathfinding.hpp

- `const char *get_error_str() const noexcept;`
- `inline bool ft_path_step_test_helper::is_locked(const ft_path_step &step) noexcept`
- `inline bool ft_path_step_test_helper::is_owned_by_thread(const ft_path_step &step, pthread_t thread_id) noexcept`
- `inline int ft_path_step_test_helper::get_mutex_error(const ft_path_step &step) noexcept`
- `inline int ft_path_step_test_helper::lock(ft_path_step &step) noexcept`
- `inline int ft_path_step_test_helper::unlock(ft_path_step &step) noexcept`
- `int astar_grid(const ft_map3d &grid, size_t start_x, size_t start_y, size_t start_z, size_t goal_x, size_t goal_y, size_t goal_z, ft_vector<ft_path_step> &out_path) const noexcept;`
- `int dijkstra_graph(const ft_graph<int> &graph, size_t start_vertex, size_t goal_vertex, ft_vector<size_t> &out_path) const noexcept;`
- `int get_error() const noexcept;`
- `int recalculate_path(const ft_map3d &grid, size_t start_x, size_t start_y, size_t start_z, size_t goal_x, size_t goal_y, size_t goal_z, ft_vector<ft_path_step> &out_path) noexcept;`
- `int set_coordinates(size_t x, size_t y, size_t z) noexcept;`
- `int set_x(size_t x) noexcept;`
- `int set_y(size_t y) noexcept;`
- `int set_z(size_t z) noexcept;`
- `public: ft_pathfinding() noexcept;`
- `size_t get_x() const noexcept;`
- `size_t get_y() const noexcept;`
- `size_t get_z() const noexcept;`
- `static bool is_locked(const ft_path_step &step) noexcept;`
- `static bool is_owned_by_thread(const ft_path_step &step, pthread_t thread_id) noexcept;`
- `static int get_mutex_error(const ft_path_step &step) noexcept;`
- `static int lock(ft_path_step &step) noexcept;`
- `static int lock_pair(const ft_path_step &first, const ft_path_step &second, ft_unique_lock<pt_recursive_mutex> &first_guard, ft_unique_lock<pt_recursive_mutex> &second_guard) noexcept;`
- `static int lock_pair(const ft_pathfinding &first, const ft_pathfinding &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard) noexcept;`
- `static int unlock(ft_path_step &step) noexcept;`
- `static void finalize_lock(ft_unique_lock<pt_mutex> &guard) noexcept;`
- `static void sleep_backoff() noexcept;`
- `void reset_system_error() const noexcept;`
- `void set_error(int error) const noexcept;`
- `void set_system_error(int error) const noexcept;`
- `void update_obstacle(size_t x, size_t y, size_t z, int value) noexcept;`

### Game/game_price_definition.cpp

- `const char *ft_price_definition::get_error_str() const noexcept`
- `int ft_price_definition::get_base_value() const noexcept`
- `int ft_price_definition::get_error() const noexcept`
- `int ft_price_definition::get_item_id() const noexcept`
- `int ft_price_definition::get_maximum_value() const noexcept`
- `int ft_price_definition::get_minimum_value() const noexcept`
- `int ft_price_definition::get_rarity() const noexcept`
- `void ft_price_definition::set_base_value(int base_value) noexcept`
- `void ft_price_definition::set_error(int error_code) const noexcept`
- `void ft_price_definition::set_item_id(int item_id) noexcept`
- `void ft_price_definition::set_maximum_value(int maximum_value) noexcept`
- `void ft_price_definition::set_minimum_value(int minimum_value) noexcept`
- `void ft_price_definition::set_rarity(int rarity) noexcept`

### Game/game_progress_tracker.cpp

- `bool ft_progress_tracker::is_achievement_complete(int achievement_id) const noexcept`
- `bool ft_progress_tracker::is_quest_complete(int quest_id) const noexcept`
- `const char *ft_progress_tracker::get_error_str() const noexcept`
- `const ft_map<int, ft_achievement> &ft_progress_tracker::get_achievements() const noexcept`
- `const ft_map<int, ft_quest> &ft_progress_tracker::get_quests() const noexcept`
- `ft_map<int, ft_achievement> &ft_progress_tracker::get_achievements() noexcept`
- `ft_map<int, ft_quest> &ft_progress_tracker::get_quests() noexcept`
- `int ft_progress_tracker::add_goal_progress(int achievement_id, int goal_id, int value) noexcept`
- `int ft_progress_tracker::advance_quest_phase(int quest_id) noexcept`
- `int ft_progress_tracker::get_error() const noexcept`
- `int ft_progress_tracker::lock_pair(const ft_progress_tracker &first, const ft_progress_tracker &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `int ft_progress_tracker::register_achievement(const ft_achievement &achievement) noexcept`
- `int ft_progress_tracker::register_quest(const ft_quest &quest) noexcept`
- `int ft_progress_tracker::set_quest_phase(int quest_id, int phase) noexcept`
- `int ft_progress_tracker::update_goal_progress(int achievement_id, int goal_id, int progress) noexcept`
- `int ft_progress_tracker::update_goal_target(int achievement_id, int goal_id, int target) noexcept`
- `static void game_progress_tracker_sleep_backoff()`
- `void ft_progress_tracker::record_operation_error_unlocked(int error_code)`
- `void ft_progress_tracker::set_achievements(const ft_map<int, ft_achievement> &achievements) noexcept`
- `void ft_progress_tracker::set_error(int error) const noexcept`
- `void ft_progress_tracker::set_quests(const ft_map<int, ft_quest> &quests) noexcept`

### Game/game_progress_tracker.hpp

- `bool is_achievement_complete(int achievement_id) const noexcept;`
- `bool is_quest_complete(int quest_id) const noexcept;`
- `const char *get_error_str() const noexcept;`
- `const ft_map<int, ft_achievement> &get_achievements() const noexcept;`
- `const ft_map<int, ft_quest> &get_quests() const noexcept;`
- `ft_map<int, ft_achievement> &get_achievements() noexcept;`
- `ft_map<int, ft_quest> &get_quests() noexcept;`
- `int add_goal_progress(int achievement_id, int goal_id, int value) noexcept;`
- `int advance_quest_phase(int quest_id) noexcept;`
- `int get_error() const noexcept;`
- `int register_achievement(const ft_achievement &achievement) noexcept;`
- `int register_quest(const ft_quest &quest) noexcept;`
- `int set_quest_phase(int quest_id, int phase) noexcept;`
- `int update_goal_progress(int achievement_id, int goal_id, int progress) noexcept;`
- `int update_goal_target(int achievement_id, int goal_id, int target) noexcept;`
- `public: ft_progress_tracker() noexcept;`
- `static int lock_pair(const ft_progress_tracker &first, const ft_progress_tracker &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `static void record_operation_error_unlocked(int error_code);`
- `void set_achievements(const ft_map<int, ft_achievement> &achievements) noexcept;`
- `void set_error(int error) const noexcept;`
- `void set_quests(const ft_map<int, ft_quest> &quests) noexcept;`

### Game/game_quest.cpp

- `bool ft_quest::is_complete() const noexcept`
- `const char *ft_quest::get_error_str() const noexcept`
- `const ft_operation_error_stack *ft_quest::get_operation_error_stack_for_validation() const noexcept`
- `const ft_string &ft_quest::get_description() const noexcept`
- `const ft_string &ft_quest::get_objective() const noexcept`
- `const ft_vector<ft_sharedptr<ft_item> > &ft_quest::get_reward_items() const noexcept`
- `ft_operation_error_stack *ft_quest::get_operation_error_stack_for_validation() noexcept`
- `ft_vector<ft_sharedptr<ft_item> > &ft_quest::get_reward_items() noexcept`
- `int ft_quest::get_current_phase() const noexcept`
- `int ft_quest::get_error() const noexcept`
- `int ft_quest::get_id() const noexcept`
- `int ft_quest::get_phases() const noexcept`
- `int ft_quest::get_reward_experience() const noexcept`
- `int ft_quest::lock_pair(const ft_quest &first, const ft_quest &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `static void game_quest_unlock_guard(ft_unique_lock<pt_mutex> &guard)`
- `void ft_quest::advance_phase() noexcept`
- `void ft_quest::record_operation_error(int error_code) const noexcept`
- `void ft_quest::set_current_phase(int phase) noexcept`
- `void ft_quest::set_description(const ft_string &description) noexcept`
- `void ft_quest::set_error(int err) const noexcept`
- `void ft_quest::set_id(int id) noexcept`
- `void ft_quest::set_objective(const ft_string &objective) noexcept`
- `void ft_quest::set_phases(int phases) noexcept`
- `void ft_quest::set_reward_experience(int experience) noexcept`
- `void ft_quest::set_reward_items(const ft_vector<ft_sharedptr<ft_item> > &items) noexcept`

### Game/game_quest.hpp

- `bool is_complete() const noexcept;`
- `const char *get_error_str() const noexcept;`
- `const ft_operation_error_stack *get_operation_error_stack_for_validation() const noexcept;`
- `const ft_string &get_description() const noexcept;`
- `const ft_string &get_objective() const noexcept;`
- `const ft_vector<ft_sharedptr<ft_item> > &get_reward_items() const noexcept;`
- `ft_operation_error_stack *get_operation_error_stack_for_validation() noexcept;`
- `ft_vector<ft_sharedptr<ft_item> > &get_reward_items() noexcept;`
- `int get_current_phase() const noexcept;`
- `int get_error() const noexcept;`
- `int get_id() const noexcept;`
- `int get_phases() const noexcept;`
- `int get_reward_experience() const noexcept;`
- `public: ft_quest() noexcept;`
- `static int lock_pair(const ft_quest &first, const ft_quest &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_quest() noexcept;`
- `void advance_phase() noexcept;`
- `void record_operation_error(int error_code) const noexcept;`
- `void set_current_phase(int phase) noexcept;`
- `void set_description(const ft_string &description) noexcept;`
- `void set_error(int err) const noexcept;`
- `void set_id(int id) noexcept;`
- `void set_objective(const ft_string &objective) noexcept;`
- `void set_phases(int phases) noexcept;`
- `void set_reward_experience(int experience) noexcept;`
- `void set_reward_items(const ft_vector<ft_sharedptr<ft_item> > &items) noexcept;`

### Game/game_rarity_band.cpp

- `const char *ft_rarity_band::get_error_str() const noexcept`
- `double ft_rarity_band::get_value_multiplier() const noexcept`
- `int ft_rarity_band::get_error() const noexcept`
- `int ft_rarity_band::get_rarity() const noexcept`
- `int ft_rarity_band::lock_pair(const ft_rarity_band &first, const ft_rarity_band &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `void ft_rarity_band::record_operation_error_unlocked(int error_code)`
- `void ft_rarity_band::set_error(int error_code) const noexcept`
- `void ft_rarity_band::set_rarity(int rarity) noexcept`
- `void ft_rarity_band::set_value_multiplier(double value_multiplier) noexcept`

### Game/game_region_definition.cpp

- `const char *ft_region_definition::get_error_str() const noexcept`
- `const ft_string &ft_region_definition::get_description() const noexcept`
- `const ft_string &ft_region_definition::get_name() const noexcept`
- `int ft_region_definition::get_error() const noexcept`
- `int ft_region_definition::get_recommended_level() const noexcept`
- `int ft_region_definition::get_region_id() const noexcept`
- `void ft_region_definition::set_description(const ft_string &description) noexcept`
- `void ft_region_definition::set_error(int error_code) const noexcept`
- `void ft_region_definition::set_name(const ft_string &name) noexcept`
- `void ft_region_definition::set_recommended_level(int recommended_level) noexcept`
- `void ft_region_definition::set_region_id(int region_id) noexcept`

### Game/game_reputation.cpp

- `const char *ft_reputation::get_error_str() const noexcept`
- `const ft_map<int, int> &ft_reputation::get_milestones() const noexcept`
- `const ft_map<int, int> &ft_reputation::get_reps() const noexcept`
- `ft_map<int, int> &ft_reputation::get_milestones() noexcept`
- `ft_map<int, int> &ft_reputation::get_reps() noexcept`
- `int ft_reputation::get_current_rep() const noexcept`
- `int ft_reputation::get_error() const noexcept`
- `int ft_reputation::get_milestone(int id) const noexcept`
- `int ft_reputation::get_rep(int id) const noexcept`
- `int ft_reputation::get_total_rep() const noexcept`
- `int ft_reputation::lock_pair(const ft_reputation &first, const ft_reputation &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `static void game_reputation_restore_errno(ft_unique_lock<pt_mutex> &guard)`
- `void ft_reputation::add_current_rep(int rep) noexcept`
- `void ft_reputation::add_total_rep(int rep) noexcept`
- `void ft_reputation::set_current_rep(int rep) noexcept`
- `void ft_reputation::set_error(int err) const noexcept`
- `void ft_reputation::set_milestone(int id, int value) noexcept`
- `void ft_reputation::set_milestones(const ft_map<int, int> &milestones) noexcept`
- `void ft_reputation::set_rep(int id, int value) noexcept`
- `void ft_reputation::set_reps(const ft_map<int, int> &reps) noexcept`
- `void ft_reputation::set_total_rep(int rep) noexcept`
- `void ft_reputation::sub_current_rep(int rep) noexcept`
- `void ft_reputation::sub_total_rep(int rep) noexcept`

### Game/game_reputation.hpp

- `const char *get_error_str() const noexcept;`
- `const ft_map<int, int> &get_milestones() const noexcept;`
- `const ft_map<int, int> &get_reps() const noexcept;`
- `ft_map<int, int> &get_milestones() noexcept;`
- `ft_map<int, int> &get_reps() noexcept;`
- `int get_current_rep() const noexcept;`
- `int get_error() const noexcept;`
- `int get_milestone(int id) const noexcept;`
- `int get_rep(int id) const noexcept;`
- `int get_total_rep() const noexcept;`
- `public: ft_reputation() noexcept;`
- `static int lock_pair(const ft_reputation &first, const ft_reputation &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_reputation() = default;`
- `void add_current_rep(int rep) noexcept;`
- `void add_total_rep(int rep) noexcept;`
- `void set_current_rep(int rep) noexcept;`
- `void set_error(int err) const noexcept;`
- `void set_milestone(int id, int value) noexcept;`
- `void set_milestones(const ft_map<int, int> &milestones) noexcept;`
- `void set_rep(int id, int value) noexcept;`
- `void set_reps(const ft_map<int, int> &reps) noexcept;`
- `void set_total_rep(int rep) noexcept;`
- `void sub_current_rep(int rep) noexcept;`
- `void sub_total_rep(int rep) noexcept;`

### Game/game_resistance.cpp

- `const char *ft_resistance::get_error_str() const noexcept`
- `int ft_resistance::get_error() const noexcept`
- `int ft_resistance::get_flat() const noexcept`
- `int ft_resistance::get_percent() const noexcept`
- `int ft_resistance::lock_pair(const ft_resistance &first, const ft_resistance &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `int ft_resistance::reset() noexcept`
- `int ft_resistance::set_flat(int flat_value) noexcept`
- `int ft_resistance::set_percent(int percent_value) noexcept`
- `int ft_resistance::set_values(int percent_value, int flat_value) noexcept`
- `static void game_resistance_restore_errno(ft_unique_lock<pt_mutex> &guard) noexcept`
- `void ft_resistance::set_error(int error) const noexcept`

### Game/game_resistance.hpp

- `const char *get_error_str() const noexcept;`
- `int get_error() const noexcept;`
- `int get_flat() const noexcept;`
- `int get_percent() const noexcept;`
- `int reset() noexcept;`
- `int set_flat(int flat_value) noexcept;`
- `int set_percent(int percent_value) noexcept;`
- `int set_values(int percent_value, int flat_value) noexcept;`
- `public: ft_resistance() noexcept;`
- `static int lock_pair(const ft_resistance &first, const ft_resistance &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `void set_error(int error) const noexcept;`

### Game/game_save.cpp

- `json_group *serialize_equipment(const ft_character &character)`
- `json_group *serialize_equipment(const ft_character &character);`
- `json_group *serialize_inventory(const ft_inventory &inventory)`
- `json_group *serialize_inventory(const ft_inventory &inventory);`
- `json_group *serialize_quest(const ft_quest &quest)`
- `json_group *serialize_quest(const ft_quest &quest);`
- `static int add_item_field(json_group *group, const ft_string &key, int value)`
- `static int serialize_item_fields(json_group *group, const ft_item &item, const ft_string &item_prefix)`

### Game/game_scripting_bridge.cpp

- `bool ft_game_script_bridge::is_supported_language(const ft_string &language) noexcept`
- `const char *ft_game_script_bridge::get_error_str() const noexcept`
- `const char *ft_game_script_context::get_error_str() const noexcept`
- `const ft_sharedptr<ft_world> &ft_game_script_context::get_world() const noexcept`
- `const ft_string &ft_game_script_bridge::get_language() const noexcept`
- `const ft_string *ft_game_script_context::get_variable(const ft_string &key) const noexcept`
- `ft_game_state *ft_game_script_context::get_state() const noexcept`
- `int ft_game_script_bridge::check_sandbox_capabilities(const ft_string &script, ft_vector<ft_string> &violations) noexcept`
- `int ft_game_script_bridge::execute(const ft_string &script, ft_game_state &state) noexcept`
- `int ft_game_script_bridge::execute_line(ft_game_script_context &context, const ft_string &line) noexcept`
- `int ft_game_script_bridge::get_error() const noexcept`
- `int ft_game_script_bridge::get_max_operations() const noexcept`
- `int ft_game_script_bridge::handle_call(ft_game_script_context &context, const ft_vector<ft_string> &tokens) noexcept`
- `int ft_game_script_bridge::handle_set(ft_game_script_context &context, const ft_vector<ft_string> &tokens) noexcept`
- `int ft_game_script_bridge::handle_unset(ft_game_script_context &context, const ft_vector<ft_string> &tokens) noexcept`
- `int ft_game_script_bridge::inspect_bytecode_budget(const ft_string &script, int &required_operations) noexcept`
- `int ft_game_script_bridge::register_function(const ft_string &name, const ft_function<int(ft_game_script_context &, const ft_vector<ft_string> &)> &callback) noexcept`
- `int ft_game_script_bridge::remove_function(const ft_string &name) noexcept`
- `int ft_game_script_bridge::validate_dry_run(const ft_string &script, ft_vector<ft_string> &warnings) noexcept`
- `int ft_game_script_context::get_error() const noexcept`
- `size_t ft_game_script_bridge::get_callback_count() const noexcept`
- `void ft_game_script_bridge::set_error(int error) const noexcept`
- `void ft_game_script_bridge::set_language(const char *language) noexcept`
- `void ft_game_script_bridge::set_max_operations(int limit) noexcept`
- `void ft_game_script_bridge::tokenize_line(const ft_string &line, ft_vector<ft_string> &tokens) const noexcept`
- `void ft_game_script_context::clear_variables() noexcept`
- `void ft_game_script_context::remove_variable(const ft_string &key) noexcept`
- `void ft_game_script_context::set_error(int error) const noexcept`
- `void ft_game_script_context::set_state(ft_game_state *state) noexcept`
- `void ft_game_script_context::set_variable(const ft_string &key, const ft_string &value) noexcept`
- `void ft_game_script_context::set_world(const ft_sharedptr<ft_world> &world) noexcept`

### Game/game_scripting_bridge.hpp

- `const char *get_error_str() const noexcept;`
- `const ft_sharedptr<ft_world> &get_world() const noexcept;`
- `const ft_string *get_variable(const ft_string &key) const noexcept;`
- `ft_game_state *get_state() const noexcept;`
- `int get_error() const noexcept;`
- `public: ft_game_script_context() noexcept;`
- `void clear_variables() noexcept;`
- `void remove_variable(const ft_string &key) noexcept;`
- `void set_error(int error) const noexcept;`
- `void set_state(ft_game_state *state) noexcept;`
- `void set_variable(const ft_string &key, const ft_string &value) noexcept;`
- `void set_world(const ft_sharedptr<ft_world> &world) noexcept;`

### Game/game_server.cpp

- `const char *ft_game_server::get_error_str() const noexcept`
- `int ft_game_server::get_error() const noexcept`
- `int ft_game_server::handle_message_locked(int client_handle, const ft_string &message, ft_unique_lock<pt_mutex> &guard) noexcept`
- `int ft_game_server::lock_pair(const ft_game_server &first, const ft_game_server &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `int ft_game_server::serialize_world_locked(ft_string &out, ft_unique_lock<pt_mutex> &guard) const noexcept`
- `int ft_game_server::start(const char *ip, uint16_t port) noexcept`
- `void ft_game_server::join_client_locked(int client_id, int client_handle, ft_unique_lock<pt_mutex> &guard) noexcept`
- `void ft_game_server::leave_client_locked(int client_id, ft_unique_lock<pt_mutex> &guard) noexcept`
- `void ft_game_server::run_once() noexcept`
- `void ft_game_server::set_error(int error) const noexcept`
- `void ft_game_server::set_join_callback(void (*callback)(int)) noexcept`
- `void ft_game_server::set_leave_callback(void (*callback)(int)) noexcept`

### Game/game_server.hpp

- `const char *get_error_str() const noexcept;`
- `int get_error() const noexcept;`
- `int handle_message_locked(int client_handle, const ft_string &message, ft_unique_lock<pt_mutex> &guard) noexcept;`
- `int serialize_world_locked(ft_string &out, ft_unique_lock<pt_mutex> &guard) const noexcept;`
- `int start(const char *ip, uint16_t port) noexcept;`
- `public: ft_game_server(const ft_sharedptr<ft_world> &world, const char *auth_token = ft_nullptr) noexcept;`
- `static int lock_pair(const ft_game_server &first, const ft_game_server &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `void (*_on_join)(int);`
- `void (*_on_leave)(int);`
- `void join_client_locked(int client_id, int client_handle, ft_unique_lock<pt_mutex> &guard) noexcept;`
- `void leave_client_locked(int client_id, ft_unique_lock<pt_mutex> &guard) noexcept;`
- `void run_once() noexcept;`
- `void set_error(int error) const noexcept;`
- `void set_join_callback(void (*callback)(int)) noexcept;`
- `void set_leave_callback(void (*callback)(int)) noexcept;`

### Game/game_skill.cpp

- `const char *ft_skill::get_error_str() const noexcept`
- `int ft_skill::get_cooldown() const noexcept`
- `int ft_skill::get_error() const noexcept`
- `int ft_skill::get_id() const noexcept`
- `int ft_skill::get_level() const noexcept`
- `int ft_skill::get_modifier1() const noexcept`
- `int ft_skill::get_modifier2() const noexcept`
- `int ft_skill::get_modifier3() const noexcept`
- `int ft_skill::get_modifier4() const noexcept`
- `int ft_skill::lock_pair(const ft_skill &first, const ft_skill &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `static void game_skill_unlock(ft_unique_lock<pt_mutex> &guard)`
- `void ft_skill::add_cooldown(int cooldown) noexcept`
- `void ft_skill::add_modifier1(int mod) noexcept`
- `void ft_skill::add_modifier2(int mod) noexcept`
- `void ft_skill::add_modifier3(int mod) noexcept`
- `void ft_skill::add_modifier4(int mod) noexcept`
- `void ft_skill::set_cooldown(int cooldown) noexcept`
- `void ft_skill::set_error(int err) const noexcept`
- `void ft_skill::set_id(int id) noexcept`
- `void ft_skill::set_level(int level) noexcept`
- `void ft_skill::set_modifier1(int mod) noexcept`
- `void ft_skill::set_modifier2(int mod) noexcept`
- `void ft_skill::set_modifier3(int mod) noexcept`
- `void ft_skill::set_modifier4(int mod) noexcept`
- `void ft_skill::sub_cooldown(int cooldown) noexcept`
- `void ft_skill::sub_modifier1(int mod) noexcept`
- `void ft_skill::sub_modifier2(int mod) noexcept`
- `void ft_skill::sub_modifier3(int mod) noexcept`
- `void ft_skill::sub_modifier4(int mod) noexcept`

### Game/game_skill.hpp

- `const char *get_error_str() const noexcept;`
- `int get_cooldown() const noexcept;`
- `int get_error() const noexcept;`
- `int get_id() const noexcept;`
- `int get_level() const noexcept;`
- `int get_modifier1() const noexcept;`
- `int get_modifier2() const noexcept;`
- `int get_modifier3() const noexcept;`
- `int get_modifier4() const noexcept;`
- `public: ft_skill() noexcept;`
- `static int lock_pair(const ft_skill &first, const ft_skill &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `virtual ~ft_skill() noexcept;`
- `void add_cooldown(int cooldown) noexcept;`
- `void add_modifier1(int mod) noexcept;`
- `void add_modifier2(int mod) noexcept;`
- `void add_modifier3(int mod) noexcept;`
- `void add_modifier4(int mod) noexcept;`
- `void set_cooldown(int cooldown) noexcept;`
- `void set_error(int err) const noexcept;`
- `void set_id(int id) noexcept;`
- `void set_level(int level) noexcept;`
- `void set_modifier1(int mod) noexcept;`
- `void set_modifier2(int mod) noexcept;`
- `void set_modifier3(int mod) noexcept;`
- `void set_modifier4(int mod) noexcept;`
- `void sub_cooldown(int cooldown) noexcept;`
- `void sub_modifier1(int mod) noexcept;`
- `void sub_modifier2(int mod) noexcept;`
- `void sub_modifier3(int mod) noexcept;`
- `void sub_modifier4(int mod) noexcept;`

### Game/game_state.cpp

- `const char *ft_game_state::get_error_str() const noexcept`
- `const ft_string *ft_game_state::get_variable(const ft_string &key) const noexcept`
- `ft_sharedptr<ft_game_hooks> ft_game_state::get_hooks() const noexcept`
- `ft_vector<ft_sharedptr<ft_character> > &ft_game_state::get_characters() noexcept`
- `ft_vector<ft_sharedptr<ft_world> > &ft_game_state::get_worlds() noexcept`
- `int ft_game_state::add_character(const ft_sharedptr<ft_character> &character) noexcept`
- `int ft_game_state::get_error() const noexcept`
- `int ft_game_state::lock_pair(const ft_game_state &first, const ft_game_state &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `void ft_game_state::clear_variables() noexcept`
- `void ft_game_state::dispatch_character_damaged(ft_character &character, int damage, uint8_t type) const noexcept`
- `void ft_game_state::dispatch_event_triggered(ft_world &world, ft_event &event) const noexcept`
- `void ft_game_state::dispatch_item_crafted(ft_character &character, ft_item &item) const noexcept`
- `void ft_game_state::remove_character(size_t index) noexcept`
- `void ft_game_state::remove_variable(const ft_string &key) noexcept`
- `void ft_game_state::reset_hooks() noexcept`
- `void ft_game_state::set_error(int error) const noexcept`
- `void ft_game_state::set_hooks(const ft_sharedptr<ft_game_hooks> &hooks) noexcept`
- `void ft_game_state::set_variable(const ft_string &key, const ft_string &value) noexcept`

### Game/game_upgrade.cpp

- `const char *ft_upgrade::get_error_str() const noexcept`
- `int ft_upgrade::get_error() const noexcept`
- `int ft_upgrade::get_id() const noexcept`
- `int ft_upgrade::get_modifier1() const noexcept`
- `int ft_upgrade::get_modifier2() const noexcept`
- `int ft_upgrade::get_modifier3() const noexcept`
- `int ft_upgrade::get_modifier4() const noexcept`
- `int ft_upgrade::lock_pair(const ft_upgrade &first, const ft_upgrade &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `static void game_upgrade_finalize_lock(ft_unique_lock<pt_mutex> &guard)`
- `uint16_t ft_upgrade::get_current_level() const noexcept`
- `uint16_t ft_upgrade::get_max_level() const noexcept`
- `void ft_upgrade::add_level(uint16_t level) noexcept`
- `void ft_upgrade::add_modifier1(int mod) noexcept`
- `void ft_upgrade::add_modifier2(int mod) noexcept`
- `void ft_upgrade::add_modifier3(int mod) noexcept`
- `void ft_upgrade::add_modifier4(int mod) noexcept`
- `void ft_upgrade::set_current_level(uint16_t level) noexcept`
- `void ft_upgrade::set_error(int err) const noexcept`
- `void ft_upgrade::set_id(int id) noexcept`
- `void ft_upgrade::set_max_level(uint16_t level) noexcept`
- `void ft_upgrade::set_modifier1(int mod) noexcept`
- `void ft_upgrade::set_modifier2(int mod) noexcept`
- `void ft_upgrade::set_modifier3(int mod) noexcept`
- `void ft_upgrade::set_modifier4(int mod) noexcept`
- `void ft_upgrade::sub_level(uint16_t level) noexcept`
- `void ft_upgrade::sub_modifier1(int mod) noexcept`
- `void ft_upgrade::sub_modifier2(int mod) noexcept`
- `void ft_upgrade::sub_modifier3(int mod) noexcept`
- `void ft_upgrade::sub_modifier4(int mod) noexcept`

### Game/game_upgrade.hpp

- `const char *get_error_str() const noexcept;`
- `int get_error() const noexcept;`
- `int get_id() const noexcept;`
- `int get_modifier1() const noexcept;`
- `int get_modifier2() const noexcept;`
- `int get_modifier3() const noexcept;`
- `int get_modifier4() const noexcept;`
- `public: ft_upgrade() noexcept;`
- `static int lock_pair(const ft_upgrade &first, const ft_upgrade &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `uint16_t get_current_level() const noexcept;`
- `uint16_t get_max_level() const noexcept;`
- `virtual ~ft_upgrade() noexcept;`
- `void add_level(uint16_t level) noexcept;`
- `void add_modifier1(int mod) noexcept;`
- `void add_modifier2(int mod) noexcept;`
- `void add_modifier3(int mod) noexcept;`
- `void add_modifier4(int mod) noexcept;`
- `void set_current_level(uint16_t level) noexcept;`
- `void set_error(int err) const noexcept;`
- `void set_id(int id) noexcept;`
- `void set_max_level(uint16_t level) noexcept;`
- `void set_modifier1(int mod) noexcept;`
- `void set_modifier2(int mod) noexcept;`
- `void set_modifier3(int mod) noexcept;`
- `void set_modifier4(int mod) noexcept;`
- `void sub_level(uint16_t level) noexcept;`
- `void sub_modifier1(int mod) noexcept;`
- `void sub_modifier2(int mod) noexcept;`
- `void sub_modifier3(int mod) noexcept;`
- `void sub_modifier4(int mod) noexcept;`

### Game/game_vendor_profile.cpp

- `const char *ft_vendor_profile::get_error_str() const noexcept`
- `double ft_vendor_profile::get_buy_markup() const noexcept`
- `double ft_vendor_profile::get_sell_multiplier() const noexcept`
- `double ft_vendor_profile::get_tax_rate() const noexcept`
- `int ft_vendor_profile::get_error() const noexcept`
- `int ft_vendor_profile::get_vendor_id() const noexcept`
- `int ft_vendor_profile::lock_pair(const ft_vendor_profile &first, const ft_vendor_profile &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `void ft_vendor_profile::record_operation_error_unlocked(int error_code)`
- `void ft_vendor_profile::set_buy_markup(double buy_markup) noexcept`
- `void ft_vendor_profile::set_error(int error_code) const noexcept`
- `void ft_vendor_profile::set_sell_multiplier(double sell_multiplier) noexcept`
- `void ft_vendor_profile::set_tax_rate(double tax_rate) noexcept`
- `void ft_vendor_profile::set_vendor_id(int vendor_id) noexcept`

### Game/game_world.cpp

- `bool ft_world::propagate_crafting_state_error() const noexcept`
- `bool ft_world::propagate_dialogue_state_error() const noexcept`
- `bool ft_world::propagate_economy_state_error() const noexcept`
- `bool ft_world::propagate_quest_state_error() const noexcept`
- `bool ft_world::propagate_region_state_error() const noexcept`
- `bool ft_world::propagate_registry_state_error() const noexcept`
- `bool ft_world::propagate_replay_state_error() const noexcept`
- `bool ft_world::propagate_scheduler_state_error() const noexcept`
- `bool ft_world::propagate_upgrade_state_error() const noexcept`
- `bool ft_world::propagate_vendor_profile_state_error() const noexcept`
- `const char *ft_world::get_error_str() const noexcept`
- `const ft_sharedptr<ft_crafting> &ft_world::get_crafting() const noexcept`
- `const ft_sharedptr<ft_dialogue_table> &ft_world::get_dialogue_table() const noexcept`
- `const ft_sharedptr<ft_economy_table> &ft_world::get_economy_table() const noexcept`
- `const ft_sharedptr<ft_event_scheduler> &ft_world::get_event_scheduler() const noexcept`
- `const ft_sharedptr<ft_quest> &ft_world::get_quest() const noexcept`
- `const ft_sharedptr<ft_upgrade> &ft_world::get_upgrade() const noexcept`
- `const ft_sharedptr<ft_vendor_profile> &ft_world::get_vendor_profile() const noexcept`
- `const ft_sharedptr<ft_world_region> &ft_world::get_world_region() const noexcept`
- `const ft_sharedptr<ft_world_registry> &ft_world::get_world_registry() const noexcept`
- `const ft_sharedptr<ft_world_replay_session> &ft_world::get_replay_session() const noexcept`
- `ft_sharedptr<ft_crafting> &ft_world::get_crafting() noexcept`
- `ft_sharedptr<ft_dialogue_table> &ft_world::get_dialogue_table() noexcept`
- `ft_sharedptr<ft_economy_table> &ft_world::get_economy_table() noexcept`
- `ft_sharedptr<ft_event_scheduler> &ft_world::get_event_scheduler() noexcept`
- `ft_sharedptr<ft_quest> &ft_world::get_quest() noexcept`
- `ft_sharedptr<ft_upgrade> &ft_world::get_upgrade() noexcept`
- `ft_sharedptr<ft_vendor_profile> &ft_world::get_vendor_profile() noexcept`
- `ft_sharedptr<ft_world_region> &ft_world::get_world_region() noexcept`
- `ft_sharedptr<ft_world_registry> &ft_world::get_world_registry() noexcept`
- `ft_sharedptr<ft_world_replay_session> &ft_world::get_replay_session() noexcept`
- `int deserialize_character(ft_character &character, json_group *group);`
- `int deserialize_equipment(ft_character &character, json_group *group);`
- `int deserialize_event_scheduler(ft_sharedptr<ft_event_scheduler> &scheduler, json_group *group);`
- `int deserialize_inventory(ft_inventory &inventory, json_group *group);`
- `int ft_world::get_error() const noexcept`
- `int ft_world::load_from_buffer(const char *buffer, ft_character &character, ft_inventory &inventory) noexcept`
- `int ft_world::load_from_file(const char *file_path, ft_character &character, ft_inventory &inventory) noexcept`
- `int ft_world::load_from_store(kv_store &store, const char *slot_key, ft_character &character, ft_inventory &inventory) noexcept`
- `int ft_world::plan_route(const ft_map3d &grid, size_t start_x, size_t start_y, size_t start_z, size_t goal_x, size_t goal_y, size_t goal_z, ft_vector<ft_path_step> &path) const noexcept`
- `int ft_world::restore_from_groups(json_group *groups, ft_character &character, ft_inventory &inventory) noexcept`
- `int ft_world::save_to_buffer(ft_string &out_buffer, const ft_character &character, const ft_inventory &inventory) const noexcept`
- `int ft_world::save_to_file(const char *file_path, const ft_character &character, const ft_inventory &inventory) const noexcept`
- `int ft_world::save_to_store(kv_store &store, const char *slot_key, const ft_character &character, const ft_inventory &inventory) const noexcept`
- `json_group *ft_world::build_snapshot_groups(const ft_character &character, const ft_inventory &inventory, int &error_code) const noexcept`
- `json_group *serialize_equipment(const ft_character &character);`
- `json_group *serialize_event_scheduler(const ft_sharedptr<ft_event_scheduler> &scheduler);`
- `json_group *serialize_inventory(const ft_inventory &inventory);`
- `static ft_function<void(ft_world&, ft_event&)> get_callback_by_id(int type_id) noexcept`
- `static ft_function<void(ft_world&, ft_event&)> get_callback_by_id(int type_id) noexcept;`
- `static void default_event_callback(ft_world &world, ft_event &event) noexcept`
- `static void default_event_callback(ft_world &world, ft_event &event) noexcept;`
- `void ft_world::schedule_event(const ft_sharedptr<ft_event> &event) noexcept`
- `void ft_world::set_error(int err) const noexcept`
- `void ft_world::update_events(ft_sharedptr<ft_world> &self, int ticks, const char *log_file_path, ft_string *log_buffer) noexcept`

### Game/game_world_region.cpp

- `const char *ft_world_region::get_error_str() const noexcept`
- `const ft_vector<int> &ft_world_region::get_region_ids() const noexcept`
- `ft_vector<int> &ft_world_region::get_region_ids() noexcept`
- `int ft_world_region::get_error() const noexcept`
- `int ft_world_region::get_world_id() const noexcept`
- `int ft_world_region::lock_pair(const ft_world_region &first, const ft_world_region &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `void ft_world_region::set_error(int error_code) const noexcept`
- `void ft_world_region::set_region_ids(const ft_vector<int> &region_ids) noexcept`
- `void ft_world_region::set_world_id(int world_id) noexcept`

### Game/game_world_registry.cpp

- `const char *ft_world_registry::get_error_str() const noexcept`
- `const ft_map<int, ft_region_definition> &ft_world_registry::get_regions() const noexcept`
- `const ft_map<int, ft_world_region> &ft_world_registry::get_world_regions() const noexcept`
- `ft_map<int, ft_region_definition> &ft_world_registry::get_regions() noexcept`
- `ft_map<int, ft_world_region> &ft_world_registry::get_world_regions() noexcept`
- `int ft_world_registry::fetch_region(int region_id, ft_region_definition &out_region) const noexcept`
- `int ft_world_registry::fetch_world(int world_id, ft_world_region &out_world) const noexcept`
- `int ft_world_registry::get_error() const noexcept`
- `int ft_world_registry::register_region(const ft_region_definition &region) noexcept`
- `int ft_world_registry::register_world(const ft_world_region &world_region) noexcept`
- `void ft_world_registry::copy_registry_unlocked(const ft_world_registry &other) noexcept`
- `void ft_world_registry::set_error(int error_code) const noexcept`
- `void ft_world_registry::set_regions(const ft_map<int, ft_region_definition> &regions) noexcept`
- `void ft_world_registry::set_world_regions(const ft_map<int, ft_world_region> &world_regions) noexcept`

### Game/game_world_registry.hpp

- `const char *get_error_str() const noexcept;`
- `const ft_map<int, ft_region_definition> &get_regions() const noexcept;`
- `const ft_map<int, ft_world_region> &get_world_regions() const noexcept;`
- `ft_map<int, ft_region_definition> &get_regions() noexcept;`
- `ft_map<int, ft_world_region> &get_world_regions() noexcept;`
- `int fetch_region(int region_id, ft_region_definition &out_region) const noexcept;`
- `int fetch_world(int world_id, ft_world_region &out_world) const noexcept;`
- `int get_error() const noexcept;`
- `int register_region(const ft_region_definition &region) noexcept;`
- `int register_world(const ft_world_region &world_region) noexcept;`
- `public: ft_world_registry() noexcept;`
- `virtual ~ft_world_registry() noexcept;`
- `void copy_registry_unlocked(const ft_world_registry &other) noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_regions(const ft_map<int, ft_region_definition> &regions) noexcept;`
- `void set_world_regions(const ft_map<int, ft_world_region> &world_regions) noexcept;`

### Game/game_world_replay.cpp

- `const char *ft_world_replay_session::get_error_str() const noexcept`
- `int ft_world_replay_session::capture_snapshot(ft_world &world, const ft_character &character, const ft_inventory &inventory) noexcept`
- `int ft_world_replay_session::export_snapshot(ft_string &out_snapshot) const noexcept`
- `int ft_world_replay_session::get_error() const noexcept`
- `int ft_world_replay_session::import_snapshot(const ft_string &snapshot_payload) noexcept`
- `int ft_world_replay_session::plan_route(ft_world &world, const ft_map3d &grid, size_t start_x, size_t start_y, size_t start_z, size_t goal_x, size_t goal_y, size_t goal_z, ft_vector<ft_path_step> &path) noexcept`
- `int ft_world_replay_session::replay_ticks(ft_sharedptr<ft_world> &world_ptr, ft_character &character, ft_inventory &inventory, int ticks, const char *log_file_path, ft_string *log_buffer) noexcept`
- `int ft_world_replay_session::restore_snapshot(ft_sharedptr<ft_world> &world_ptr, ft_character &character, ft_inventory &inventory) noexcept`
- `static int world_replay_restore_callbacks(ft_world &world, const ft_vector<ft_function<void(ft_world&, ft_event&)> > &callbacks) noexcept`
- `void ft_world_replay_session::clear_snapshot() noexcept`
- `void ft_world_replay_session::set_error(int error_code) const noexcept`

### Game/game_world_replay.hpp

- `const char *get_error_str() const noexcept;`
- `int capture_snapshot(ft_world &world, const ft_character &character, const ft_inventory &inventory) noexcept;`
- `int export_snapshot(ft_string &out_snapshot) const noexcept;`
- `int get_error() const noexcept;`
- `int import_snapshot(const ft_string &snapshot_payload) noexcept;`
- `int plan_route(ft_world &world, const ft_map3d &grid, size_t start_x, size_t start_y, size_t start_z, size_t goal_x, size_t goal_y, size_t goal_z, ft_vector<ft_path_step> &path) noexcept;`
- `int replay_ticks(ft_sharedptr<ft_world> &world_ptr, ft_character &character, ft_inventory &inventory, int ticks, const char *log_file_path = ft_nullptr, ft_string *log_buffer = ft_nullptr) noexcept;`
- `int restore_snapshot(ft_sharedptr<ft_world> &world_ptr, ft_character &character, ft_inventory &inventory) noexcept;`
- `public: ft_world_replay_session() noexcept;`
- `void clear_snapshot() noexcept;`
- `void set_error(int error_code) const noexcept;`

### Geometry/geometry.hpp

- `bool intersect_aabb(const aabb &first, const aabb &second);`
- `bool intersect_circle(const circle &first, const circle &second);`
- `bool intersect_sphere(const sphere &first, const sphere &second);`

### Geometry/geometry_aabb.cpp

- `double aabb::get_maximum_x() const`
- `double aabb::get_maximum_y() const`
- `double aabb::get_minimum_x() const`
- `double aabb::get_minimum_y() const`
- `ft_operation_error_stack *aabb::get_operation_error_stack_for_validation() const noexcept`
- `int aabb::lock_pair(const aabb &other, const aabb *&lower, const aabb *&upper) const`
- `int aabb::set_bounds(double minimum_x, double minimum_y, double maximum_x, double maximum_y)`
- `int aabb::set_maximum(double maximum_x, double maximum_y)`
- `int aabb::set_maximum_x(double maximum_x)`
- `int aabb::set_maximum_y(double maximum_y)`
- `int aabb::set_minimum(double minimum_x, double minimum_y)`
- `int aabb::set_minimum_x(double minimum_x)`
- `int aabb::set_minimum_y(double minimum_y)`
- `pt_recursive_mutex *aabb::get_mutex_for_validation() const`
- `static int aabb_lock_mutex(const pt_recursive_mutex &mutex)`
- `static int aabb_unlock_mutex(const pt_recursive_mutex &mutex)`
- `void aabb::record_operation_error(int error_code) const noexcept`
- `void aabb::unlock_pair(const aabb *lower, const aabb *upper)`

### Geometry/geometry_aabb.hpp

- `double get_maximum_x() const;`
- `double get_maximum_y() const;`
- `double get_minimum_x() const;`
- `double get_minimum_y() const;`
- `ft_operation_error_stack *get_operation_error_stack_for_validation() const noexcept;`
- `int lock_pair(const aabb &other, const aabb *&lower, const aabb *&upper) const;`
- `int set_bounds(double minimum_x, double minimum_y, double maximum_x, double maximum_y);`
- `int set_maximum(double maximum_x, double maximum_y);`
- `int set_maximum_x(double maximum_x);`
- `int set_maximum_y(double maximum_y);`
- `int set_minimum(double minimum_x, double minimum_y);`
- `int set_minimum_x(double minimum_x);`
- `int set_minimum_y(double minimum_y);`
- `pt_recursive_mutex *get_mutex_for_validation() const;`
- `public: aabb();`
- `static void unlock_pair(const aabb *lower, const aabb *upper);`
- `void record_operation_error(int error_code) const noexcept;`

### Geometry/geometry_circle.cpp

- `bool intersect_circle(const circle &first, const circle &second)`
- `double circle::get_center_x() const`
- `double circle::get_center_y() const`
- `double circle::get_radius() const`
- `ft_operation_error_stack *circle::get_operation_error_stack_for_validation() const noexcept`
- `int circle::lock_pair(const circle &other, const circle *&lower, const circle *&upper) const`
- `int circle::set_center(double center_x, double center_y)`
- `int circle::set_center_x(double center_x)`
- `int circle::set_center_y(double center_y)`
- `int circle::set_radius(double radius)`
- `pt_recursive_mutex *circle::get_mutex_for_validation() const`
- `static int circle_lock_mutex(const pt_recursive_mutex &mutex)`
- `static int circle_unlock_mutex(const pt_recursive_mutex &mutex)`
- `static pt_recursive_mutex *circle_mutex_for(const circle &value)`
- `void circle::record_operation_error(int error_code) const noexcept`
- `void circle::unlock_pair(const circle *lower, const circle *upper)`

### Geometry/geometry_circle.hpp

- `double get_center_x() const;`
- `double get_center_y() const;`
- `double get_radius() const;`
- `ft_operation_error_stack *get_operation_error_stack_for_validation() const noexcept;`
- `int lock_pair(const circle &other, const circle *&lower, const circle *&upper) const;`
- `int set_center(double center_x, double center_y);`
- `int set_center_x(double center_x);`
- `int set_center_y(double center_y);`
- `int set_radius(double radius);`
- `pt_recursive_mutex *get_mutex_for_validation() const;`
- `public: circle();`
- `static void unlock_pair(const circle *lower, const circle *upper);`
- `void record_operation_error(int error_code) const noexcept;`

### Geometry/geometry_collision.cpp

- `bool intersect_circle(const circle &first, const circle &second)`
- `bool intersect_sphere(const sphere &first, const sphere &second)`

### Geometry/geometry_lock_tracker.cpp

- `int geometry_lock_tracker_lock_pair(const void *first_object, const void *second_object, pt_recursive_mutex &first_mutex, pt_recursive_mutex &second_mutex)`
- `static bool geometry_lock_tracker_register_wait(pt_thread_id_type thread_identifier, const void *owned_object, const void *requested_object, bool &out_cycle_detected)`
- `static void geometry_lock_tracker_clear_wait(pt_thread_id_type thread_identifier)`
- `static void geometry_lock_tracker_sleep_backoff()`

### Geometry/geometry_sphere.cpp

- `double sphere::get_center_x() const`
- `double sphere::get_center_y() const`
- `double sphere::get_center_z() const`
- `double sphere::get_radius() const`
- `ft_operation_error_stack *sphere::get_operation_error_stack_for_validation() const noexcept`
- `int sphere::lock_pair(const sphere &other, const sphere *&lower, const sphere *&upper) const`
- `int sphere::set_center(double center_x, double center_y, double center_z)`
- `int sphere::set_center_x(double center_x)`
- `int sphere::set_center_y(double center_y)`
- `int sphere::set_center_z(double center_z)`
- `int sphere::set_radius(double radius)`
- `pt_recursive_mutex *sphere::get_mutex_for_validation() const`
- `static int sphere_unlock_mutex(const pt_recursive_mutex &mutex)`
- `void sphere::record_operation_error(int error_code) const noexcept`
- `void sphere::unlock_pair(const sphere *lower, const sphere *upper)`

### Geometry/geometry_sphere.hpp

- `double get_center_x() const;`
- `double get_center_y() const;`
- `double get_center_z() const;`
- `double get_radius() const;`
- `ft_operation_error_stack *get_operation_error_stack_for_validation() const noexcept;`
- `int lock_pair(const sphere &other, const sphere *&lower, const sphere *&upper) const;`
- `int set_center(double center_x, double center_y, double center_z);`
- `int set_center_x(double center_x);`
- `int set_center_y(double center_y);`
- `int set_center_z(double center_z);`
- `int set_radius(double radius);`
- `pt_recursive_mutex *get_mutex_for_validation() const;`
- `public: sphere();`
- `static void unlock_pair(const sphere *lower, const sphere *upper);`
- `void record_operation_error(int error_code) const noexcept;`

### GetNextLine/get_next_line.cpp

- `char *get_next_line(int fd, std::size_t buffer_size)`
- `char* ft_strjoin_gnl(char* string_one, char* string_two)`
- `int gnl_clear_stream(int fd)`
- `static bool stream_map_has_new_error(ft_unordered_map<int, gnl_stream*> &map, int previous_error, int *current_error)`
- `static char* allocate_new_string(char* string_one, char* string_two, int *allocation_error)`
- `static char* fetch_line(char* readed_string, int *line_error)`
- `static char* leftovers(char* readed_string, bool *buffer_was_freed, int *leftover_error)`
- `static char* malloc_gnl(char* readed_string, size_t length, int *allocation_error)`
- `static char* read_stream(gnl_stream *stream, char* readed_string, std::size_t buffer_size, int *read_error)`
- `static gnl_stream *gnl_acquire_stream(int fd, int *stream_error)`
- `static void *(*g_gnl_leftover_alloc_hook)(ft_size_t size) = cma_malloc;`
- `void gnl_reset_all_streams(void)`
- `void gnl_reset_leftover_alloc_hook(void)`
- `void gnl_set_leftover_alloc_hook(void *(*hook)(ft_size_t size))`

### GetNextLine/get_next_line.hpp

- `char *get_next_line(int fd, std::size_t buffer_size);`
- `int ft_open_and_read_file(const char *path, ft_vector<ft_string> &lines, std::size_t buffer_size);`
- `int ft_read_file_lines(int fd, ft_vector<ft_string> &lines, std::size_t buffer_size);`
- `int gnl_clear_stream(int fd);`
- `void gnl_reset_all_streams(void);`
- `void gnl_reset_leftover_alloc_hook(void);`
- `void gnl_set_leftover_alloc_hook(void *(*hook)(ft_size_t size));`

### GetNextLine/get_next_line_stream_helpers.cpp

- `int ft_open_and_read_file(const char *path, ft_vector<ft_string> &lines, std::size_t buffer_size)`
- `int ft_read_file_lines(int fd, ft_vector<ft_string> &lines, std::size_t buffer_size)`

### GetNextLine/gnl_stream.cpp

- `const char *gnl_stream::get_error_str() const noexcept`
- `int gnl_stream::get_error() const noexcept`
- `int gnl_stream::init_from_callback(ssize_t (*callback)(void *user_data, char *buffer, size_t max_size) noexcept, void *user_data) noexcept`
- `int gnl_stream::init_from_fd(int file_descriptor) noexcept`
- `int gnl_stream::init_from_file(FILE *file_handle, bool close_on_reset) noexcept`
- `int gnl_stream::lock_self(ft_unique_lock<pt_mutex> &guard) const noexcept`
- `ssize_t gnl_stream::read(char *buffer, size_t max_size) noexcept`
- `ssize_t gnl_stream::read_from_descriptor(int file_descriptor, char *buffer, size_t max_size) const noexcept`
- `ssize_t gnl_stream::read_from_file(FILE *file_handle, char *buffer, size_t max_size) const noexcept`
- `static ssize_t gnl_stream_default_file_read(void *user_data, char *buffer, size_t max_size, int *error_code) noexcept`
- `void gnl_stream::reset() noexcept`
- `void gnl_stream::set_error(int error_code) const noexcept`
- `void gnl_stream::set_error_unlocked(int error_code) const noexcept`

### GetNextLine/gnl_stream.hpp

- `const char *get_error_str() const noexcept;`
- `int get_error() const noexcept;`
- `int init_from_callback(ssize_t (*callback)(void *user_data, char *buffer, size_t max_size) noexcept, void *user_data) noexcept;`
- `int init_from_fd(int file_descriptor) noexcept;`
- `int init_from_file(FILE *file_handle, bool close_on_reset) noexcept;`
- `int lock_self(ft_unique_lock<pt_mutex> &guard) const noexcept;`
- `private: typedef ssize_t (*gnl_stream_read_callback)(void *user_data, char *buffer, size_t max_size) noexcept;`
- `public: gnl_stream() noexcept;`
- `ssize_t read(char *buffer, size_t max_size) noexcept;`
- `ssize_t read_from_descriptor(int file_descriptor, char *buffer, size_t max_size) const noexcept;`
- `ssize_t read_from_file(FILE *file_handle, char *buffer, size_t max_size) const noexcept;`
- `void reset() noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_error_unlocked(int error_code) const noexcept;`

### HTML/html_attr_thread_safety.cpp

- `bool html_attr_is_thread_safe_enabled(const html_attr *attribute)`
- `int html_attr_lock(const html_attr *attribute, bool *lock_acquired)`
- `void html_attr_teardown_thread_safety(html_attr *attribute)`
- `void html_attr_unlock(const html_attr *attribute, bool lock_acquired)`

### HTML/html_cleanup.cpp

- `void html_free_nodes(html_node *nodeList)`
- `void html_remove_nodes_by_attr(html_node **nodeList, const char *key, const char *value)`
- `void html_remove_nodes_by_tag(html_node **nodeList, const char *tagName)`
- `void html_remove_nodes_by_text(html_node **nodeList, const char *textContent)`

### HTML/html_document.cpp

- `bool html_document::is_thread_safe_enabled() const noexcept`
- `bool html_document::thread_guard::lock_acquired() const noexcept`
- `char *html_document::write_to_string() const noexcept`
- `const char *html_document::get_error_str() const noexcept`
- `ft_operation_error_stack *html_document::operation_error_stack_handle() const noexcept`
- `html_attr *html_document::create_attr(const char *key, const char *value) noexcept`
- `html_node *html_document::create_node(const char *tag_name, const char *text_content) noexcept`
- `html_node *html_document::find_by_attr(const char *key, const char *value) const noexcept`
- `html_node *html_document::find_by_selector(const char *selector) const noexcept`
- `html_node *html_document::find_by_tag(const char *tag_name) const noexcept`
- `html_node *html_document::find_by_text(const char *text_content) const noexcept`
- `html_node *html_document::get_root() const noexcept`
- `int html_document::get_error() const noexcept`
- `int html_document::lock(bool *lock_acquired) const noexcept`
- `int html_document::prepare_thread_safety() noexcept`
- `int html_document::thread_guard::get_status() const noexcept`
- `int html_document::write_to_file(const char *file_path) const noexcept`
- `pt_mutex *html_document::get_mutex_for_validation() const noexcept`
- `size_t html_document::count_nodes_by_tag(const char *tag_name) const noexcept`
- `void html_document::add_attr(html_node *target_node, html_attr *new_attribute) noexcept`
- `void html_document::add_child(html_node *parent_node, html_node *child_node) noexcept`
- `void html_document::append_node(html_node *new_node) noexcept`
- `void html_document::clear() noexcept`
- `void html_document::record_operation_error(int error_code) const noexcept`
- `void html_document::remove_attr(html_node *target_node, const char *key) noexcept`
- `void html_document::remove_nodes_by_attr(const char *key, const char *value) noexcept`
- `void html_document::remove_nodes_by_tag(const char *tag_name) noexcept`
- `void html_document::remove_nodes_by_text(const char *text_content) noexcept`
- `void html_document::set_error(int error_code) const noexcept`
- `void html_document::teardown_thread_safety() noexcept`
- `void html_document::unlock(bool lock_acquired) const noexcept`

### HTML/html_node.cpp

- `html_attr *html_create_attr(const char *key, const char *value)`
- `void html_add_attr(html_node *targetNode, html_attr *newAttribute)`
- `void html_add_child(html_node *parentNode, html_node *childNode)`
- `void html_append_node(html_node **headNode, html_node *newNode)`
- `void html_remove_attr(html_node *targetNode, const char *key)`

### HTML/html_node_thread_safety.cpp

- `bool html_node_is_thread_safe_enabled(const html_node *node)`
- `int html_node_lock(const html_node *node, bool *lock_acquired)`
- `void html_node_teardown_thread_safety(html_node *node)`
- `void html_node_unlock(const html_node *node, bool lock_acquired)`

### HTML/html_search.cpp

- `html_node *html_find_by_attr(html_node *nodeList, const char *key, const char *value)`
- `html_node *html_find_by_selector(html_node *node_list, const char *selector)`
- `html_node *html_find_by_tag(html_node *nodeList, const char *tagName)`
- `html_node *html_find_by_text(html_node *nodeList, const char *textContent)`
- `html_node *html_query_selector(html_node *node_list, const char *selector)`
- `size_t html_count_nodes_by_tag(html_node *nodeList, const char *tagName)`

### HTML/html_string_writer.cpp

- `char *html_write_to_string(html_node *nodeList)`
- `static char *html_attrs_to_string(html_attr *attribute, int *error_code)`
- `static char *html_escape_attribute_value(const char *value, int *error_code)`
- `static char *html_indent(int indent, int *error_code)`
- `static char *html_node_to_string(html_node *node, int indent, int *error_code)`

### HTML/html_writer.cpp

- `int html_write_to_file(const char *file_path, html_node *node_list)`
- `static void html_write_node(int fd, html_node *htmlNode, int indent)`

### HTML/parser.hpp

- `bool html_attr_is_thread_safe_enabled(const html_attr *attribute);`
- `bool html_node_is_thread_safe_enabled(const html_node *node);`
- `char *html_write_to_string(html_node *nodeList);`
- `html_attr *html_create_attr(const char *key, const char *value);`
- `html_node *html_create_node(const char *tagName, const char *textContent);`
- `html_node *html_find_by_attr(html_node *nodeList, const char *key, const char *value);`
- `html_node *html_find_by_selector(html_node *node_list, const char *selector);`
- `html_node *html_find_by_tag(html_node *nodeList, const char *tagName);`
- `html_node *html_find_by_text(html_node *nodeList, const char *textContent);`
- `html_node *html_query_selector(html_node *node_list, const char *selector);`
- `int html_attr_lock(const html_attr *attribute, bool *lock_acquired);`
- `int html_attr_prepare_thread_safety(html_attr *attribute);`
- `int html_node_lock(const html_node *node, bool *lock_acquired);`
- `int html_node_prepare_thread_safety(html_node *node);`
- `int html_write_to_file(const char *filePath, html_node *nodeList);`
- `size_t html_count_nodes_by_tag(html_node *nodeList, const char *tagName);`
- `void html_add_attr(html_node *targetNode, html_attr *newAttribute);`
- `void html_add_child(html_node *parentNode, html_node *childNode);`
- `void html_append_node(html_node **headNode, html_node *newNode);`
- `void html_attr_teardown_thread_safety(html_attr *attribute);`
- `void html_attr_unlock(const html_attr *attribute, bool lock_acquired);`
- `void html_free_nodes(html_node *nodeList);`
- `void html_node_teardown_thread_safety(html_node *node);`
- `void html_node_unlock(const html_node *node, bool lock_acquired);`
- `void html_remove_attr(html_node *targetNode, const char *key);`
- `void html_remove_nodes_by_attr(html_node **nodeList, const char *key, const char *value);`
- `void html_remove_nodes_by_tag(html_node **nodeList, const char *tagName);`
- `void html_remove_nodes_by_text(html_node **nodeList, const char *textContent);`

### JSon/document.hpp

- `char *write_to_string() const noexcept;`
- `char *write_to_string_unlocked() const noexcept;`
- `const char *get_error_str() const noexcept;`
- `const char *get_value_by_pointer(const char *pointer) const noexcept;`
- `int get_error() const noexcept;`
- `int lock_self(ft_unique_lock<pt_mutex> &guard) const noexcept;`
- `int read_from_backend(ft_document_source &source) noexcept;`
- `int read_from_file(const char *file_path) noexcept;`
- `int read_from_file_streaming(const char *file_path, size_t buffer_capacity) noexcept;`
- `int read_from_string(const char *content) noexcept;`
- `int write_to_backend(ft_document_sink &sink) const noexcept;`
- `int write_to_file(const char *file_path) const noexcept;`
- `json_group *create_group(const char *name) noexcept;`
- `json_group *find_group(const char *name) const noexcept;`
- `json_group *get_groups() const noexcept;`
- `json_item *create_item(const char *key, const bool value) noexcept;`
- `json_item *create_item(const char *key, const char *value) noexcept;`
- `json_item *create_item(const char *key, const ft_big_number &value) noexcept;`
- `json_item *create_item(const char *key, const int value) noexcept;`
- `json_item *find_item(json_group *group, const char *key) const noexcept;`
- `json_item *find_item_by_pointer(const char *pointer) const noexcept;`
- `json_item *find_item_by_pointer_unlocked(const char *pointer) const noexcept;`
- `public: json_document() noexcept;`
- `void add_item(json_group *group, json_item *item) noexcept;`
- `void append_group(json_group *group) noexcept;`
- `void clear() noexcept;`
- `void clear_unlocked() noexcept;`
- `void remove_group(const char *name) noexcept;`
- `void remove_item(json_group *group, const char *key) noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void set_error_unlocked(int error_code) const noexcept;`
- `void set_manual_error(int error_code) noexcept;`
- `void update_item(json_group *group, const char *key, const bool value) noexcept;`
- `void update_item(json_group *group, const char *key, const char *value) noexcept;`
- `void update_item(json_group *group, const char *key, const ft_big_number &value) noexcept;`
- `void update_item(json_group *group, const char *key, const int value) noexcept;`

### JSon/json.hpp

- `char *json_document_write_to_string(const json_document &document);`
- `char *json_write_to_string(json_group *groups);`
- `const char *json_group_get_error_str(const json_group *group);`
- `const char *json_item_get_error_str(const json_item *item);`
- `const char *json_schema_field_get_error_str(const json_schema_field *field);`
- `const char *json_schema_get_error_str(const json_schema *schema);`
- `int json_document_read_from_backend(json_document &document, ft_document_source &source);`
- `int json_document_write_to_backend(ft_document_sink &sink, const json_document &document);`
- `int json_document_write_to_file(const char *file_path, const json_document &document);`
- `int json_group_enable_thread_safety(json_group *group);`
- `int json_group_get_error(const json_group *group);`
- `int json_group_list_lock(ft_unique_lock<pt_mutex> &guard);`
- `int json_group_lock(json_group *group, ft_unique_lock<pt_mutex> &guard);`
- `int json_item_enable_thread_safety(json_item *item);`
- `int json_item_get_error(const json_item *item);`
- `int json_item_lock(json_item *item, ft_unique_lock<pt_mutex> &guard);`
- `int json_schema_enable_thread_safety(json_schema *schema);`
- `int json_schema_field_enable_thread_safety(json_schema_field *field);`
- `int json_schema_field_get_error(const json_schema_field *field);`
- `int json_schema_field_lock(json_schema_field *field, ft_unique_lock<pt_mutex> &guard);`
- `int json_schema_get_error(const json_schema *schema);`
- `int json_schema_lock(json_schema *schema, ft_unique_lock<pt_mutex> &guard);`
- `int json_write_to_backend(ft_document_sink &sink, json_group *groups);`
- `int json_write_to_file(const char *filename, json_group *groups);`
- `json_group *json_create_json_group(const char *name);`
- `json_group *json_find_group(json_group *head, const char *name);`
- `json_group *json_read_from_backend(ft_document_source &source);`
- `json_group *json_read_from_file(const char *filename);`
- `json_group *json_read_from_file_stream(FILE *file, size_t buffer_capacity);`
- `json_group *json_read_from_stream(json_stream_read_callback callback, void *user_data, size_t buffer_capacity);`
- `json_group *json_read_from_string(const char *content);`
- `json_item *json_create_item(const char *key, const bool value);`
- `json_item *json_create_item(const char *key, const char *value);`
- `json_item *json_create_item(const char *key, const ft_big_number &value);`
- `json_item *json_create_item(const char *key, const int value);`
- `json_item *json_find_item(json_group *group, const char *key);`
- `void json_add_item_to_group(json_group *group, json_item *item);`
- `void json_append_group(json_group **head, json_group *new_group);`
- `void json_free_groups(json_group *group);`
- `void json_free_items(json_item *item);`
- `void json_group_list_finalize_lock(ft_unique_lock<pt_mutex> &guard);`
- `void json_group_set_error(json_group *group, int error_code);`
- `void json_group_set_error_unlocked(json_group *group, int error_code);`
- `void json_item_refresh_numeric_state(json_item *item);`
- `void json_item_set_error(json_item *item, int error_code);`
- `void json_item_set_error_unlocked(json_item *item, int error_code);`
- `void json_remove_group(json_group **head, const char *name);`
- `void json_remove_item(json_group *group, const char *key);`
- `void json_schema_field_set_error(json_schema_field *field, int error_code);`
- `void json_schema_field_set_error_unlocked(json_schema_field *field, int error_code);`
- `void json_schema_set_error(json_schema *schema, int error_code);`
- `void json_schema_set_error_unlocked(json_schema *schema, int error_code);`
- `void json_update_item(json_group *group, const char *key, const bool value);`
- `void json_update_item(json_group *group, const char *key, const char *value);`
- `void json_update_item(json_group *group, const char *key, const ft_big_number &value);`
- `void json_update_item(json_group *group, const char *key, const int value);`

### JSon/json_create_item.cpp

- `json_item* json_create_item(const char *key, const bool value)`
- `json_item* json_create_item(const char *key, const ft_big_number &value)`
- `json_item* json_create_item(const char *key, const int value)`

### JSon/json_document.cpp

- `char *json_document::write_to_string() const noexcept`
- `char *json_document::write_to_string_unlocked() const noexcept`
- `const char *json_document::get_error_str() const noexcept`
- `const char *json_document::get_value_by_pointer(const char *pointer) const noexcept`
- `int json_document::get_error() const noexcept`
- `int json_document::lock_self(ft_unique_lock<pt_mutex> &guard) const noexcept`
- `int json_document::read_from_backend(ft_document_source &source) noexcept`
- `int json_document::read_from_file(const char *file_path) noexcept`
- `int json_document::read_from_file_streaming(const char *file_path, size_t buffer_capacity) noexcept`
- `int json_document::read_from_string(const char *content) noexcept`
- `int json_document::write_to_backend(ft_document_sink &sink) const noexcept`
- `int json_document::write_to_file(const char *file_path) const noexcept`
- `json_group *json_document::create_group(const char *name) noexcept`
- `json_group *json_document::find_group(const char *name) const noexcept`
- `json_group *json_document::get_groups() const noexcept`
- `json_item *json_document::create_item(const char *key, const bool value) noexcept`
- `json_item *json_document::create_item(const char *key, const char *value) noexcept`
- `json_item *json_document::create_item(const char *key, const ft_big_number &value) noexcept`
- `json_item *json_document::create_item(const char *key, const int value) noexcept`
- `json_item *json_document::find_item(json_group *group, const char *key) const noexcept`
- `json_item *json_document::find_item_by_pointer(const char *pointer) const noexcept`
- `json_item *json_document::find_item_by_pointer_unlocked(const char *pointer) const noexcept`
- `static void json_document_finalize_guard(ft_unique_lock<pt_mutex> &guard) noexcept`
- `void json_document::add_item(json_group *group, json_item *item) noexcept`
- `void json_document::append_group(json_group *group) noexcept`
- `void json_document::clear() noexcept`
- `void json_document::clear_unlocked() noexcept`
- `void json_document::remove_group(const char *name) noexcept`
- `void json_document::remove_item(json_group *group, const char *key) noexcept`
- `void json_document::set_error(int error_code) const noexcept`
- `void json_document::set_error_unlocked(int error_code) const noexcept`
- `void json_document::set_manual_error(int error_code) noexcept`
- `void json_document::update_item(json_group *group, const char *key, const bool value) noexcept`
- `void json_document::update_item(json_group *group, const char *key, const char *value) noexcept`
- `void json_document::update_item(json_group *group, const char *key, const ft_big_number &value) noexcept`
- `void json_document::update_item(json_group *group, const char *key, const int value) noexcept`

### JSon/json_dom_bridge.cpp

- `int json_document_from_dom(const ft_dom_document &dom, json_document &document) noexcept`
- `int json_document_to_dom(const json_document &document, ft_dom_document &dom) noexcept`
- `static int json_dom_append_group(const json_group *group, ft_dom_node *root_node) noexcept`
- `static int json_dom_append_item(const json_item *item, ft_dom_node *group_node) noexcept`
- `static int json_dom_apply_group(ft_dom_node *group_node, json_document &document) noexcept`
- `static int json_dom_apply_item(ft_dom_node *item_node, json_group *group, json_document &document) noexcept`

### JSon/json_dom_bridge.hpp

- `int json_document_from_dom(const ft_dom_document &dom, json_document &document) noexcept;`

### JSon/json_parsing.cpp

- `json_group* json_create_json_group(const char *name)`
- `static bool json_string_exceeds_signed_long_long(const char *value)`
- `void json_add_item_to_group(json_group *group, json_item *item)`
- `void json_append_group(json_group **head, json_group *new_group)`
- `void json_free_groups(json_group *group)`
- `void json_free_items(json_item *item)`
- `void json_item_refresh_numeric_state(json_item *item)`

### JSon/json_reader.cpp

- `int json_document_read_from_backend(json_document &document, ft_document_source &source)`
- `json_group *json_read_from_backend(ft_document_source &source)`
- `json_group *json_read_from_file(const char *filename)`
- `json_group *json_read_from_string(const char *content)`
- `static char *json_read_file_content(const char *filename)`
- `static char *parse_number(const char *json_string, size_t &index)`
- `static char *parse_string(const char *json_string, size_t &index)`
- `static char *parse_value(const char *json_string, size_t &index)`
- `static int json_reader_append_escape(const char *json_string, size_t length, size_t &index, char **buffer_ptr, size_t &capacity, size_t &out_length) noexcept`
- `static int json_reader_append_utf8(char **buffer_ptr, size_t &capacity, size_t &length, unsigned int code_point) noexcept`
- `static int json_reader_ensure_capacity(char **buffer_ptr, size_t &capacity, size_t required) noexcept`
- `static int json_reader_hex_value(char character, unsigned int &value) noexcept`
- `static int json_reader_parse_code_unit(const char *json_string, size_t length, size_t &index, unsigned int &code_unit) noexcept`
- `static json_item *parse_items(const char *json_string, size_t &index)`
- `static void json_reader_set_io_error(void)`

### JSon/json_schema.cpp

- `bool json_validate_schema(json_group *group, const json_schema &schema)`
- `static bool json_is_bool(const char *string)`

### JSon/json_schema.hpp

- `bool json_validate_schema(json_group *group, const json_schema &schema);`

### JSon/json_schema_evolution.cpp

- `int json_apply_schema_migrations(json_document &document, const ft_string &schema_name, int current_version, int target_version) noexcept`
- `int json_get_latest_schema_version(const ft_string &schema_name, int *out_version) noexcept`
- `int json_register_schema_migration(const ft_string &schema_name, int from_version, int to_version, const ft_function<int(json_document &)> &callback) noexcept`
- `static bool json_schema_validate_identifier(const ft_string &schema_name) noexcept`
- `static ft_map<ft_string, ft_vector<json_schema_migration_step> > &json_schema_registry()`
- `static pt_mutex &json_schema_registry_mutex()`
- `static void json_schema_unlock(ft_unique_lock<pt_mutex> &guard) noexcept`

### JSon/json_schema_evolution.hpp

- `int json_apply_schema_migrations(json_document &document, const ft_string &schema_name, int current_version, int target_version) noexcept;`
- `int json_get_latest_schema_version(const ft_string &schema_name, int *out_version) noexcept;`
- `int json_register_schema_migration(const ft_string &schema_name, int from_version, int to_version, const ft_function<int(json_document &)> &callback) noexcept;`

### JSon/json_stream_reader.cpp

- `int json_stream_read_from_file_events(FILE *file, size_t buffer_capacity, json_stream_event_callback callback, void *user_data)`
- `int json_stream_read_from_stream_events(json_stream_read_callback callback, void *user_data, size_t buffer_capacity, json_stream_event_callback event_callback, void *event_user_data)`
- `int json_stream_reader_init_callback(json_stream_reader *reader, json_stream_read_callback callback, void *user_data, size_t buffer_capacity)`
- `int json_stream_reader_init_file(json_stream_reader *reader, FILE *file, size_t buffer_capacity)`
- `int json_stream_reader_traverse(json_stream_reader *reader, json_stream_event_callback callback, void *user_data)`
- `json_group *json_read_from_file_stream(FILE *file, size_t buffer_capacity)`
- `json_group *json_read_from_stream(json_stream_read_callback callback, void *user_data, size_t buffer_capacity)`
- `json_group *json_stream_reader_parse(json_stream_reader *reader)`
- `static char *json_stream_parse_number(json_stream_reader *reader)`
- `static char *json_stream_parse_string(json_stream_reader *reader)`
- `static char *json_stream_parse_value(json_stream_reader *reader)`
- `static int json_stream_append_escape(json_stream_reader *reader, char **buffer, size_t *capacity, size_t *length)`
- `static int json_stream_append_utf8(char **buffer, size_t *capacity, size_t *length, unsigned int code_point) noexcept`
- `static int json_stream_dispatch_event(json_stream_event_callback callback, void *user_data, json_stream_event_type type, char *string_value, bool bool_value)`
- `static int json_stream_ensure_capacity(char **buffer, size_t *capacity, size_t minimum)`
- `static int json_stream_hex_value(char character, unsigned int &value) noexcept`
- `static int json_stream_match_literal(json_stream_reader *reader, const char *literal)`
- `static int json_stream_parse_code_unit(json_stream_reader *reader, unsigned int &code_unit)`
- `static int json_stream_read_array(json_stream_reader *reader, json_stream_event_callback callback, void *user_data)`
- `static int json_stream_read_object(json_stream_reader *reader, json_stream_event_callback callback, void *user_data)`
- `static int json_stream_read_value(json_stream_reader *reader, json_stream_event_callback callback, void *user_data)`
- `static int json_stream_read_value(json_stream_reader *reader, json_stream_event_callback callback, void *user_data);`
- `static int json_stream_reader_consume(json_stream_reader *reader, char *out_char)`
- `static int json_stream_reader_expect(json_stream_reader *reader, char expected_char)`
- `static int json_stream_reader_fill(json_stream_reader *reader)`
- `static int json_stream_reader_peek(json_stream_reader *reader, char *out_char)`
- `static int json_stream_skip_whitespace(json_stream_reader *reader)`
- `static json_item *json_stream_parse_items(json_stream_reader *reader)`
- `static size_t json_stream_reader_file_callback(void *user_data, char *buffer, size_t max_size)`
- `void json_stream_reader_destroy(json_stream_reader *reader)`

### JSon/json_stream_reader.hpp

- `const char *json_stream_reader_get_error_str(const json_stream_reader *reader);`
- `int json_stream_read_from_file_events(FILE *file, size_t buffer_capacity, json_stream_event_callback callback, void *user_data);`
- `int json_stream_read_from_stream_events(json_stream_read_callback callback, void *user_data, size_t buffer_capacity, json_stream_event_callback event_callback, void *event_user_data);`
- `int json_stream_reader_enable_thread_safety(json_stream_reader *reader);`
- `int json_stream_reader_get_error(const json_stream_reader *reader);`
- `int json_stream_reader_init_callback(json_stream_reader *reader, json_stream_read_callback callback, void *user_data, size_t buffer_capacity);`
- `int json_stream_reader_init_file(json_stream_reader *reader, FILE *file, size_t buffer_capacity);`
- `int json_stream_reader_lock(json_stream_reader *reader, ft_unique_lock<pt_mutex> &guard);`
- `int json_stream_reader_traverse(json_stream_reader *reader, json_stream_event_callback callback, void *user_data);`
- `json_group *json_read_from_file_stream(FILE *file, size_t buffer_capacity);`
- `json_group *json_read_from_stream(json_stream_read_callback callback, void *user_data, size_t buffer_capacity);`
- `json_group *json_stream_reader_parse(json_stream_reader *reader);`
- `void json_stream_reader_destroy(json_stream_reader *reader);`
- `void json_stream_reader_finalize_lock(json_stream_reader *reader, ft_unique_lock<pt_mutex> &guard);`
- `void json_stream_reader_set_error(json_stream_reader *reader, int error_code);`
- `void json_stream_reader_set_error_unlocked(json_stream_reader *reader, int error_code);`

### JSon/json_stream_writer.cpp

- `int json_stream_writer_finish(json_stream_writer *writer)`
- `int json_stream_writer_init(json_stream_writer *writer, json_stream_write_callback callback, void *user_data)`
- `int json_stream_writer_process(json_stream_writer *writer, const json_stream_event *event)`
- `static int json_stream_writer_ensure_capacity(json_stream_writer *writer, size_t required)`
- `static int json_stream_writer_pop_context(json_stream_writer *writer, char expected_type)`
- `static int json_stream_writer_prepare_value(json_stream_writer *writer)`
- `static int json_stream_writer_push_context(json_stream_writer *writer, char type)`
- `static int json_stream_writer_write_boolean(json_stream_writer *writer, bool value)`
- `static int json_stream_writer_write_escaped_string(json_stream_writer *writer, const char *value, size_t length)`
- `static int json_stream_writer_write_literal(json_stream_writer *writer, const char *literal)`
- `static int json_stream_writer_write_number(json_stream_writer *writer, const json_stream_scalar *scalar)`
- `static int json_stream_writer_write_string(json_stream_writer *writer, const json_stream_scalar *scalar)`
- `static json_stream_writer_context *json_stream_writer_current_context(json_stream_writer *writer)`
- `static void json_stream_writer_mark_parent_consumed(json_stream_writer *writer)`
- `void json_stream_writer_destroy(json_stream_writer *writer)`

### JSon/json_stream_writer.hpp

- `int json_stream_writer_finish(json_stream_writer *writer);`
- `int json_stream_writer_init(json_stream_writer *writer, json_stream_write_callback callback, void *user_data);`
- `int json_stream_writer_process(json_stream_writer *writer, const json_stream_event *event);`
- `void json_stream_writer_destroy(json_stream_writer *writer);`

### JSon/json_thread_safety.cpp

- `const char *json_group_get_error_str(const json_group *group)`
- `const char *json_item_get_error_str(const json_item *item)`
- `const char *json_schema_field_get_error_str(const json_schema_field *field)`
- `const char *json_schema_get_error_str(const json_schema *schema)`
- `const char *json_stream_reader_get_error_str(const json_stream_reader *reader)`
- `int json_group_enable_thread_safety(json_group *group)`
- `int json_group_get_error(const json_group *group)`
- `int json_group_list_lock(ft_unique_lock<pt_mutex> &guard)`
- `int json_group_lock(json_group *group, ft_unique_lock<pt_mutex> &guard)`
- `int json_item_enable_thread_safety(json_item *item)`
- `int json_item_get_error(const json_item *item)`
- `int json_item_lock(json_item *item, ft_unique_lock<pt_mutex> &guard)`
- `int json_schema_enable_thread_safety(json_schema *schema)`
- `int json_schema_field_enable_thread_safety(json_schema_field *field)`
- `int json_schema_field_get_error(const json_schema_field *field)`
- `int json_schema_field_lock(json_schema_field *field, ft_unique_lock<pt_mutex> &guard)`
- `int json_schema_get_error(const json_schema *schema)`
- `int json_schema_lock(json_schema *schema, ft_unique_lock<pt_mutex> &guard)`
- `int json_stream_reader_enable_thread_safety(json_stream_reader *reader)`
- `int json_stream_reader_get_error(const json_stream_reader *reader)`
- `int json_stream_reader_lock(json_stream_reader *reader, ft_unique_lock<pt_mutex> &guard)`
- `static void json_group_initialize_error(json_group *group) noexcept`
- `static void json_item_initialize_error(json_item *item) noexcept`
- `static void json_schema_field_initialize_error(json_schema_field *field) noexcept`
- `static void json_schema_initialize_error(json_schema *schema) noexcept`
- `static void json_stream_reader_initialize_error(json_stream_reader *reader) noexcept`
- `void json_group_list_finalize_lock(ft_unique_lock<pt_mutex> &guard)`
- `void json_group_set_error(json_group *group, int error_code)`
- `void json_group_set_error_unlocked(json_group *group, int error_code)`
- `void json_item_set_error(json_item *item, int error_code)`
- `void json_item_set_error_unlocked(json_item *item, int error_code)`
- `void json_schema_field_set_error(json_schema_field *field, int error_code)`
- `void json_schema_field_set_error_unlocked(json_schema_field *field, int error_code)`
- `void json_schema_set_error(json_schema *schema, int error_code)`
- `void json_schema_set_error_unlocked(json_schema *schema, int error_code)`
- `void json_stream_reader_finalize_lock(json_stream_reader *reader, ft_unique_lock<pt_mutex> &guard)`
- `void json_stream_reader_set_error(json_stream_reader *reader, int error_code)`
- `void json_stream_reader_set_error_unlocked(json_stream_reader *reader, int error_code)`

### JSon/json_utils.cpp

- `json_group *json_find_group(json_group *head, const char *name)`
- `json_item *json_find_item(json_group *group, const char *key)`
- `void json_remove_group(json_group **head, const char *name)`
- `void json_remove_item(json_group *group, const char *key)`
- `void json_update_item(json_group *group, const char *key, const bool value)`
- `void json_update_item(json_group *group, const char *key, const char *value)`
- `void json_update_item(json_group *group, const char *key, const ft_big_number &value)`
- `void json_update_item(json_group *group, const char *key, const int value)`

### JSon/json_writer.cpp

- `char *json_document_write_to_string(const json_document &document)`
- `char *json_write_to_string(json_group *groups)`
- `int json_document_write_to_backend(ft_document_sink &sink, const json_document &document)`
- `int json_document_write_to_file(const char *file_path, const json_document &document)`
- `int json_write_to_backend(ft_document_sink &sink, json_group *groups)`
- `int json_write_to_file(const char *file_path, json_group *groups)`

### Libft/libft.hpp

- `char *ft_fgets(char *string, int size, FILE *stream);`
- `char *ft_strchr(const char *string, int char_to_find);`
- `char *ft_strmapi(const char *string, char (*function)(unsigned int, char));`
- `char *ft_strncpy(char *destination, const char *source, size_t number_of_characters);`
- `char *ft_strnstr(const char *haystack, const char *needle, size_t maximum_length);`
- `char *ft_strrchr(const char *string, int char_to_find);`
- `char *ft_strstr(const char *haystack, const char *needle);`
- `char *ft_strtok(char *string, const char *delimiters);`
- `char *ft_time_format(char *buffer, size_t buffer_size);`
- `char16_t *ft_utf8_to_utf16(const char *input, size_t input_length, size_t *output_length_pointer);`
- `char32_t *ft_utf8_to_utf32(const char *input, size_t input_length, size_t *output_length_pointer);`
- `constexpr bool ft_is_constant_evaluated()`
- `constexpr int ft_strlen(const char *string)`
- `constexpr size_t ft_strlen_size_t(const char *string)`
- `ft_string ft_locale_casefold(const char *input, const char *locale_name);`
- `ft_string ft_span_to_string(const char *buffer, size_t length);`
- `ft_string ft_to_string(double number);`
- `ft_string ft_to_string(float number);`
- `ft_string ft_to_string(int number);`
- `ft_string ft_to_string(unsigned int number);`
- `ft_string ft_to_string(unsigned long long number);`
- `ft_string ft_to_string(unsigned long number);`
- `ft_string ft_utf16_to_utf8(const char16_t *input, size_t input_length);`
- `ft_string ft_utf32_to_utf8(const char32_t *input, size_t input_length);`
- `int ft_atoi(const char *string);`
- `int ft_fclose(FILE *stream);`
- `int ft_isalnum(int character);`
- `int ft_isalpha(int character);`
- `int ft_isdigit(int character);`
- `int ft_islower(int character);`
- `int ft_isprint(int character);`
- `int ft_isspace(int character);`
- `int ft_isupper(int character);`
- `int ft_memcmp(const void *pointer1, const void *pointer2, size_t size);`
- `int ft_setenv(const char *name, const char *value, int overwrite);`
- `int ft_strcat_s(char *destination, size_t destination_size, const char *source);`
- `int ft_strcmp(const char *string1, const char *string2);`
- `int ft_strncat_s(char *destination, size_t destination_size, const char *source, size_t maximum_append_length);`
- `int ft_strncmp(const char *string_1, const char *string_2, size_t maximum_length);`
- `int ft_strncpy_s(char *destination, size_t destination_size, const char *source, size_t maximum_copy_length);`
- `int ft_unsetenv(const char *name);`
- `int ft_validate_int(const char *input);`
- `long ft_atol(const char *string);`
- `long ft_strtol(const char *input_string, char **end_pointer, int numeric_base);`
- `size_t ft_strlcpy(char *destination, const char *source, size_t buffer_size);`
- `size_t ft_strnlen(const char *string, size_t maximum_length);`
- `unsigned long ft_strtoul(const char *input_string, char **end_pointer, int numeric_base);`
- `void *ft_memchr(const void *pointer, int character, size_t size);`
- `void *ft_memcpy(void* destination, const void* source, size_t size);`
- `void ft_bzero(void *string, size_t size);`
- `void ft_striteri(char *string, void (*function)(unsigned int, char *));`
- `void ft_to_lower(char *string);`
- `void ft_to_upper(char *string);`

### Libft/libft_environment_lock.cpp

- `int ft_environment_lock(void)`
- `int ft_environment_unlock(void)`
- `static void ft_environment_initialize_mutex(void)`
- `void ft_environment_force_lock_failure(int error_code)`
- `void ft_environment_force_unlock_failure(int error_code)`
- `void ft_environment_reset_failures(void)`

### Libft/libft_environment_lock.hpp

- `int ft_environment_unlock(void);`
- `void ft_environment_force_lock_failure(int error_code);`
- `void ft_environment_force_unlock_failure(int error_code);`
- `void ft_environment_reset_failures(void);`

### Libft/libft_locale.cpp

- `ft_string ft_locale_casefold(const char *input, const char *locale_name)`

### Libft/libft_memcpy_s.cpp

- `int ft_memcpy_s(void *destination, size_t destination_size, const void *source, size_t number_of_bytes)`

### Libft/libft_memmove_s.cpp

- `int ft_memmove_s(void *destination, size_t destination_size, const void *source, size_t number_of_bytes)`

### Libft/libft_span.cpp

- `ft_string ft_span_to_string(const char *buffer, size_t length)`

### Libft/libft_strcat_s.cpp

- `int ft_strcat_s(char *destination, size_t destination_size, const char *source)`

### Libft/libft_strcpy_s.cpp

- `int ft_strcpy_s(char *destination, size_t destination_size, const char *source)`

### Libft/libft_strncat_s.cpp

- `int ft_strncat_s(char *destination, size_t destination_size, const char *source, size_t maximum_append_length)`

### Libft/libft_strncpy_s.cpp

- `int ft_strncpy_s(char *destination, size_t destination_size, const char *source, size_t maximum_copy_length)`

### Libft/libft_strtol.cpp

- `long ft_strtol(const char *input_string, char **end_pointer, int numeric_base)`

### Libft/libft_strtoul.cpp

- `unsigned long ft_strtoul(const char *input_string, char **end_pointer, int numeric_base)`

### Libft/libft_time.cpp

- `char *ft_time_format(char *buffer, size_t buffer_size)`

### Libft/libft_to_string.cpp

- `ft_string ft_to_string(double number)`
- `ft_string ft_to_string(float number)`
- `ft_string ft_to_string(int number)`
- `ft_string ft_to_string(long number)`
- `ft_string ft_to_string(unsigned int number)`
- `ft_string ft_to_string(unsigned long long number)`
- `ft_string ft_to_string(unsigned long number)`
- `static ft_string format_double_value(double number, int *error_code)`
- `static ft_string format_signed_long(long number, int *error_code)`
- `static ft_string format_unsigned_long(unsigned long number, int *error_code)`
- `static ft_string format_unsigned_long_long(unsigned long long number, int *error_code)`

### Libft/libft_utf8.hpp

- `int ft_utf8_count(const char *string, size_t *code_point_count_pointer);`
- `int ft_utf8_duplicate_grapheme(const char *string, size_t string_length, size_t *index_pointer, char **grapheme_pointer);`
- `int ft_utf8_encode(uint32_t code_point, char *buffer, size_t buffer_size, size_t *encoded_length_pointer);`
- `int ft_utf8_is_combining_code_point(uint32_t code_point);`
- `int ft_utf8_next(const char *string, size_t string_length, size_t *index_pointer, uint32_t *code_point_pointer, size_t *sequence_length_pointer);`
- `int ft_utf8_next_grapheme(const char *string, size_t string_length, size_t *index_pointer, size_t *grapheme_length_pointer);`
- `int ft_utf8_transform(const char *input, size_t input_length, char *output_buffer, size_t output_buffer_size, ft_utf8_case_hook case_hook);`
- `int ft_utf8_transform_alloc(const char *input, char **output_pointer, ft_utf8_case_hook case_hook);`
- `uint32_t ft_utf8_case_ascii_lower(uint32_t code_point);`
- `uint32_t ft_utf8_case_ascii_upper(uint32_t code_point);`

### Libft/libft_utf8_case.cpp

- `int ft_utf8_encode(uint32_t code_point, char *buffer, size_t buffer_size, size_t *encoded_length_pointer)`
- `int ft_utf8_transform(const char *input, size_t input_length, char *output_buffer, size_t output_buffer_size, ft_utf8_case_hook case_hook)`
- `int ft_utf8_transform_alloc(const char *input, char **output_pointer, ft_utf8_case_hook case_hook)`
- `uint32_t ft_utf8_case_ascii_upper(uint32_t code_point)`

### Libft/libft_utf8_decode.cpp

- `int ft_utf8_next(const char *string, size_t string_length, size_t *index_pointer, uint32_t *code_point_pointer, size_t *sequence_length_pointer)`
- `static int ft_utf8_detect_sequence(unsigned char first_byte, size_t *expected_length, uint32_t *initial_value, uint32_t *minimum_value)`

### Libft/libft_utf8_grapheme.cpp

- `int ft_utf8_duplicate_grapheme(const char *string, size_t string_length, size_t *index_pointer, char **grapheme_pointer)`
- `int ft_utf8_is_combining_code_point(uint32_t code_point)`
- `int ft_utf8_next_grapheme(const char *string, size_t string_length, size_t *index_pointer, size_t *grapheme_length_pointer)`

### Libft/libft_wide.cpp

- `char16_t *ft_utf8_to_utf16(const char *input, size_t input_length, size_t *output_length_pointer)`
- `char32_t *ft_utf8_to_utf32(const char *input, size_t input_length, size_t *output_length_pointer)`
- `ft_string ft_utf16_to_utf8(const char16_t *input, size_t input_length)`
- `ft_string ft_utf32_to_utf8(const char32_t *input, size_t input_length)`
- `size_t ft_wstrlen(const wchar_t *string)`
- `static char16_t *ft_allocate_utf16(size_t code_unit_count, int *error_code)`
- `static int ft_utf16_decode_unit(const char16_t *input, size_t length, size_t index, uint32_t *code_point_pointer, size_t *advance, int *error_code)`
- `static size_t ft_utf32_effective_length(const char32_t *input, size_t input_length)`

### Libft/limits.hpp

- `static constexpr unsigned long long ft_compute_system_size_max()`

### Logger/logger.cpp

- `bool ft_logger::get_alloc_logging() const noexcept`
- `bool ft_logger::get_api_logging() const noexcept`
- `bool ft_logger::get_color() const noexcept`
- `bool ft_logger::is_thread_safe_enabled() const noexcept`
- `bool ft_logger::thread_guard::lock_acquired() const noexcept`
- `const char *ft_logger::get_error_str() const noexcept`
- `ft_log_context_guard ft_logger::make_context_guard(const s_log_field *fields, size_t field_count) noexcept`
- `int ft_logger::add_sink(t_log_sink sink, void *user_data) noexcept`
- `int ft_logger::get_async_metrics(s_log_async_metrics *metrics) noexcept`
- `int ft_logger::get_error() const noexcept`
- `int ft_logger::get_remote_health(s_log_remote_health *statuses, size_t capacity, size_t *count) noexcept`
- `int ft_logger::get_rotation(size_t *max_size, size_t *retention_count, unsigned int *max_age_seconds) noexcept`
- `int ft_logger::lock(bool *lock_acquired) const noexcept`
- `int ft_logger::prepare_thread_safety() noexcept`
- `int ft_logger::probe_remote_health() noexcept`
- `int ft_logger::push_context(const s_log_field *fields, size_t field_count) noexcept`
- `int ft_logger::set_file(const char *path, size_t max_size) noexcept`
- `int ft_logger::set_remote_sink(const char *host, unsigned short port, bool use_tcp) noexcept`
- `int ft_logger::set_rotation(size_t max_size, size_t retention_count, unsigned int max_age_seconds) noexcept`
- `int ft_logger::set_syslog(const char *identifier) noexcept`
- `int ft_logger::thread_guard::get_status() const noexcept`
- `size_t ft_logger::get_async_queue_limit() const noexcept`
- `void ft_logger::close() noexcept`
- `void ft_logger::debug(const char *fmt, ...) noexcept`
- `void ft_logger::enable_remote_health(bool enable) noexcept`
- `void ft_logger::error(const char *fmt, ...) noexcept`
- `void ft_logger::info(const char *fmt, ...) noexcept`
- `void ft_logger::pop_context(size_t field_count) noexcept`
- `void ft_logger::remove_sink(t_log_sink sink, void *user_data) noexcept`
- `void ft_logger::reset_async_metrics() noexcept`
- `void ft_logger::set_alloc_logging(bool enable) noexcept`
- `void ft_logger::set_api_logging(bool enable) noexcept`
- `void ft_logger::set_async_queue_limit(size_t limit) noexcept`
- `void ft_logger::set_color(bool enable) noexcept`
- `void ft_logger::set_error(int error_code) const noexcept`
- `void ft_logger::set_global() noexcept`
- `void ft_logger::set_level(t_log_level level) noexcept`
- `void ft_logger::set_remote_health_interval(unsigned int interval_seconds) noexcept`
- `void ft_logger::structured(t_log_level level, const char *message, const s_log_field *fields, size_t field_count) noexcept`
- `void ft_logger::structured_debug(const char *message, const s_log_field *fields, size_t field_count) noexcept`
- `void ft_logger::structured_error(const char *message, const s_log_field *fields, size_t field_count) noexcept`
- `void ft_logger::structured_info(const char *message, const s_log_field *fields, size_t field_count) noexcept`
- `void ft_logger::structured_warn(const char *message, const s_log_field *fields, size_t field_count) noexcept`
- `void ft_logger::teardown_thread_safety() noexcept`
- `void ft_logger::unlock(bool lock_acquired) const noexcept`
- `void ft_logger::warn(const char *fmt, ...) noexcept`

### Logger/logger.hpp

- `bool ft_log_get_alloc_logging();`
- `bool ft_log_get_api_logging();`
- `bool ft_log_get_color();`
- `int ft_log_add_redaction(const char *pattern);`
- `int ft_log_add_redaction_with_replacement(const char *pattern, const char *replacement);`
- `int ft_log_add_sink(t_log_sink sink, void *user_data);`
- `int ft_log_context_push(const s_log_field *fields, size_t field_count);`
- `int ft_log_get_async_metrics(s_log_async_metrics *metrics);`
- `int ft_log_get_remote_health(s_log_remote_health *statuses, size_t capacity, size_t *count);`
- `int ft_log_get_rotation(size_t *max_size, size_t *retention_count, unsigned int *max_age_seconds);`
- `int ft_log_lock_contention_get_statistics(s_log_lock_contention_statistics *statistics);`
- `int ft_log_probe_remote_health();`
- `int ft_log_sample_lock_contention(s_log_lock_contention_sample *samples, size_t capacity, size_t *count);`
- `int ft_log_set_file(const char *path, size_t max_size);`
- `int ft_log_set_remote_sink(const char *host, unsigned short port, bool use_tcp);`
- `int ft_log_set_rotation(size_t max_size, size_t retention_count, unsigned int max_age_seconds);`
- `int ft_log_set_syslog(const char *identifier);`
- `int log_async_metrics_lock(s_log_async_metrics *metrics, bool *lock_acquired);`
- `int log_async_metrics_prepare_thread_safety(s_log_async_metrics *metrics);`
- `int log_field_lock(const s_log_field *field, bool *lock_acquired);`
- `int log_field_prepare_thread_safety(s_log_field *field);`
- `size_t ft_log_get_async_queue_limit();`
- `void ft_json_sink(const char *message, void *user_data);`
- `void ft_log_clear_redactions();`
- `void ft_log_close();`
- `void ft_log_context_clear();`
- `void ft_log_context_pop(size_t field_count);`
- `void ft_log_debug(const char *fmt, ...);`
- `void ft_log_debug_structured(const char *message, const s_log_field *fields, size_t field_count);`
- `void ft_log_enable_async(bool enable);`
- `void ft_log_enable_lock_contention_sampling(bool enable);`
- `void ft_log_enable_remote_health(bool enable);`
- `void ft_log_enqueue(t_log_level level, const char *fmt, va_list args);`
- `void ft_log_error(const char *fmt, ...);`
- `void ft_log_error_structured(const char *message, const s_log_field *fields, size_t field_count);`
- `void ft_log_info(const char *fmt, ...);`
- `void ft_log_info_structured(const char *message, const s_log_field *fields, size_t field_count);`
- `void ft_log_lock_contention_reset_statistics();`
- `void ft_log_remove_sink(t_log_sink sink, void *user_data);`
- `void ft_log_reset_async_metrics();`
- `void ft_log_set_alloc_logging(bool enable);`
- `void ft_log_set_api_logging(bool enable);`
- `void ft_log_set_async_queue_limit(size_t limit);`
- `void ft_log_set_color(bool enable);`
- `void ft_log_set_level(t_log_level level);`
- `void ft_log_set_lock_contention_priority_threshold(long threshold_ms);`
- `void ft_log_set_lock_contention_sampling_interval(unsigned int interval_ms);`
- `void ft_log_set_remote_health_interval(unsigned int interval_seconds);`
- `void ft_log_structured(t_log_level level, const char *message, const s_log_field *fields, size_t field_count);`
- `void ft_log_warn(const char *fmt, ...);`
- `void ft_log_warn_structured(const char *message, const s_log_field *fields, size_t field_count);`
- `void ft_syslog_sink(const char *message, void *user_data);`
- `void log_async_metrics_teardown_thread_safety(s_log_async_metrics *metrics);`
- `void log_async_metrics_unlock(s_log_async_metrics *metrics, bool lock_acquired);`
- `void log_field_teardown_thread_safety(s_log_field *field);`
- `void log_field_unlock(const s_log_field *field, bool lock_acquired);`

### Logger/logger_file_sink_thread_safety.cpp

- `int file_sink_lock(const s_file_sink *sink, bool *lock_acquired)`
- `void file_sink_teardown_thread_safety(s_file_sink *sink)`
- `void file_sink_unlock(const s_file_sink *sink, bool lock_acquired)`

### Logger/logger_internal.hpp

- `const char *ft_level_to_str(t_log_level level);`
- `int file_sink_lock(const s_file_sink *sink, bool *lock_acquired);`
- `int file_sink_prepare_thread_safety(s_file_sink *sink);`
- `int ft_log_level_to_severity(t_log_level level);`
- `int log_sink_lock(const s_log_sink *sink, bool *lock_acquired);`
- `int log_sink_prepare_thread_safety(s_log_sink *sink);`
- `int logger_apply_redactions(ft_string &text, const ft_vector<s_redaction_rule> &rules);`
- `int logger_build_standard_message(t_log_level level, const ft_string &message_text, const ft_string &context_fragment, ft_string &formatted_message);`
- `int logger_context_apply_plain(ft_string &text);`
- `int logger_context_format_flat(ft_string &output);`
- `int logger_context_push(const s_log_field *fields, size_t field_count, size_t *pushed_count);`
- `int logger_context_snapshot(ft_vector<s_log_context_view> &snapshot);`
- `int logger_copy_redaction_rules(ft_vector<s_redaction_rule> &destination);`
- `int logger_lock_sinks();`
- `int logger_prepare_rotation(s_file_sink *sink, bool *rotate_for_size, bool *rotate_for_age);`
- `int logger_unlock_sinks();`
- `int network_sink_lock(const s_network_sink *sink, bool *lock_acquired);`
- `int network_sink_prepare_thread_safety(s_network_sink *sink);`
- `void file_sink_teardown_thread_safety(s_file_sink *sink);`
- `void file_sink_unlock(const s_file_sink *sink, bool lock_acquired);`
- `void ft_file_sink(const char *message, void *user_data);`
- `void ft_log_rotate(s_file_sink *sink);`
- `void ft_log_vwrite(t_log_level level, const char *fmt, va_list args);`
- `void ft_network_sink(const char *message, void *user_data);`
- `void log_sink_teardown_thread_safety(s_log_sink *sink);`
- `void log_sink_unlock(const s_log_sink *sink, bool lock_acquired);`
- `void logger_context_clear();`
- `void logger_context_pop(size_t count);`
- `void logger_execute_rotation(s_file_sink *sink);`
- `void network_sink_teardown_thread_safety(s_network_sink *sink);`
- `void network_sink_unlock(const s_network_sink *sink, bool lock_acquired);`

### Logger/logger_lock_contention.cpp

- `int ft_log_lock_contention_get_statistics(s_log_lock_contention_statistics *statistics)`
- `int ft_log_sample_lock_contention(s_log_lock_contention_sample *samples, size_t capacity, size_t *count)`
- `static int logger_lock_contention_lock()`
- `static int logger_lock_contention_unlock()`
- `static void logger_lock_contention_initialize_mutex()`
- `static void logger_lock_contention_record_sample(long wait_duration_ms, bool priority_inversion, bool skipped)`
- `void ft_log_enable_lock_contention_sampling(bool enable)`
- `void ft_log_lock_contention_reset_statistics()`
- `void ft_log_set_lock_contention_priority_threshold(long threshold_ms)`
- `void ft_log_set_lock_contention_sampling_interval(unsigned int interval_ms)`

### Logger/logger_log_add_sink.cpp

- `int ft_log_add_sink(t_log_sink sink, void *user_data)`
- `static int logger_json_sink_hex_value(char character)`
- `static void logger_json_sink_append_character_sequence(ft_string &buffer, const char *sequence, int &error_code)`
- `static void logger_json_sink_append_json_escaped(ft_string &buffer, char character, int &error_code)`
- `static void logger_json_sink_append_json_string(ft_string &buffer, const char *value, int &error_code)`
- `static void logger_json_sink_append_literal(ft_string &buffer, const char *literal, int &error_code)`
- `static void logger_json_sink_decode_quoted(const char *message, size_t &index, char *destination, size_t capacity)`
- `static void logger_json_sink_decode_unquoted(const char *message, size_t &index, char *destination, size_t capacity)`
- `void ft_json_sink(const char *message, void *user_data)`

### Logger/logger_log_async.cpp

- `int ft_log_get_async_metrics(s_log_async_metrics *metrics)`
- `size_t ft_log_get_async_queue_limit()`
- `static void *ft_log_worker(void *argument)`
- `static void ft_log_process_message(const ft_string &message)`
- `void ft_log_enable_async(bool enable)`
- `void ft_log_enqueue(t_log_level level, const char *fmt, va_list args)`
- `void ft_log_reset_async_metrics()`
- `void ft_log_set_async_queue_limit(size_t limit)`

### Logger/logger_log_async_metrics_thread_safety.cpp

- `int log_async_metrics_lock(s_log_async_metrics *metrics, bool *lock_acquired)`
- `void log_async_metrics_teardown_thread_safety(s_log_async_metrics *metrics)`
- `void log_async_metrics_unlock(s_log_async_metrics *metrics, bool lock_acquired)`

### Logger/logger_log_close.cpp

- `void ft_log_close()`

### Logger/logger_log_context.cpp

- `int ft_log_context_push(const s_log_field *fields, size_t field_count)`
- `int logger_context_apply_plain(ft_string &text)`
- `int logger_context_format_flat(ft_string &output)`
- `int logger_context_push(const s_log_field *fields, size_t field_count, size_t *pushed_count)`
- `int logger_context_snapshot(ft_vector<s_log_context_view> &snapshot)`
- `static bool logger_context_value_needs_quotes(const char *value)`
- `static int logger_context_append_flat_value(ft_string &output, const char *value)`
- `static int logger_context_format_prefix(ft_string &prefix)`
- `static int logger_context_rollback(size_t count)`
- `void ft_log_context_clear()`
- `void ft_log_context_pop(size_t field_count)`
- `void logger_context_clear()`
- `void logger_context_pop(size_t count)`

### Logger/logger_log_context_guard.cpp

- `bool ft_log_context_guard::is_active() const noexcept`
- `const char *ft_log_context_guard::get_error_str() const`
- `int ft_log_context_guard::get_error() const`
- `void ft_log_context_guard::release() noexcept`
- `void ft_log_context_guard::set_error(int error_code) const`

### Logger/logger_log_field_thread_safety.cpp

- `int log_field_lock(const s_log_field *field, bool *lock_acquired)`
- `void log_field_teardown_thread_safety(s_log_field *field)`
- `void log_field_unlock(const s_log_field *field, bool lock_acquired)`

### Logger/logger_log_health.cpp

- `int ft_log_get_remote_health(s_log_remote_health *statuses, size_t capacity, size_t *count)`
- `int ft_log_probe_remote_health()`
- `static int logger_health_fetch_config(bool *running, unsigned int *interval_seconds)`
- `static int logger_health_lock()`
- `static int logger_health_record_result(s_network_sink *sink, bool reachable, int error_code)`
- `static int logger_health_sync_states(const ft_vector<s_network_sink_snapshot> &snapshot)`
- `static int logger_health_unlock()`
- `static int logger_health_wait_loop(unsigned int interval_seconds)`
- `static int logger_snapshot_network_sinks(ft_vector<s_network_sink_snapshot> &snapshot)`
- `static void *logger_health_thread(void *argument)`
- `static void logger_health_initialize_mutex()`
- `static void logger_health_probe_sink(const s_network_sink_snapshot &snapshot_entry, bool *reachable, int *error_code)`
- `void ft_log_enable_remote_health(bool enable)`
- `void ft_log_set_remote_health_interval(unsigned int interval_seconds)`

### Logger/logger_log_level_to_str.cpp

- `int ft_log_level_to_severity(t_log_level level)`

### Logger/logger_log_redaction.cpp

- `int ft_log_add_redaction(const char *pattern)`
- `int ft_log_add_redaction_with_replacement(const char *pattern, const char *replacement)`
- `int logger_apply_redactions(ft_string &text, const ft_vector<s_redaction_rule> &rules)`
- `int logger_copy_redaction_rules(ft_vector<s_redaction_rule> &destination)`
- `static int logger_apply_redaction_rule(ft_string &text, const s_redaction_rule &rule)`
- `void ft_log_clear_redactions()`

### Logger/logger_log_rotate.cpp

- `int logger_prepare_rotation(s_file_sink *sink, bool *rotate_for_size, bool *rotate_for_age)`
- `static int logger_prepare_rotation_internal(s_file_sink *sink, bool *rotate_for_size, bool *rotate_for_age)`
- `static int logger_shift_rotation_chain(const ft_string &rotation_base, size_t retention_count)`
- `void ft_log_rotate(s_file_sink *sink)`
- `void logger_execute_rotation(s_file_sink *sink)`

### Logger/logger_log_set_file.cpp

- `int ft_log_set_file(const char *path, size_t max_size)`
- `static int log_set_file_report(int error_code, int return_value)`

### Logger/logger_log_set_rotation.cpp

- `int ft_log_get_rotation(size_t *max_size, size_t *retention_count, unsigned int *max_age_seconds)`
- `int ft_log_set_rotation(size_t max_size, size_t retention_count, unsigned int max_age_seconds)`

### Logger/logger_log_sink_thread_safety.cpp

- `int log_sink_lock(const s_log_sink *sink, bool *lock_acquired)`
- `void log_sink_teardown_thread_safety(s_log_sink *sink)`
- `void log_sink_unlock(const s_log_sink *sink, bool lock_acquired)`

### Logger/logger_log_state.cpp

- `int logger_lock_sinks()`
- `int logger_unlock_sinks()`
- `static void logger_initialize_sinks_mutex()`

### Logger/logger_log_structured.cpp

- `static void logger_append_character_sequence(ft_string &buffer, const char *sequence, int &error_code)`
- `static void logger_append_field(ft_string &buffer, const s_log_field &field, bool &first_field, int &error_code)`
- `static void logger_append_json_escaped(ft_string &buffer, char character, int &error_code)`
- `static void logger_append_json_optional_string(ft_string &buffer, const char *value, int &error_code)`
- `static void logger_append_json_string(ft_string &buffer, const char *value, int &error_code)`
- `static void logger_dispatch_structured(t_log_level level, const char *payload)`
- `void ft_log_debug_structured(const char *message, const s_log_field *fields, size_t field_count)`
- `void ft_log_error_structured(const char *message, const s_log_field *fields, size_t field_count)`
- `void ft_log_info_structured(const char *message, const s_log_field *fields, size_t field_count)`
- `void ft_log_structured(t_log_level level, const char *message, const s_log_field *fields, size_t field_count)`
- `void ft_log_warn_structured(const char *message, const s_log_field *fields, size_t field_count)`

### Logger/logger_log_vwrite.cpp

- `int logger_build_standard_message(t_log_level level, const ft_string &message_text, const ft_string &context_fragment, ft_string &formatted_message)`
- `static bool logger_sink_snapshot_contains(const ft_vector<s_log_sink> &snapshot, const s_log_sink &entry, int &error_code)`
- `static int logger_append_quoted_token(ft_string &buffer, const char *value)`
- `void ft_log_vwrite(t_log_level level, const char *fmt, va_list args)`

### Logger/logger_network.cpp

- `void ft_network_sink(const char *message, void *user_data)`

### Logger/logger_network_sink_thread_safety.cpp

- `int network_sink_lock(const s_network_sink *sink, bool *lock_acquired)`
- `void network_sink_teardown_thread_safety(s_network_sink *sink)`
- `void network_sink_unlock(const s_network_sink *sink, bool lock_acquired)`

### Logger/logger_syslog.cpp

- `void ft_syslog_sink(const char *message, void *user_data)`

### Math/linear_algebra.cpp

- `), _mutex()`
- `ft_operation_error_stack *matrix2::get_operation_error_stack_for_validation() const noexcept`
- `ft_operation_error_stack *matrix3::get_operation_error_stack_for_validation() const noexcept`
- `ft_operation_error_stack *matrix4::get_operation_error_stack_for_validation() const noexcept`
- `int matrix2::lock_pair(const matrix2 &first, const matrix2 &second, const matrix2 *&lower, const matrix2 *&upper)`
- `int matrix3::lock_pair(const matrix3 &first, const matrix3 &second, const matrix3 *&lower, const matrix3 *&upper)`
- `int matrix4::lock_pair(const matrix4 &first, const matrix4 &second, const matrix4 *&lower, const matrix4 *&upper)`
- `matrix2 matrix2::invert() const`
- `matrix2 matrix2::multiply(const matrix2 &other) const`
- `matrix3 matrix3::invert() const`
- `matrix3 matrix3::multiply(const matrix3 &other) const`
- `matrix4 matrix4::invert() const`
- `matrix4 matrix4::make_rotation_x(double angle)`
- `matrix4 matrix4::make_rotation_y(double angle)`
- `matrix4 matrix4::make_rotation_z(double angle)`
- `matrix4 matrix4::make_scale(double x, double y, double z)`
- `matrix4 matrix4::make_translation(double x, double y, double z)`
- `matrix4 matrix4::multiply(const matrix4 &other) const`
- `pt_recursive_mutex *matrix2::get_mutex_for_validation() const`
- `pt_recursive_mutex *matrix3::get_mutex_for_validation() const`
- `pt_recursive_mutex *matrix4::get_mutex_for_validation() const`
- `static int math_matrix2_lock_mutex(const pt_recursive_mutex &mutex)`
- `static int math_matrix2_unlock_mutex(const pt_recursive_mutex &mutex)`
- `static int math_matrix3_lock_mutex(const pt_recursive_mutex &mutex)`
- `static int math_matrix3_unlock_mutex(const pt_recursive_mutex &mutex)`
- `static int math_matrix4_lock_mutex(const pt_recursive_mutex &mutex)`
- `static int math_matrix4_unlock_mutex(const pt_recursive_mutex &mutex)`
- `vector2 matrix2::transform(const vector2 &vector) const`
- `vector3 matrix3::transform(const vector3 &vector) const`
- `vector4 matrix4::transform(const vector4 &vector) const`
- `void matrix2::record_operation_error(int error_code) const noexcept`
- `void matrix2::unlock_pair(const matrix2 *lower, const matrix2 *upper)`
- `void matrix3::record_operation_error(int error_code) const noexcept`
- `void matrix3::unlock_pair(const matrix3 *lower, const matrix3 *upper)`
- `void matrix4::record_operation_error(int error_code) const noexcept`
- `void matrix4::unlock_pair(const matrix4 *lower, const matrix4 *upper)`

### Math/linear_algebra.hpp

- `double dot(const vector2 &other) const;`
- `double get_x() const;`
- `double get_y() const;`
- `double length() const;`
- `ft_operation_error_stack *get_operation_error_stack_for_validation() const noexcept;`
- `pt_recursive_mutex *get_mutex_for_validation() const;`
- `public: vector2();`
- `static int lock_pair(const vector2 &first, const vector2 &second, const vector2 *&lower, const vector2 *&upper);`
- `static void unlock_pair(const vector2 *lower, const vector2 *upper);`
- `vector2 add(const vector2 &other) const;`
- `vector2 normalize() const;`
- `vector2 subtract(const vector2 &other) const;`
- `void record_operation_error(int error_code) const noexcept;`

### Math/linear_algebra_quaternion.cpp

- `const char *quaternion::last_operation_error_str() const noexcept`
- `const char *quaternion::operation_error_str_at(ft_size_t index) const noexcept`
- `double quaternion::get_w() const`
- `double quaternion::get_x() const`
- `double quaternion::get_y() const`
- `double quaternion::get_z() const`
- `double quaternion::length() const`
- `ft_operation_error_stack *quaternion::get_operation_error_stack_for_validation() noexcept`
- `int quaternion::operation_error_at(ft_size_t index) const noexcept`
- `int quaternion::pop_newest_operation_error() noexcept`
- `int quaternion::pop_oldest_operation_error() noexcept`
- `quaternion quaternion::add(const quaternion &other) const`
- `quaternion quaternion::conjugate() const`
- `quaternion quaternion::multiply(const quaternion &other) const`
- `quaternion quaternion::normalize() const`
- `static int math_quaternion_unlock_mutex(const pt_recursive_mutex &mutex)`
- `static int quaternion_lock_pair(const quaternion &first, const quaternion &second, const quaternion *&lower, const quaternion *&upper)`
- `static pt_recursive_mutex *quaternion_mutex_for(const quaternion &value)`
- `static void quaternion_compute_product_components(quaternion &result, double first_w, double first_x, double first_y, double first_z, double second_w, double second_x, double second_y, double second_z)`
- `static void quaternion_sleep_backoff()`
- `static void quaternion_unlock_pair(const quaternion *lower, const quaternion *upper)`
- `void quaternion::pop_operation_errors() noexcept`
- `void quaternion::record_operation_error(int error_code) const noexcept`

### Math/linear_algebra_quaternion.hpp

- `const char *last_operation_error_str() const noexcept;`
- `const char *operation_error_str_at(ft_size_t index) const noexcept;`
- `double get_w() const;`
- `double get_x() const;`
- `double get_y() const;`
- `double get_z() const;`
- `double length() const;`
- `ft_operation_error_stack *get_operation_error_stack_for_validation() noexcept;`
- `int last_operation_error() const noexcept;`
- `int operation_error_at(ft_size_t index) const noexcept;`
- `int pop_newest_operation_error() noexcept;`
- `int pop_oldest_operation_error() noexcept;`
- `pt_recursive_mutex *get_mutex_for_validation() const noexcept;`
- `public: quaternion();`
- `quaternion add(const quaternion &other) const;`
- `quaternion conjugate() const;`
- `quaternion multiply(const quaternion &other) const;`
- `quaternion normalize() const;`
- `void pop_operation_errors() noexcept;`
- `void record_operation_error(int error_code) const noexcept;`

### Math/linear_algebra_vector2.cpp

- `), _mutex()`
- `double vector2::dot(const vector2 &other) const`
- `double vector2::get_x() const`
- `double vector2::get_y() const`
- `double vector2::length() const`
- `ft_operation_error_stack *vector2::get_operation_error_stack_for_validation() const noexcept`
- `pt_recursive_mutex *vector2::get_mutex_for_validation() const`
- `static int math_vector2_lock_mutex(const pt_recursive_mutex &mutex)`
- `static int math_vector2_unlock_mutex(const pt_recursive_mutex &mutex)`
- `vector2 vector2::add(const vector2 &other) const`
- `vector2 vector2::normalize() const`
- `vector2 vector2::subtract(const vector2 &other) const`
- `void vector2::record_operation_error(int error_code) const noexcept`
- `void vector2::unlock_pair(const vector2 *lower, const vector2 *upper)`

### Math/linear_algebra_vector3.cpp

- `double vector3::dot(const vector3 &other) const`
- `double vector3::get_x() const`
- `double vector3::get_y() const`
- `double vector3::get_z() const`
- `double vector3::length() const`
- `ft_operation_error_stack *vector3::get_operation_error_stack_for_validation() const noexcept`
- `pt_recursive_mutex *vector3::get_mutex_for_validation() const`
- `static int math_vector3_lock_mutex(const pt_recursive_mutex &mutex)`
- `static int math_vector3_unlock_mutex(const pt_recursive_mutex &mutex)`
- `vector3 vector3::add(const vector3 &other) const`
- `vector3 vector3::cross(const vector3 &other) const`
- `vector3 vector3::normalize() const`
- `vector3 vector3::subtract(const vector3 &other) const`
- `void vector3::record_operation_error(int error_code) const noexcept`
- `void vector3::unlock_pair(const vector3 *lower, const vector3 *upper)`

### Math/linear_algebra_vector4.cpp

- `), _mutex()`
- `double vector4::dot(const vector4 &other) const`
- `double vector4::get_w() const`
- `double vector4::get_x() const`
- `double vector4::get_y() const`
- `double vector4::get_z() const`
- `double vector4::length() const`
- `ft_operation_error_stack *vector4::get_operation_error_stack_for_validation() const noexcept`
- `pt_recursive_mutex *vector4::get_mutex_for_validation() const`
- `static int math_vector4_lock_mutex(const pt_recursive_mutex &mutex)`
- `static int math_vector4_unlock_mutex(const pt_recursive_mutex &mutex)`
- `vector4 vector4::add(const vector4 &other) const`
- `vector4 vector4::normalize() const`
- `vector4 vector4::subtract(const vector4 &other) const`
- `void vector4::record_operation_error(int error_code) const noexcept`
- `void vector4::unlock_pair(const vector4 *lower, const vector4 *upper)`

### Math/math.hpp

- `double ft_geometric_mean(const double *values, int array_size);`
- `double ft_harmonic_mean(const double *values, int array_size);`
- `double ft_mean(const double *values, int array_size);`
- `double ft_median(const double *values, int array_size);`
- `double ft_mode(const double *values, int array_size);`
- `double ft_sin(double value);`
- `double ft_stddev(const double *values, int array_size);`
- `double ft_tan(double value);`
- `double ft_variance(const double *values, int array_size);`
- `double math_absdiff(double first_number, double second_number);`
- `double math_acos(double dot);`
- `double math_average(double first_number, double second_number);`
- `double math_clamp(double value, double minimum, double maximum);`
- `double math_cos(double value);`
- `double math_deg2rad(double degrees);`
- `double math_exp(double value);`
- `double math_fabs(double number);`
- `double math_fmod(double value, double modulus);`
- `double math_indeterminate(void);`
- `double math_infinity(void);`
- `double math_log(double value);`
- `double math_max(double first_number, double second_number);`
- `double math_min(double first_number, double second_number);`
- `double math_nan(void);`
- `double math_negative_infinity(void);`
- `double math_pow(double base_value, int exponent);`
- `double math_rad2deg(double radians);`
- `double math_sqrt(double number);`
- `ft_big_number math_big_gcd(const ft_big_number &first_number, const ft_big_number &second_number);`
- `ft_big_number math_big_lcm(const ft_big_number &first_number, const ft_big_number &second_number);`
- `int math_absdiff(int first_number, int second_number);`
- `int math_average(int first_number, int second_number);`
- `int math_clamp(int value, int minimum, int maximum);`
- `int math_convolution(const ft_vector<double> &first, const ft_vector<double> &second, ft_vector<double> &result) noexcept;`
- `int math_factorial(int number);`
- `int math_fft(const ft_vector<double> &input_real, const ft_vector<double> &input_imag, ft_vector<double> &output_real, ft_vector<double> &output_imag) noexcept;`
- `int math_gcd(int first_number, int second_number);`
- `int math_ifft(const ft_vector<double> &input_real, const ft_vector<double> &input_imag, ft_vector<double> &output_real, ft_vector<double> &output_imag) noexcept;`
- `int math_isinf(double number);`
- `int math_isnan(double number);`
- `int math_lcm(int first_number, int second_number);`
- `int math_max(int first_number, int second_number);`
- `int math_min(int first_number, int second_number);`
- `int math_signbit(double number);`
- `int math_validate_int(const char *input);`
- `long long math_abs(long long number);`
- `long long math_absdiff(long long first_number, long long second_number);`
- `long long math_average(long long first_number, long long second_number);`
- `long long math_factorial(long long number);`
- `long long math_gcd(long long first_number, long long second_number);`
- `long long math_lcm(long long first_number, long long second_number);`
- `long long math_max(long long first_number, long long second_number);`
- `long long math_min(long long first_number, long long second_number);`
- `long math_abs(long number);`
- `long math_absdiff(long first_number, long second_number);`
- `long math_average(long first_number, long second_number);`
- `long math_factorial(long number);`
- `long math_gcd(long first_number, long second_number);`
- `long math_lcm(long first_number, long second_number);`
- `long math_max(long first_number, long second_number);`
- `long math_min(long first_number, long second_number);`
- `void math_swap(int *first_number, int *second_number);`

### Math/math_abs.cpp

- `long long math_abs(long long number)`
- `long math_abs(long number)`

### Math/math_absdiff.cpp

- `double math_absdiff(double first_number, double second_number)`
- `int math_absdiff(int first_number, int second_number)`
- `long long math_absdiff(long long first_number, long long second_number)`
- `long math_absdiff(long first_number, long second_number)`

### Math/math_acos.cpp

- `double math_acos(double dot)`

### Math/math_autodiff.cpp

- `) , _mutex()`
- `const char *ft_dual_number::get_error_str() const noexcept`
- `double ft_dual_number::derivative() const noexcept`
- `double ft_dual_number::value() const noexcept`
- `ft_dual_number ft_dual_number::apply_cos() const noexcept`
- `ft_dual_number ft_dual_number::apply_exp() const noexcept`
- `ft_dual_number ft_dual_number::apply_log() const noexcept`
- `ft_dual_number ft_dual_number::apply_sin() const noexcept`
- `ft_dual_number ft_dual_number::constant(double value) noexcept`
- `ft_dual_number ft_dual_number::variable(double value) noexcept`
- `int ft_dual_number::get_error() const noexcept`
- `int math_autodiff_gradient(math_autodiff_multivariate_function function, const ft_vector<double> &point, ft_vector<double> &gradient, double *value, void *user_data) noexcept`
- `int math_autodiff_univariate(math_autodiff_univariate_function function, double point, double *value, double *derivative, void *user_data) noexcept`
- `pt_recursive_mutex *ft_dual_number::get_mutex_for_validation() const noexcept`
- `static int math_autodiff_prepare_inputs(const ft_vector<double> &point, size_t active_index, ft_vector<ft_dual_number> &dual_inputs) noexcept`
- `static void math_autodiff_push_error(int error_code)`
- `void ft_dual_number::record_operation_error(int error_code) const noexcept`
- `void ft_dual_number::set_error(int error_code) const noexcept`

### Math/math_autodiff.hpp

- `const char *get_error_str() const noexcept;`
- `double derivative() const noexcept;`
- `double value() const noexcept;`
- `ft_dual_number apply_cos() const noexcept;`
- `ft_dual_number apply_exp() const noexcept;`
- `ft_dual_number apply_log() const noexcept;`
- `ft_dual_number apply_sin() const noexcept;`
- `int get_error() const noexcept;`
- `int math_autodiff_gradient(math_autodiff_multivariate_function function, const ft_vector<double> &point, ft_vector<double> &gradient, double *value, void *user_data) noexcept;`
- `int math_autodiff_univariate(math_autodiff_univariate_function function, double point, double *value, double *derivative, void *user_data) noexcept;`
- `pt_recursive_mutex *get_mutex_for_validation() const noexcept;`
- `public: ft_dual_number() noexcept;`
- `static ft_dual_number constant(double value) noexcept;`
- `static ft_dual_number variable(double value) noexcept;`
- `void record_operation_error(int error_code) const noexcept;`
- `void set_error(int error_code) const noexcept;`

### Math/math_average.cpp

- `double math_average(double first_number, double second_number)`
- `long long math_average(long long first_number, long long second_number)`
- `long math_average(long first_number, long second_number)`

### Math/math_big_number.cpp

- `ft_big_number math_big_gcd(const ft_big_number &first_number, const ft_big_number &second_number)`
- `ft_big_number math_big_lcm(const ft_big_number &first_number, const ft_big_number &second_number)`
- `static ft_big_number math_big_gcd_normalized(ft_big_number first_value, ft_big_number second_value)`

### Math/math_clamp.cpp

- `double math_clamp(double value, double minimum, double maximum)`

### Math/math_eval.cpp

- `int *math_eval(const char *expression)`

### Math/math_factorial.cpp

- `long long math_factorial(long long number)`
- `long math_factorial(long number)`

### Math/math_fft.cpp

- `int math_convolution(const ft_vector<double> &first, const ft_vector<double> &second, ft_vector<double> &result) noexcept`
- `int math_fft(const ft_vector<double> &input_real, const ft_vector<double> &input_imag, ft_vector<double> &output_real, ft_vector<double> &output_imag) noexcept`
- `int math_ifft(const ft_vector<double> &input_real, const ft_vector<double> &input_imag, ft_vector<double> &output_real, ft_vector<double> &output_imag) noexcept`
- `static bool math_fft_is_power_of_two(size_t value) noexcept`
- `static int math_fft_bit_reverse(ft_vector<double> &real, ft_vector<double> &imag) noexcept`
- `static int math_fft_copy_inputs(const ft_vector<double> &input, ft_vector<double> &output) noexcept`
- `static int math_fft_dispatch(const ft_vector<double> &input_real, const ft_vector<double> &input_imag, ft_vector<double> &output_real, ft_vector<double> &output_imag, bool inverse) noexcept`
- `static int math_fft_iterative(ft_vector<double> &real, ft_vector<double> &imag, bool inverse) noexcept`
- `static int math_fft_pointwise_multiply(ft_vector<double> &first_real, ft_vector<double> &first_imag, const ft_vector<double> &second_real, const ft_vector<double> &second_imag) noexcept`
- `static int math_fft_prepare_padded(const ft_vector<double> &input, size_t target_length, ft_vector<double> &real, ft_vector<double> &imag) noexcept`
- `static size_t math_fft_next_power_of_two(size_t value) noexcept`
- `static void math_fft_push_error(int error_code)`
- `static void math_fft_swap(ft_vector<double> &real, ft_vector<double> &imag, size_t first, size_t second) noexcept`

### Math/math_fft.hpp

- `int math_convolution(const ft_vector<double> &first, const ft_vector<double> &second, ft_vector<double> &result) noexcept;`
- `int math_ifft(const ft_vector<double> &input_real, const ft_vector<double> &input_imag, ft_vector<double> &output_real, ft_vector<double> &output_imag) noexcept;`

### Math/math_fmod.cpp

- `double math_fmod(double value, double modulus)`

### Math/math_gcd.cpp

- `int math_gcd(int first_number, int second_number)`
- `long long math_gcd(long long first_number, long long second_number)`
- `long math_gcd(long first_number, long second_number)`
- `static long long math_gcd_normalized_long_long(long long first_number, long long second_number)`
- `static long math_gcd_normalized_long(long first_number, long second_number)`

### Math/math_internal.hpp

- `int math_check_string_number(char *string);`
- `int math_is_unary_sign(const char *string, int index);`
- `int math_process_sign(char *string, int *index, int string_boundary, int *error);`
- `int math_roll_check_character(char character);`
- `int math_roll_check_number_previous(char *string, int index);`
- `int math_roll_convert_next(char *string, int index, int *error);`
- `int math_roll_convert_previous(char *string, int *index, int *error);`
- `int math_roll_excecute_droll(char *string, int *index, int string_boundary);`
- `int math_roll_excecute_md(char *string, int *index, int string_boundary);`
- `int math_roll_excecute_pm(char *string, int *index, int string_boundary);`
- `int math_roll_itoa(int result, int *index, char *string);`
- `int math_roll_parse_brackets(char *string);`
- `int math_roll_validate(char *string);`
- `void math_calculate_j(char *string, int *string_boundary);`
- `void math_free_parse(char **parsed_strings);`

### Math/math_interval.cpp

- `const char *ft_interval_get_error_str(const ft_interval *interval) noexcept`
- `double ft_interval_midpoint(const ft_interval &interval) noexcept`
- `double ft_interval_radius(const ft_interval &interval) noexcept`
- `ft_interval ft_interval_add(const ft_interval &left_interval, const ft_interval &right_interval) noexcept`
- `ft_interval ft_interval_create(double lower, double upper) noexcept`
- `ft_interval ft_interval_divide(const ft_interval &left_interval, const ft_interval &right_interval) noexcept`
- `ft_interval ft_interval_from_measurement(double value, double absolute_error) noexcept`
- `ft_interval ft_interval_multiply(const ft_interval &left_interval, const ft_interval &right_interval) noexcept`
- `ft_interval ft_interval_propagate_linear(const ft_interval *components, const double *sensitivities, size_t component_count) noexcept`
- `ft_interval ft_interval_subtract(const ft_interval &left_interval, const ft_interval &right_interval) noexcept`
- `ft_interval ft_interval_widen(const ft_interval &interval, double absolute_error) noexcept`
- `int ft_interval_contains(const ft_interval &interval, double value) noexcept`
- `int ft_interval_get_error(const ft_interval *interval) noexcept`
- `static double ft_interval_max(double first_value, double second_value)`
- `static double ft_interval_min(double first_value, double second_value)`
- `static ft_interval ft_interval_propagate_input_error(const ft_interval &left_interval, const ft_interval &right_interval)`
- `static int ft_interval_spans_zero(const ft_interval &interval)`

### Math/math_interval.hpp

- `const char *ft_interval_get_error_str(const ft_interval *interval) noexcept;`
- `double ft_interval_midpoint(const ft_interval &interval) noexcept;`
- `double ft_interval_radius(const ft_interval &interval) noexcept;`
- `ft_interval ft_interval_add(const ft_interval &left_interval, const ft_interval &right_interval) noexcept;`
- `ft_interval ft_interval_create(double lower, double upper) noexcept;`
- `ft_interval ft_interval_divide(const ft_interval &left_interval, const ft_interval &right_interval) noexcept;`
- `ft_interval ft_interval_from_measurement(double value, double absolute_error) noexcept;`
- `ft_interval ft_interval_multiply(const ft_interval &left_interval, const ft_interval &right_interval) noexcept;`
- `ft_interval ft_interval_propagate_linear(const ft_interval *components, const double *sensitivities, size_t component_count) noexcept;`
- `ft_interval ft_interval_subtract(const ft_interval &left_interval, const ft_interval &right_interval) noexcept;`
- `ft_interval ft_interval_widen(const ft_interval &interval, double absolute_error) noexcept;`
- `int ft_interval_contains(const ft_interval &interval, double value) noexcept;`
- `int ft_interval_get_error(const ft_interval *interval) noexcept;`

### Math/math_lcm.cpp

- `int math_lcm(int first_number, int second_number)`
- `long long math_lcm(long long first_number, long long second_number)`
- `long math_lcm(long first_number, long second_number)`
- `static int math_lcm_check_overflow(unsigned long long quotient, unsigned long long magnitude_second, unsigned long long limit)`
- `static int math_lcm_report_result_int(int error_code, int return_value)`
- `static long long math_lcm_report_result_long_long(int error_code, long long return_value)`
- `static long math_lcm_report_result_long(int error_code, long return_value)`

### Math/math_max.cpp

- `double math_max(double first_number, double second_number)`
- `long long math_max(long long first_number, long long second_number)`
- `long math_max(long first_number, long second_number)`

### Math/math_min.cpp

- `double math_min(double first_number, double second_number)`
- `long long math_min(long long first_number, long long second_number)`
- `long math_min(long first_number, long second_number)`

### Math/math_polynomial.cpp

- `) , _mutex()`
- `const char *ft_cubic_spline::get_error_str() const noexcept`
- `double ft_cubic_spline_evaluate(const ft_cubic_spline &spline, double x) noexcept`
- `ft_cubic_spline ft_cubic_spline_build(const ft_vector<double> &x_values, const ft_vector<double> &y_values) noexcept`
- `int ft_cubic_spline::get_error() const noexcept`
- `int math_bezier_evaluate(const ft_vector<double> &control_points, double parameter, double &result) noexcept`
- `int math_bezier_evaluate_vector2(const ft_vector<vector2> &control_points, double parameter, vector2 &result) noexcept`
- `int math_integrate_simpson(math_unary_function function, void *user_data, double lower_bound, double upper_bound, double tolerance, double &result) noexcept`
- `int math_integrate_trapezoidal(math_unary_function function, void *user_data, double lower_bound, double upper_bound, size_t subdivisions, double &result) noexcept`
- `int math_polynomial_evaluate(const ft_vector<double> &coefficients, double x, double &result) noexcept`
- `int math_polynomial_find_root_newton(const ft_vector<double> &coefficients, double initial_guess, double tolerance, size_t max_iterations, double &root) noexcept`
- `int math_polynomial_lagrange_interpolate(const ft_vector<double> &x_values, const ft_vector<double> &y_values, double x, double &result) noexcept`
- `int math_polynomial_solve_quadratic(double a, double b, double c, double &root_one, double &root_two) noexcept`
- `pt_recursive_mutex *ft_cubic_spline::get_mutex_for_validation() const noexcept`
- `static int math_integrate_simpson_estimate(math_unary_function function, void *user_data, double lower_bound, double upper_bound, size_t subdivisions, double &result) noexcept`
- `static int math_integrate_trapezoidal_step(math_unary_function function, void *user_data, double lower_bound, double upper_bound, size_t subdivisions, double &result) noexcept`
- `static int math_polynomial_evaluate_with_derivative(const ft_vector<double> &coefficients, double x, double &value, double &derivative) noexcept`
- `static int math_polynomial_extract_coordinates(const ft_vector<vector2> &control_points, ft_vector<double> &x_coordinates, ft_vector<double> &y_coordinates) noexcept`
- `static int math_polynomial_validate_coefficients(const ft_vector<double> &coefficients) noexcept`
- `static int math_vector2_last_error(const vector2 &subject) noexcept`
- `static void math_polynomial_copy_vector(const ft_vector<double> &source, ft_vector<double> &destination, size_t count, int &error_code) noexcept`
- `static void math_polynomial_push_error(int error_code) noexcept`
- `void ft_cubic_spline::record_operation_error(int error_code) const noexcept`
- `void ft_cubic_spline::set_error(int error_code) const noexcept`

### Math/math_polynomial.hpp

- `double ft_cubic_spline_evaluate(const ft_cubic_spline &spline, double x) noexcept;`
- `ft_cubic_spline ft_cubic_spline_build(const ft_vector<double> &x_values, const ft_vector<double> &y_values) noexcept;`
- `int math_bezier_evaluate(const ft_vector<double> &control_points, double parameter, double &result) noexcept;`
- `int math_bezier_evaluate_vector2(const ft_vector<vector2> &control_points, double parameter, vector2 &result) noexcept;`
- `int math_integrate_simpson(math_unary_function function, void *user_data, double lower_bound, double upper_bound, double tolerance, double &result) noexcept;`
- `int math_integrate_trapezoidal(math_unary_function function, void *user_data, double lower_bound, double upper_bound, size_t subdivisions, double &result) noexcept;`
- `int math_polynomial_evaluate(const ft_vector<double> &coefficients, double x, double &result) noexcept;`
- `int math_polynomial_find_root_newton(const ft_vector<double> &coefficients, double initial_guess, double tolerance, size_t max_iterations, double &root) noexcept;`
- `int math_polynomial_lagrange_interpolate(const ft_vector<double> &x_values, const ft_vector<double> &y_values, double x, double &result) noexcept;`
- `int math_polynomial_solve_quadratic(double a, double b, double c, double &root_one, double &root_two) noexcept;`

### Math/math_roll.cpp

- `int *math_roll(const char *expression)`
- `static int *math_roll_report_error(int error_code, char *buffer)`
- `static int execute_roll_function(char *string, RollExecuteFunc func)`
- `static int math_roll_parse(char *string, int nested)`
- `void math_calculate_j(char *string, int *j)`

### Math/math_roll_parse_dice.cpp

- `int math_roll_excecute_droll(char *string, int *i, int j)`
- `static int math_handle_result_replacement(char *string, int *i, int x, int result)`

### Math/math_roll_parse_utils.cpp

- `int math_is_unary_sign(const char *string, int index)`
- `int math_process_sign(char *string, int *i, int j, int *error)`
- `static int math_calculate_result(int first_number, int second_number, char sign)`
- `static int math_check_add_sub_overflow(int first_number, int second_number, int error_code, int is_addition)`
- `static int math_check_div_overflow(int first_number, int second_number)`
- `static int math_check_mul_overflow(int first_number, int second_number)`
- `static int math_check_overflow(int first_number, int second_number, char sign)`
- `static void math_update_string(char *string, int *i, int x)`

### Math/math_roll_utilities.cpp

- `int math_check_string_number(char *string)`
- `int math_roll_convert_next(char *string, int i, int *error)`
- `int math_roll_convert_previous(char *string, int *i, int *error)`
- `int math_roll_itoa(int result, int *i, char *string)`
- `void math_free_parse(char **to_parse)`

### Math/math_roll_validate_string.cpp

- `int math_roll_validate(char *string)`
- `static int math_check_close_braces(char *string, int i, int open_braces, int *close_braces)`
- `static int math_check_dice(char *string, int i)`
- `static int math_check_divide_multiply(char *string, int i)`
- `static int math_check_open_braces(char *string, int i, int *open_braces)`
- `static int math_check_plus_minus(char *string, int i)`

### Math/math_roll_validate_utils.cpp

- `int math_roll_check_character(char c)`
- `int math_roll_check_number_previous(char *string, int i)`

### Math/math_signbit.cpp

- `int math_signbit(double number)`

### Math/math_sqrt.cpp

- `double math_sqrt(double number)`

### Math/math_statistics.cpp

- `double ft_geometric_mean(const double *values, int array_size)`
- `double ft_harmonic_mean(const double *values, int array_size)`
- `double ft_mean(const double *values, int array_size)`
- `double ft_median(const double *values, int array_size)`
- `double ft_mode(const double *values, int array_size)`
- `double ft_stddev(const double *values, int array_size)`
- `double ft_variance(const double *values, int array_size)`
- `static void sort_array(double *array, int array_size)`

### Math/roll.hpp

- `int *math_eval(const char *expression);`

### Networking/http2_client.cpp

- `bool http2_compress_headers(const ft_vector<http2_header_field> &headers, ft_string &out_block, int &error_code) noexcept`
- `bool http2_decode_frame(const unsigned char *buffer, size_t buffer_size, size_t &offset, http2_frame &out_frame, int &error_code) noexcept`
- `bool http2_decompress_headers(const ft_string &block, ft_vector<http2_header_field> &out_headers, int &error_code) noexcept`
- `bool http2_encode_frame(const http2_frame &frame, ft_string &out_buffer, int &error_code) noexcept`
- `bool http2_frame::copy_payload(ft_string &out_payload) const noexcept`
- `bool http2_frame::get_flags(uint8_t &out_flags) const noexcept`
- `bool http2_frame::get_stream_identifier(uint32_t &out_stream_identifier) const noexcept`
- `bool http2_frame::get_type(uint8_t &out_type) const noexcept`
- `bool http2_frame::is_thread_safe() const noexcept`
- `bool http2_frame::set_flags(uint8_t flags_value) noexcept`
- `bool http2_frame::set_payload(const ft_string &payload_value) noexcept`
- `bool http2_frame::set_payload_from_buffer(const char *buffer, size_t length) noexcept`
- `bool http2_frame::set_stream_identifier(uint32_t stream_identifier_value) noexcept`
- `bool http2_frame::set_type(uint8_t type_value) noexcept`
- `bool http2_header_field::assign(const ft_string &name_value, const ft_string &value_value) noexcept`
- `bool http2_header_field::assign_from_buffers(const char *name_buffer, size_t name_length, const char *value_buffer, size_t value_length) noexcept`
- `bool http2_header_field::assign_from_cstr(const char *name_value, const char *value_value) noexcept`
- `bool http2_header_field::copy_name(ft_string &out_name) const noexcept`
- `bool http2_header_field::copy_value(ft_string &out_value) const noexcept`
- `bool http2_header_field::set_name(const ft_string &name_value) noexcept`
- `bool http2_header_field::set_name_from_buffer(const char *buffer, size_t length) noexcept`
- `bool http2_header_field::set_name_from_cstr(const char *name_value) noexcept`
- `bool http2_header_field::set_value(const ft_string &value_value) noexcept`
- `bool http2_header_field::set_value_from_buffer(const char *buffer, size_t length) noexcept`
- `bool http2_header_field::set_value_from_cstr(const char *value_value) noexcept`
- `bool http2_select_alpn_protocol(SSL *ssl_session, bool &selected_http2, int &error_code) noexcept`
- `bool http2_settings_state::apply_remote_settings(const http2_frame &frame, http2_stream_manager &streams) noexcept`
- `bool http2_settings_state::apply_single_setting(uint16_t identifier, uint32_t value, http2_stream_manager &streams) noexcept`
- `bool http2_settings_state::get_enable_push() const noexcept`
- `bool http2_settings_state::update_local_initial_window(uint32_t new_window, http2_stream_manager &streams) noexcept`
- `bool http2_settings_state::update_remote_initial_window(uint32_t new_window, http2_stream_manager &streams) noexcept`
- `bool http2_stream_manager::append_data(uint32_t stream_identifier, const char *data, size_t length) noexcept`
- `bool http2_stream_manager::close_stream(uint32_t stream_identifier) noexcept`
- `bool http2_stream_manager::get_priority(uint32_t stream_identifier, uint32_t &dependency_identifier, uint8_t &weight, bool &exclusive) const noexcept`
- `bool http2_stream_manager::get_stream_buffer(uint32_t stream_identifier, ft_string &out_buffer) const noexcept`
- `bool http2_stream_manager::increase_local_window(uint32_t stream_identifier, uint32_t increment) noexcept`
- `bool http2_stream_manager::increase_remote_window(uint32_t stream_identifier, uint32_t increment) noexcept`
- `bool http2_stream_manager::is_thread_safe() const noexcept`
- `bool http2_stream_manager::open_stream(uint32_t stream_identifier) noexcept`
- `bool http2_stream_manager::record_connection_send(uint32_t length) noexcept`
- `bool http2_stream_manager::record_received_data(uint32_t stream_identifier, uint32_t length) noexcept`
- `bool http2_stream_manager::reserve_remote_connection_window(uint32_t length) noexcept`
- `bool http2_stream_manager::reserve_send_window(uint32_t stream_identifier, uint32_t length) noexcept`
- `bool http2_stream_manager::update_connection_local_window(uint32_t increment) noexcept`
- `bool http2_stream_manager::update_connection_remote_window(uint32_t increment) noexcept`
- `bool http2_stream_manager::update_local_initial_window(uint32_t new_window) noexcept`
- `bool http2_stream_manager::update_priority(uint32_t stream_identifier, uint32_t dependency_identifier, uint8_t weight, bool exclusive) noexcept`
- `bool http2_stream_manager::update_remote_initial_window(uint32_t new_window) noexcept`
- `bool http2_stream_manager::validate_receive_window(uint32_t stream_identifier, uint32_t length) noexcept`
- `const char *http2_frame::get_error_str() const noexcept`
- `const char *http2_header_field::get_error_str() const noexcept`
- `const char *http2_settings_state::get_error_str() const noexcept`
- `const char *http2_stream_manager::get_error_str() const noexcept`
- `int http2_frame::enable_thread_safety() noexcept`
- `int http2_frame::get_error() const noexcept`
- `int http2_frame::lock(bool *lock_acquired) const noexcept`
- `int http2_header_field::get_error() const noexcept`
- `int http2_header_field::lock(bool *lock_acquired) const noexcept`
- `int http2_header_field::prepare_thread_safety() noexcept`
- `int http2_settings_state::get_error() const noexcept`
- `int http2_stream_manager::enable_thread_safety() noexcept`
- `int http2_stream_manager::get_error() const noexcept`
- `int http2_stream_manager::lock(bool *lock_acquired) const noexcept`
- `int http2_stream_manager::prepare_thread_safety() noexcept`
- `uint32_t http2_settings_state::get_header_table_size() const noexcept`
- `uint32_t http2_settings_state::get_initial_local_window() const noexcept`
- `uint32_t http2_settings_state::get_initial_remote_window() const noexcept`
- `uint32_t http2_settings_state::get_max_concurrent_streams() const noexcept`
- `uint32_t http2_settings_state::get_max_frame_size() const noexcept`
- `uint32_t http2_settings_state::get_max_header_list_size() const noexcept`
- `uint32_t http2_stream_manager::get_connection_local_window() const noexcept`
- `uint32_t http2_stream_manager::get_connection_remote_window() const noexcept`
- `uint32_t http2_stream_manager::get_local_window(uint32_t stream_identifier) const noexcept`
- `uint32_t http2_stream_manager::get_remote_window(uint32_t stream_identifier) const noexcept`
- `void http2_frame::clear_payload() noexcept`
- `void http2_frame::disable_thread_safety() noexcept`
- `void http2_frame::set_error(int error_code) const noexcept`
- `void http2_frame::teardown_thread_safety() noexcept`
- `void http2_frame::unlock(bool lock_acquired) const noexcept`
- `void http2_header_field::clear() noexcept`
- `void http2_header_field::set_error(int error_code) const noexcept`
- `void http2_header_field::teardown_thread_safety() noexcept`
- `void http2_header_field::unlock(bool lock_acquired) const noexcept`
- `void http2_settings_state::set_error(int error_code) const noexcept`
- `void http2_stream_manager::disable_thread_safety() noexcept`
- `void http2_stream_manager::remove_stream_identifier(uint32_t stream_identifier) noexcept`
- `void http2_stream_manager::set_error(int error_code) const noexcept`
- `void http2_stream_manager::teardown_thread_safety() noexcept`
- `void http2_stream_manager::unlock(bool lock_acquired) const noexcept`

### Networking/http2_client.hpp

- `bool assign(const ft_string &name_value, const ft_string &value_value) noexcept;`
- `bool assign_from_buffers(const char *name_buffer, size_t name_length, const char *value_buffer, size_t value_length) noexcept;`
- `bool assign_from_cstr(const char *name_value, const char *value_value) noexcept;`
- `bool copy_name(ft_string &out_name) const noexcept;`
- `bool copy_value(ft_string &out_value) const noexcept;`
- `bool http2_compress_headers(const ft_vector<http2_header_field> &headers, ft_string &out_block, int &error_code) noexcept;`
- `bool http2_decode_frame(const unsigned char *buffer, size_t buffer_size, size_t &offset, http2_frame &out_frame, int &error_code) noexcept;`
- `bool http2_decompress_headers(const ft_string &block, ft_vector<http2_header_field> &out_headers, int &error_code) noexcept;`
- `bool http2_encode_frame(const http2_frame &frame, ft_string &out_buffer, int &error_code) noexcept;`
- `bool http2_select_alpn_protocol(SSL *ssl_session, bool &selected_http2, int &error_code) noexcept;`
- `bool set_name(const ft_string &name_value) noexcept;`
- `bool set_name_from_buffer(const char *buffer, size_t length) noexcept;`
- `bool set_name_from_cstr(const char *name_value) noexcept;`
- `bool set_value(const ft_string &value_value) noexcept;`
- `bool set_value_from_buffer(const char *buffer, size_t length) noexcept;`
- `bool set_value_from_cstr(const char *value_value) noexcept;`
- `const char *get_error_str() const noexcept;`
- `int get_error() const noexcept;`
- `int lock(bool *lock_acquired) const noexcept;`
- `int prepare_thread_safety() noexcept;`
- `public: http2_header_field() noexcept;`
- `void clear() noexcept;`
- `void set_error(int error_code) const noexcept;`
- `void teardown_thread_safety() noexcept;`
- `void unlock(bool lock_acquired) const noexcept;`

### Networking/http_client.cpp

- `int http_client_send_plain_request(int socket_fd, const char *buffer, size_t length)`
- `int http_client_send_ssl_request(SSL *ssl_connection, const char *buffer, size_t length)`
- `int http_get(const char *host, const char *path, ft_string &response, bool use_ssl, const char *custom_port)`
- `int http_get_stream(const char *host, const char *path, http_response_handler handler, bool use_ssl, const char *custom_port)`
- `int http_post(const char *host, const char *path, const ft_string &body, ft_string &response, bool use_ssl, const char *custom_port)`
- `size_t http_client_pool_debug_get_miss_count(void)`
- `size_t http_client_pool_debug_get_reuse_count(void)`
- `size_t http_client_pool_get_idle_count(void)`
- `static int http_client_establish_connection(const char *host, const char *port_string, bool use_ssl, http_client_active_connection &connection)`
- `static int http_client_finish_with_metrics(const char *method, const char *host, const char *path, size_t request_bytes, int result, t_monotonic_time_point start_time)`
- `static int http_client_initialize_ssl(int socket_fd, const char *host, SSL_CTX **ssl_context, SSL **ssl_connection)`
- `static int http_client_parse_status(const ft_string &headers)`
- `static int http_client_pool_acquire_connection(const char *host, const char *port, bool use_ssl, http_client_active_connection &connection, bool &reused)`
- `static int http_client_receive_stream(http_client_active_connection &connection, http_response_handler handler, bool &allow_keep_alive)`
- `static int http_client_stream_handle_header(http_stream_state &state)`
- `static int http_client_wait_for_socket_ready(int socket_fd, bool wait_for_write)`
- `static void http_client_buffering_adapter(int status_code, const ft_string &headers, const char *body_chunk, size_t chunk_size, bool finished)`
- `static void http_client_parse_header_metadata(http_stream_state &state)`
- `static void http_client_pool_disable_store(http_client_active_connection &connection)`
- `static void http_client_pool_dispose_entry(http_client_connection_entry &entry)`
- `static void http_client_pool_prune_locked(t_monotonic_time_point now)`
- `static void http_client_pool_release_connection(http_client_active_connection &connection, bool allow_reuse)`
- `static void http_client_pool_reset_active(http_client_active_connection &connection)`
- `static void http_client_reset_buffer_adapter_state(void)`
- `static void http_client_stream_state_init(http_stream_state &state, http_response_handler handler)`
- `static void http_client_to_lower(ft_string &value)`
- `static void http_client_trim_string(ft_string &value)`
- `void http_client_pool_debug_reset_counters(void)`
- `void http_client_pool_flush(void)`
- `void http_client_pool_set_max_idle(size_t max_idle)`

### Networking/http_client.hpp

- `int http_client_send_plain_request(int socket_fd, const char *buffer, size_t length);`
- `int http_client_send_ssl_request(SSL *ssl_connection, const char *buffer, size_t length);`
- `int http_get(const char *host, const char *path, ft_string &response, bool use_ssl = false, const char *custom_port = NULL);`
- `int http_get_stream(const char *host, const char *path, http_response_handler handler, bool use_ssl = false, const char *custom_port = NULL);`
- `int http_post(const char *host, const char *path, const ft_string &body, ft_string &response, bool use_ssl = false, const char *custom_port = NULL);`
- `size_t http_client_pool_debug_get_miss_count(void);`
- `size_t http_client_pool_debug_get_reuse_count(void);`
- `size_t http_client_pool_get_idle_count(void);`
- `void http_client_pool_debug_reset_counters(void);`
- `void http_client_pool_flush(void);`
- `void http_client_pool_set_max_idle(size_t max_idle);`

### Networking/http_server.cpp

- `const char *ft_http_server::get_error_str() const`
- `int ft_http_server::get_error() const`
- `int ft_http_server::run_once()`
- `int ft_http_server::run_once_locked(ft_unique_lock<pt_mutex> &guard)`
- `int ft_http_server::start(const char *ip, uint16_t port, int address_family, bool non_blocking)`
- `static bool http_server_request_wants_keep_alive(const ft_string &request, size_t header_length)`
- `static bool http_server_token_equals(const char *token_start, size_t token_length, const char *token)`
- `static char http_server_to_lower(char character)`
- `static int parse_request(const ft_string &request, ft_string &body, bool &is_post)`
- `static void http_server_record_metrics(const char *method, size_t request_bytes, size_t response_bytes, int status_code, int result, t_monotonic_time_point start_time)`
- `void ft_http_server::set_error(int error_code) const`

### Networking/http_server.hpp

- `const char *get_error_str() const;`
- `int get_error() const;`
- `int run_once();`
- `int run_once_locked(ft_unique_lock<pt_mutex> &guard);`
- `int start(const char *ip, uint16_t port, int address_family = AF_INET, bool non_blocking = false);`
- `public: ft_http_server();`
- `void set_error(int error_code) const;`

### Networking/networking.cpp

- `const char *SocketConfig::get_error_str()`
- `int SocketConfig::get_error()`
- `void SocketConfig::set_error(int error_code) noexcept`

### Networking/networking.hpp

- `bool networking_dns_resolve(const char *host, const char *service, int family, int socktype, int protocol, int flags, ft_vector<networking_resolved_address> &out_addresses) noexcept;`
- `bool networking_dns_resolve_first(const char *host, const char *service, int family, int socktype, int protocol, int flags, networking_resolved_address &out_address) noexcept;`
- `int event_loop_add_socket(event_loop *loop, int socket_fd, bool is_write);`
- `int event_loop_lock(event_loop *loop, bool *lock_acquired);`
- `int event_loop_prepare_thread_safety(event_loop *loop);`
- `int event_loop_remove_socket(event_loop *loop, int socket_fd, bool is_write);`
- `int event_loop_run(event_loop *loop, int timeout_milliseconds);`
- `int networking_check_socket_after_send(int socket_fd);`
- `int networking_check_ssl_after_send(SSL *ssl_connection);`
- `int nw_accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`
- `int nw_close(int sockfd);`
- `int nw_connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`
- `int nw_inet_pton(int family, const char *ip_address, void *destination);`
- `int nw_listen(int sockfd, int backlog);`
- `int nw_poll(int *read_file_descriptors, int read_count, int *write_file_descriptors, int write_count, int timeout_milliseconds);`
- `int nw_set_nonblocking(int socket_fd);`
- `int nw_shutdown(int sockfd, int how);`
- `int nw_socket(int domain, int type, int protocol);`
- `int socket_config_lock(const SocketConfig *config, bool *lock_acquired);`
- `int socket_config_prepare_thread_safety(SocketConfig *config);`
- `int udp_event_loop_wait_read(event_loop *loop, udp_socket &socket, int timeout_milliseconds);`
- `int udp_event_loop_wait_write(event_loop *loop, udp_socket &socket, int timeout_milliseconds);`
- `ssize_t nw_recv(int sockfd, void *buf, size_t len, int flags);`
- `ssize_t nw_recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);`
- `ssize_t nw_send(int sockfd, const void *buf, size_t len, int flags);`
- `ssize_t nw_sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);`
- `ssize_t udp_event_loop_receive(event_loop *loop, udp_socket &socket, void *buffer, size_t size, int flags, struct sockaddr *source_address, socklen_t *address_length, int timeout_milliseconds);`
- `ssize_t udp_event_loop_send(event_loop *loop, udp_socket &socket, const void *data, size_t size, int flags, const struct sockaddr *destination_address, socklen_t address_length, int timeout_milliseconds);`
- `void event_loop_clear(event_loop *loop);`
- `void event_loop_init(event_loop *loop);`
- `void event_loop_teardown_thread_safety(event_loop *loop);`
- `void event_loop_unlock(event_loop *loop, bool lock_acquired);`
- `void networking_dns_clear_cache(void) noexcept;`
- `void networking_dns_set_error(int resolver_status) noexcept;`
- `void nw_set_socket_hook(t_nw_socket_hook hook);`
- `void socket_config_teardown_thread_safety(SocketConfig *config);`
- `void socket_config_unlock(const SocketConfig *config, bool lock_acquired);`

### Networking/networking_dns_resolver.cpp

- `bool networking_dns_resolve(const char *host, const char *service, int family, int socktype, int protocol, int flags, ft_vector<networking_resolved_address> &out_addresses) noexcept`
- `bool networking_dns_resolve_first(const char *host, const char *service, int family, int socktype, int protocol, int flags, networking_resolved_address &out_address) noexcept`
- `static bool networking_dns_append_literal(ft_string &target, const char *literal) noexcept`
- `static bool networking_dns_append_separator(ft_string &target) noexcept`
- `static bool networking_dns_append_string(ft_string &target, const ft_string &value) noexcept`
- `static bool networking_dns_copy_addresses(const ft_vector<networking_resolved_address> &source, ft_vector<networking_resolved_address> &destination) noexcept`
- `static int networking_dns_cache_lock(ft_unique_lock<pt_mutex> &cache_lock) noexcept`
- `static int networking_dns_cache_unlock(ft_unique_lock<pt_mutex> &cache_lock) noexcept`
- `void networking_dns_clear_cache(void) noexcept`
- `void networking_dns_set_error(int resolver_status) noexcept`

### Networking/networking_event_loop.cpp

- `int event_loop_add_socket(event_loop *loop, int socket_fd, bool is_write)`
- `int event_loop_lock(event_loop *loop, bool *lock_acquired)`
- `int event_loop_prepare_thread_safety(event_loop *loop)`
- `int event_loop_remove_socket(event_loop *loop, int socket_fd, bool is_write)`
- `int event_loop_run(event_loop *loop, int timeout_milliseconds)`
- `void event_loop_clear(event_loop *loop)`
- `void event_loop_teardown_thread_safety(event_loop *loop)`
- `void event_loop_unlock(event_loop *loop, bool lock_acquired)`

### Networking/networking_quic_experimental.cpp

- `bool networking_quic_disable_experimental() noexcept`
- `bool networking_quic_enable_experimental() noexcept`
- `bool networking_quic_is_experimental_enabled() noexcept`
- `bool quic_experimental_session::configure(SSL *ssl_session, const quic_feature_configuration &configuration, bool outbound) noexcept`
- `bool quic_experimental_session::decrypt_datagram(const ft_vector<unsigned char> &ciphertext, const unsigned char *associated_data, size_t associated_data_length, ft_vector<unsigned char> &out_plaintext) noexcept`
- `bool quic_experimental_session::derive_keys(SSL *ssl_session, bool outbound) noexcept`
- `bool quic_experimental_session::encrypt_datagram(const quic_datagram_plaintext &plaintext, ft_vector<unsigned char> &out_ciphertext) noexcept`
- `bool quic_experimental_session::ensure_configured() const noexcept`
- `bool quic_experimental_session::ensure_feature_enabled() const noexcept`
- `bool quic_experimental_session::get_feature_configuration(quic_feature_configuration &out_configuration) const noexcept`
- `bool quic_experimental_session::prepare_nonce(uint64_t sequence_number, const ft_vector<unsigned char> &base_iv, ft_vector<unsigned char> &out_nonce) noexcept`
- `const char *quic_experimental_session::get_error_str() const noexcept`
- `int quic_experimental_session::get_error() const noexcept`
- `void quic_experimental_session::clear_key_material() noexcept`
- `void quic_experimental_session::set_error(int error_code) const noexcept`

### Networking/networking_quic_experimental.hpp

- `bool networking_quic_disable_experimental() noexcept;`
- `bool networking_quic_enable_experimental() noexcept;`
- `bool networking_quic_is_experimental_enabled() noexcept;`

### Networking/networking_send_utils.cpp

- `int networking_check_ssl_after_send(SSL *ssl_connection)`

### Networking/networking_setup_server.cpp

- `int ft_socket::bind_socket(const SocketConfig &config)`
- `int ft_socket::configure_address(const SocketConfig &config)`
- `int ft_socket::create_socket(const SocketConfig &config)`
- `int ft_socket::join_multicast_group(const SocketConfig &config)`
- `int ft_socket::listen_socket(const SocketConfig &config)`
- `int ft_socket::set_non_blocking(const SocketConfig &config)`
- `int ft_socket::set_reuse_address(const SocketConfig &config)`
- `int ft_socket::set_timeouts(const SocketConfig &config)`
- `int ft_socket::setup_server(const SocketConfig &config)`
- `static inline int set_nonblocking_platform(int fd)`
- `static inline int set_timeout_recv(int fd, int ms)`
- `static inline int set_timeout_send(int fd, int ms)`
- `static void networking_finalize_guard(ft_unique_lock<pt_mutex> &guard) noexcept`
- `void ft_socket::set_error(int error_code) const noexcept`

### Networking/networking_setup_udp.cpp

- `bool udp_socket::close_socket()`
- `const char *udp_socket::get_error_str() const`
- `const struct sockaddr_storage &udp_socket::get_address() const`
- `int udp_socket::bind_socket(const SocketConfig &config)`
- `int udp_socket::configure_address(const SocketConfig &config)`
- `int udp_socket::connect_socket(const SocketConfig &config)`
- `int udp_socket::create_socket(const SocketConfig &config)`
- `int udp_socket::get_error() const`
- `int udp_socket::get_fd() const`
- `int udp_socket::initialize(const SocketConfig &config)`
- `int udp_socket::set_non_blocking(const SocketConfig &config)`
- `int udp_socket::set_timeouts(const SocketConfig &config)`
- `ssize_t udp_socket::receive_from(void *buffer, size_t size, int flags, struct sockaddr *src_addr, socklen_t *addr_len)`
- `ssize_t udp_socket::send_to(const void *data, size_t size, int flags, const struct sockaddr *dest_addr, socklen_t addr_len)`
- `static inline int set_timeout_recv(int fd, int ms)`
- `static inline int set_timeout_send(int fd, int ms)`
- `void udp_socket::set_error(int error_code) const noexcept`

### Networking/networking_socket_class.cpp

- `bool ft_socket::close_socket()`
- `bool ft_socket::close_socket_locked()`
- `bool ft_socket::disconnect_client(int fd)`
- `bool ft_socket::is_client_connected(int fd) const`
- `const char* ft_socket::get_error_str() const`
- `const struct sockaddr_storage &ft_socket::get_address() const`
- `int ft_socket::accept_connection()`
- `int ft_socket::get_error() const`
- `int ft_socket::get_fd() const`
- `int ft_socket::initialize(const SocketConfig &config)`
- `int ft_socket::lock_pair(const ft_socket &first, const ft_socket &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard)`
- `size_t ft_socket::get_client_count() const`
- `ssize_t ft_socket::broadcast_data(const void *data, size_t size, int flags)`
- `ssize_t ft_socket::broadcast_data(const void *data, size_t size, int flags, int exception)`
- `ssize_t ft_socket::receive_data(void *buffer, size_t size, int flags)`
- `ssize_t ft_socket::receive_data_locked(void *buffer, size_t size, int flags)`
- `ssize_t ft_socket::send_all(const void *data, size_t size, int flags)`
- `ssize_t ft_socket::send_all_locked(const void *data, size_t size, int flags)`
- `ssize_t ft_socket::send_data(const void *data, size_t size, int flags)`
- `ssize_t ft_socket::send_data(const void *data, size_t size, int flags, int fd)`
- `ssize_t ft_socket::send_data_locked(const void *data, size_t size, int flags)`
- `static int networking_pop_guard_error(const ft_unique_lock<pt_mutex> &guard) noexcept`
- `static void socket_finalize_guard(ft_unique_lock<pt_mutex> &guard) noexcept`
- `void ft_socket::disconnect_all_clients()`
- `void ft_socket::reset_to_empty_state()`
- `void ft_socket::reset_to_empty_state_locked()`

### Networking/networking_socket_config_thread_safety.cpp

- `int socket_config_lock(const SocketConfig *config, bool *lock_acquired)`
- `void socket_config_teardown_thread_safety(SocketConfig *config)`
- `void socket_config_unlock(const SocketConfig *config, bool lock_acquired)`

### Networking/networking_socket_wrapper_functions.cpp

- `int nw_accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)`
- `int nw_close(int sockfd)`
- `int nw_connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)`
- `int nw_inet_pton(int family, const char *ip_address, void *destination)`
- `int nw_listen(int sockfd, int backlog)`
- `int nw_shutdown(int sockfd, int how)`
- `int nw_socket(int domain, int type, int protocol)`
- `ssize_t nw_recv(int sockfd, void *buf, size_t len, int flags)`
- `ssize_t nw_recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen)`
- `ssize_t nw_send(int sockfd, const void *buf, size_t len, int flags)`
- `ssize_t nw_sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen)`
- `static inline int accept_platform(int sockfd, struct sockaddr *addr, socklen_t *addrlen)`
- `static inline int connect_platform(int sockfd, const struct sockaddr *addr, socklen_t len)`
- `static inline int listen_platform(int sockfd, int backlog)`
- `static inline int shutdown_platform(int sockfd, int how)`
- `static inline int socket_platform(int domain, int type, int protocol)`
- `static inline ssize_t recv_platform(int sockfd, void *buf, size_t len, int flags)`
- `static inline ssize_t recvfrom_platform(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen)`
- `static inline ssize_t send_platform(int sockfd, const void *buf, size_t len, int flags)`
- `static inline ssize_t sendto_platform(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen)`
- `void nw_set_socket_hook(t_nw_socket_hook hook)`

### Networking/networking_ssl_wrapper.cpp

- `ssize_t nw_ssl_read(SSL *ssl, void *buf, size_t len)`
- `ssize_t nw_ssl_write(SSL *ssl, const void *buf, size_t len)`
- `static ssize_t ssl_report(int error_code, ssize_t result)`
- `static ssize_t ssl_write_platform(SSL *ssl, const void *buf, size_t len)`

### Networking/networking_tls_aead.cpp

- `bool networking_tls_export_aead_keys(SSL *ssl_session, bool outbound, ft_vector<unsigned char> &send_key, ft_vector<unsigned char> &send_iv, ft_vector<unsigned char> &receive_key, ft_vector<unsigned char> &receive_iv)`
- `bool networking_tls_initialize_aead_contexts(SSL *ssl_session, bool outbound, encryption_aead_context &send_context, encryption_aead_context &receive_context, ft_vector<unsigned char> &send_iv, ft_vector<unsigned char> &receive_iv)`
- `static bool networking_tls_prepare_buffer(ft_vector<unsigned char> &buffer, size_t length)`

### Networking/networking_tls_aead.hpp

- `bool networking_tls_initialize_aead_contexts(SSL *ssl_session, bool outbound, encryption_aead_context &send_context, encryption_aead_context &receive_context, ft_vector<unsigned char> &send_iv, ft_vector<unsigned char> &receive_iv);`

### Networking/networking_udp_event_loop.cpp

- `int udp_event_loop_wait_read(event_loop *loop, udp_socket &socket, int timeout_milliseconds)`
- `int udp_event_loop_wait_write(event_loop *loop, udp_socket &socket, int timeout_milliseconds)`
- `ssize_t udp_event_loop_receive(event_loop *loop, udp_socket &socket, void *buffer, size_t size, int flags, struct sockaddr *source_address, socklen_t *address_length, int timeout_milliseconds)`
- `ssize_t udp_event_loop_send(event_loop *loop, udp_socket &socket, const void *data, size_t size, int flags, const struct sockaddr *destination_address, socklen_t address_length, int timeout_milliseconds)`

### Networking/socket_class.hpp

- `bool close_socket();`
- `bool close_socket_locked();`
- `bool disconnect_client(int fd);`
- `bool is_client_connected(int fd) const;`
- `const char *get_error_str() const;`
- `const struct sockaddr_storage &get_address() const;`
- `int accept_connection();`
- `int bind_socket(const SocketConfig &config);`
- `int configure_address(const SocketConfig &config);`
- `int create_socket(const SocketConfig &config);`
- `int get_error() const;`
- `int get_fd() const;`
- `int initialize(const SocketConfig &config);`
- `int join_multicast_group(const SocketConfig &config);`
- `int listen_socket(const SocketConfig &config);`
- `int set_non_blocking(const SocketConfig &config);`
- `int set_reuse_address(const SocketConfig &config);`
- `int set_timeouts(const SocketConfig &config);`
- `int setup_client(const SocketConfig &config);`
- `private: int setup_server(const SocketConfig &config);`
- `public: ft_socket(const SocketConfig &config);`
- `size_t get_client_count() const;`
- `ssize_t broadcast_data(const void *data, size_t size, int flags);`
- `ssize_t broadcast_data(const void *data, size_t size, int flags, int exception);`
- `ssize_t receive_data(void *buffer, size_t size, int flags = 0);`
- `ssize_t receive_data_locked(void *buffer, size_t size, int flags);`
- `ssize_t send_all(const void *data, size_t size, int flags = 0);`
- `ssize_t send_all_locked(const void *data, size_t size, int flags);`
- `ssize_t send_data(const void *data, size_t size, int flags = 0);`
- `ssize_t send_data(const void *data, size_t size, int flags, int fd);`
- `ssize_t send_data_locked(const void *data, size_t size, int flags);`
- `static int lock_pair(const ft_socket &first, const ft_socket &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard);`
- `static void sleep_backoff();`
- `void disconnect_all_clients();`
- `void reset_to_empty_state();`
- `void reset_to_empty_state_locked();`
- `void set_error(int error_code) const noexcept;`

### Networking/socket_handle.cpp

- `bool ft_socket_handle::close()`
- `bool ft_socket_handle::is_valid() const`
- `bool ft_socket_handle::reset(int socket_fd)`
- `const char *ft_socket_handle::get_error_str() const`
- `int ft_socket_handle::get() const`
- `int ft_socket_handle::get_error() const`
- `int ft_socket_runtime_acquire()`
- `static bool &ft_socket_runtime_initialized()`
- `static int &ft_socket_runtime_reference_count()`
- `void ft_socket_runtime_release()`

### Networking/socket_handle.hpp

- `void ft_socket_runtime_release();`

### Networking/ssl_wrapper.hpp

- `ssize_t nw_ssl_read(SSL *ssl, void *buf, size_t len);`

### Networking/udp_socket.hpp

- `bool close_socket();`
- `const char *get_error_str() const;`
- `const struct sockaddr_storage &get_address() const;`
- `int bind_socket(const SocketConfig &config);`
- `int configure_address(const SocketConfig &config);`
- `int connect_socket(const SocketConfig &config);`
- `int get_error() const;`
- `int get_fd() const;`
- `int initialize(const SocketConfig &config);`
- `int set_non_blocking(const SocketConfig &config);`
- `int set_timeouts(const SocketConfig &config);`
- `private: int create_socket(const SocketConfig &config);`
- `public: udp_socket();`
- `ssize_t receive_from(void *buffer, size_t size, int flags, struct sockaddr *src_addr, socklen_t *addr_len);`
- `ssize_t send_to(const void *data, size_t size, int flags, const struct sockaddr *dest_addr, socklen_t addr_len);`
- `void set_error(int error_code) const noexcept;`

### Networking/websocket_client.cpp

- `const char *ft_websocket_client::get_error_str() const`
- `int ft_websocket_client::close_locked(ft_unique_lock<pt_mutex> &guard)`
- `int ft_websocket_client::connect(const char *host, uint16_t port, const char *path)`
- `int ft_websocket_client::get_error() const`
- `int ft_websocket_client::perform_handshake_locked(const char *host, const char *path, ft_unique_lock<pt_mutex> &guard)`
- `int ft_websocket_client::receive_text(ft_string &message)`
- `int ft_websocket_client::receive_text_locked(ft_string &message, ft_unique_lock<pt_mutex> &guard)`
- `int ft_websocket_client::send_pong_locked(const unsigned char *payload, std::size_t length, ft_unique_lock<pt_mutex> &guard)`
- `int ft_websocket_client::send_text(const ft_string &message)`
- `int ft_websocket_client::send_text_locked(const ft_string &message, ft_unique_lock<pt_mutex> &guard)`
- `void ft_websocket_client::close()`
- `void ft_websocket_client::set_error(int error_code) const`

### Networking/websocket_client.hpp

- `const char *get_error_str() const;`
- `int close_locked(ft_unique_lock<pt_mutex> &guard);`
- `int connect(const char *host, uint16_t port, const char *path);`
- `int get_error() const;`
- `int perform_handshake_locked(const char *host, const char *path, ft_unique_lock<pt_mutex> &guard);`
- `int receive_text(ft_string &message);`
- `int receive_text_locked(ft_string &message, ft_unique_lock<pt_mutex> &guard);`
- `int send_pong_locked(const unsigned char *payload, std::size_t length, ft_unique_lock<pt_mutex> &guard);`
- `int send_text(const ft_string &message);`
- `int send_text_locked(const ft_string &message, ft_unique_lock<pt_mutex> &guard);`
- `public: ft_websocket_client();`
- `void close();`
- `void set_error(int error_code) const;`

### Networking/websocket_server.cpp

- `bool ft_websocket_server::connection_supports_permessage_deflate_locked(int client_fd) const`
- `const char *ft_websocket_server::get_error_str() const`
- `int ft_websocket_server::get_error() const`
- `int ft_websocket_server::get_port(unsigned short &port_value) const`
- `int ft_websocket_server::perform_handshake_locked(int client_fd, ft_unique_lock<pt_mutex> &guard)`
- `int ft_websocket_server::receive_frame_locked(int client_fd, ft_string &message, ft_unique_lock<pt_mutex> &guard)`
- `int ft_websocket_server::run_once(int &client_fd, ft_string &message)`
- `int ft_websocket_server::send_pong_locked(int client_fd, const unsigned char *payload, std::size_t length, ft_unique_lock<pt_mutex> &guard)`
- `int ft_websocket_server::send_text(int client_fd, const ft_string &message)`
- `int ft_websocket_server::start(const char *ip, uint16_t port, int address_family, bool non_blocking)`
- `static bool websocket_header_contains_token(const ft_string &request, const char *header_name, const char *token)`
- `static const char *websocket_find_header_value(const ft_string &request, const char *header_name, std::size_t &value_length)`
- `static int websocket_append_bytes(ft_vector<unsigned char> &buffer, const unsigned char *data, std::size_t length)`
- `static int websocket_case_insensitive_compare(const char *left, const char *right, std::size_t length)`
- `static int websocket_permessage_deflate_deflate(const ft_string &message, ft_vector<unsigned char> &compressed)`
- `static int websocket_permessage_deflate_inflate(const unsigned char *payload, std::size_t payload_length, ft_string &message)`
- `static void compute_accept_key(const ft_string &key, ft_string &accept)`
- `void ft_websocket_server::finalize_lock(ft_unique_lock<pt_mutex> &guard) noexcept`
- `void ft_websocket_server::remove_connection_state_locked(int client_fd)`
- `void ft_websocket_server::set_error(int error_code) const`
- `void ft_websocket_server::store_connection_state_locked(int client_fd, bool permessage_deflate_enabled)`

### Observability/observability_game_metrics.cpp

- `const char *observability_game_metrics_get_error_str(void)`
- `int observability_game_metrics_get_error(void)`
- `int observability_game_metrics_initialize(ft_game_observability_exporter exporter)`
- `int observability_game_metrics_shutdown(void)`
- `static void observability_game_metrics_set_error(int error_code)`
- `void observability_game_metrics_record(const ft_game_observability_sample &sample)`

### Observability/observability_game_metrics.hpp

- `const char *observability_game_metrics_get_error_str(void);`
- `int observability_game_metrics_get_error(void);`
- `int observability_game_metrics_initialize(ft_game_observability_exporter exporter);`
- `int observability_game_metrics_shutdown(void);`
- `void observability_game_metrics_record(const ft_game_observability_sample &sample);`

### Observability/observability_networking_metrics.cpp

- `const char *observability_networking_metrics_get_error_str(void)`
- `int observability_networking_metrics_get_error(void)`
- `int observability_networking_metrics_initialize(ft_networking_observability_exporter exporter)`
- `int observability_networking_metrics_shutdown(void)`
- `static void observability_networking_metrics_set_error(int error_code)`
- `void observability_networking_metrics_record(const ft_networking_observability_sample &sample)`

### Observability/observability_networking_metrics.hpp

- `const char *observability_networking_metrics_get_error_str(void);`
- `int observability_networking_metrics_get_error(void);`
- `int observability_networking_metrics_initialize(ft_networking_observability_exporter exporter);`
- `int observability_networking_metrics_shutdown(void);`
- `void observability_networking_metrics_record(const ft_networking_observability_sample &sample);`

### Observability/observability_task_scheduler_bridge.cpp

- `const char *observability_task_scheduler_bridge_get_error_str(void)`
- `int observability_task_scheduler_bridge_get_error(void)`
- `int observability_task_scheduler_bridge_initialize(ft_otel_span_exporter exporter)`
- `int observability_task_scheduler_bridge_shutdown(void)`
- `static ft_otel_span_metrics observability_span_metrics_create(void)`
- `static ft_otel_span_state observability_span_state_create(void)`
- `static void observability_bridge_set_error(int error)`
- `static void observability_task_scheduler_bridge_trace_sink(const ft_task_trace_event &event)`

### Observability/observability_task_scheduler_bridge.hpp

- `const char *observability_task_scheduler_bridge_get_error_str(void);`
- `int observability_task_scheduler_bridge_get_error(void);`
- `int observability_task_scheduler_bridge_initialize(ft_otel_span_exporter exporter);`
- `int observability_task_scheduler_bridge_shutdown(void);`

### PThread/condition.hpp

- `int pt_cond_broadcast(pthread_cond_t *condition);`
- `int pt_cond_destroy(pthread_cond_t *condition);`
- `int pt_cond_init(pthread_cond_t *condition, const pthread_condattr_t *attributes);`
- `int pt_cond_signal(pthread_cond_t *condition);`
- `int pt_cond_wait(pthread_cond_t *condition, pthread_mutex_t *mutex);`

### PThread/lock_guard.hpp

- `const char *get_error_str() const;`
- `int get_error() const;`
- `public: explicit ft_lock_guard(MutexType &mutex);`
- `static inline ft_recursive_mutex_pair_lock_order ft_recursive_mutex_lock_pair( pt_recursive_mutex &first_mutex, pt_recursive_mutex &second_mutex)`
- `static inline void ft_recursive_mutex_unlock_pair(pt_recursive_mutex &first_mutex, pt_recursive_mutex &second_mutex, ft_recursive_mutex_pair_lock_order order)`
- `template <typename MutexType> const char *ft_lock_guard<MutexType>::get_error_str() const`
- `template <typename MutexType> ft_lock_guard<MutexType>::ft_lock_guard(MutexType &mutex) : _mutex(&mutex), _owns_lock(false), _error_code(FT_ERR_SUCCESSS)`
- `template <typename MutexType> ft_lock_guard<MutexType>::~ft_lock_guard()`
- `template <typename MutexType> int ft_lock_guard<MutexType>::get_error() const`
- `template <typename MutexType> void ft_lock_guard<MutexType>::record_error(int error, bool push_global) const`
- `template <typename MutexType> void ft_lock_guard<MutexType>::set_error(int error) const`
- `void record_error(int error, bool push_global = true) const;`
- `void set_error(int error) const;`

### PThread/mutex.hpp

- `bool ensure_native_mutex() const;`
- `bool is_owned_by_thread(pthread_t thread_id) const;`
- `bool lockState() const;`
- `const char *operation_error_error_str_at(ft_size_t index) const;`
- `const char *operation_error_last_error_str() const;`
- `ft_size_t operation_error_depth() const;`
- `ft_size_t operation_error_find_by_id(unsigned long long operation_id) const;`
- `int lock(pthread_t thread_id) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `int lock_state(bool *lock_acquired) const;`
- `int operation_error_error_at(ft_size_t index) const;`
- `int operation_error_last_error() const;`
- `int operation_error_pop_last() const;`
- `int operation_error_pop_newest() const;`
- `int try_lock(pthread_t thread_id) const;`
- `int try_lock_for(pthread_t thread_id, const struct timespec &relative_time) const;`
- `int try_lock_until(pthread_t thread_id, const struct timespec &absolute_time) const;`
- `int unlock(pthread_t thread_id) const;`
- `int unlock_internal(bool lock_acquired) const;`
- `pthread_mutex_t *get_native_mutex() const;`
- `public: pt_mutex();`
- `unsigned long long operation_error_get_id_at(ft_size_t index) const;`
- `unsigned long long operation_error_push_entry(int error_code) const;`
- `unsigned long long operation_error_push_entry_with_id(int error_code, unsigned long long operation_id) const;`
- `void operation_error_pop_all() const;`
- `void operation_error_push(int error_code) const;`
- `void teardown_thread_safety();`
- `void unlock_state(bool lock_acquired) const;`

### PThread/pthread.hpp

- `bool pt_atomic_compare_exchange(std::atomic<int>& atomic_variable, int& expected_value, int desired_value);`
- `const char *pt_rwlock_strategy_get_error_str(const t_pt_rwlock *rwlock);`
- `int pt_atomic_fetch_add(std::atomic<int>& atomic_variable, int increment_value);`
- `int pt_atomic_load(const std::atomic<int>& atomic_variable);`
- `int pt_rwlock_destroy(pthread_rwlock_t *rwlock);`
- `int pt_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attributes);`
- `int pt_rwlock_rdlock(pthread_rwlock_t *rwlock);`
- `int pt_rwlock_strategy_destroy(t_pt_rwlock *rwlock);`
- `int pt_rwlock_strategy_get_error(const t_pt_rwlock *rwlock);`
- `int pt_rwlock_strategy_init(t_pt_rwlock *rwlock, t_pt_rwlock_strategy strategy);`
- `int pt_rwlock_strategy_rdlock(t_pt_rwlock *rwlock);`
- `int pt_rwlock_strategy_unlock(t_pt_rwlock *rwlock);`
- `int pt_rwlock_strategy_wrlock(t_pt_rwlock *rwlock);`
- `int pt_rwlock_unlock(pthread_rwlock_t *rwlock);`
- `int pt_rwlock_wrlock(pthread_rwlock_t *rwlock);`
- `int pt_thread_cancel(pthread_t thread);`
- `int pt_thread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);`
- `int pt_thread_detach(pthread_t thread);`
- `int pt_thread_equal(pthread_t thread1, pthread_t thread2);`
- `int pt_thread_join(pthread_t thread, void **retval);`
- `int pt_thread_sleep(unsigned int milliseconds);`
- `int pt_thread_timed_join(pthread_t thread, void **retval, long timeout_ms);`
- `int pt_thread_wait_uint32(std::atomic<uint32_t> *address, uint32_t expected_value);`
- `int pt_thread_wake_one_uint32(std::atomic<uint32_t> *address);`
- `int pt_thread_yield();`
- `pt_thread_id_type pt_thread_self();`
- `t_thread_id ft_this_thread_get_id();`
- `void ft_this_thread_sleep_for(t_duration_milliseconds duration);`
- `void ft_this_thread_sleep_until(t_monotonic_time_point time_point);`
- `void ft_this_thread_yield();`
- `void pt_atomic_store(std::atomic<int>& atomic_variable, int desired_value);`

### PThread/pthread_condition.cpp

- `int pt_cond_broadcast(pthread_cond_t *condition)`
- `int pt_cond_destroy(pthread_cond_t *condition)`
- `int pt_cond_signal(pthread_cond_t *condition)`
- `int pt_cond_wait(pthread_cond_t *condition, pthread_mutex_t *mutex)`

### PThread/pthread_condition_variable.cpp

- `bool pt_condition_variable::is_thread_safe() const`
- `const char *pt_condition_variable::get_error_str() const`
- `int pt_condition_variable::broadcast()`
- `int pt_condition_variable::enable_thread_safety()`
- `int pt_condition_variable::get_error() const`
- `int pt_condition_variable::lock_internal(bool *lock_acquired) const`
- `int pt_condition_variable::lock_state(bool *lock_acquired) const`
- `int pt_condition_variable::signal()`
- `int pt_condition_variable::wait(pt_mutex &mutex)`
- `int pt_condition_variable::wait_for(pt_mutex &mutex, const struct timespec &relative_time)`
- `int pt_condition_variable::wait_until(pt_mutex &mutex, const struct timespec &absolute_time)`
- `void pt_condition_variable::disable_thread_safety()`
- `void pt_condition_variable::set_error(int error) const`
- `void pt_condition_variable::teardown_thread_safety()`
- `void pt_condition_variable::unlock_internal(bool lock_acquired) const`
- `void pt_condition_variable::unlock_state(bool lock_acquired) const`

### PThread/pthread_errno_guard.hpp

- `public: pt_errno_guard(GuardType &first_guard, GuardType &second_guard) noexcept;`
- `static int pt_errno_guard_capture_error() noexcept`
- `template <typename GuardType> pt_errno_guard<GuardType>::pt_errno_guard(GuardType &first_guard, GuardType &second_guard) noexcept : _first_guard(&first_guard) , _second_guard(&second_guard) , _previous_error(ft_global_error_stack_peek_last_error())`
- `template <typename GuardType> pt_errno_guard<GuardType>::~pt_errno_guard() noexcept`
- `template <typename GuardType> void pt_errno_guard<GuardType>::dismiss() noexcept`
- `void dismiss() noexcept;`

### PThread/pthread_lock_tracking.cpp

- `bool pt_lock_tracking::detect_cycle(const s_pt_thread_lock_info *origin, pthread_mutex_t *requested_mutex, pt_mutex_vector *visited_mutexes, pt_thread_vector *visited_threads)`
- `bool pt_lock_tracking::ensure_registry_mutex_initialized(int *error_code)`
- `bool pt_lock_tracking::get_thread_state(pt_thread_id_type thread_identifier, s_pt_lock_tracking_thread_state &state)`
- `bool pt_lock_tracking::notify_wait(pt_thread_id_type thread_identifier, pthread_mutex_t *requested_mutex, const pt_mutex_vector &owned_mutexes)`
- `bool pt_lock_tracking::snapshot_waiters(pt_lock_wait_snapshot_vector &snapshot)`
- `bool pt_lock_tracking::vector_contains_mutex(const pt_mutex_vector &mutexes, pthread_mutex_t *mutex_pointer)`
- `bool pt_lock_tracking::vector_contains_thread(const pt_thread_vector &thread_identifiers, pt_thread_id_type thread_identifier)`
- `pt_mutex_vector pt_lock_tracking::get_owned_mutexes(pt_thread_id_type thread_identifier)`
- `pthread_mutex_t *pt_lock_tracking::get_registry_mutex(void)`
- `s_pt_thread_lock_info *pt_lock_tracking::find_thread_info(pt_thread_id_type thread_identifier, int *error_code)`
- `s_pt_thread_lock_info *pt_lock_tracking::lookup_thread_info(pt_thread_id_type thread_identifier, int *error_code)`
- `void pt_lock_tracking::notify_acquired(pt_thread_id_type thread_identifier, pthread_mutex_t *mutex_pointer)`
- `void pt_lock_tracking::notify_released(pt_thread_id_type thread_identifier, pthread_mutex_t *mutex_pointer)`
- `void pt_lock_tracking::record_error(ft_operation_error_stack *error_stack, int error_code, bool push_global)`
- `void pt_lock_tracking::set_error(int error_code)`

### PThread/pthread_lock_tracking.hpp

- `t_type *allocate(std::size_t count);`
- `template <typename t_other> pt_system_allocator(const pt_system_allocator<t_other> &other);`
- `void deallocate(t_type *pointer, std::size_t count);`

### PThread/pthread_mutex.cpp

- `bool pt_mutex::ensure_native_mutex() const`
- `bool pt_mutex::is_owned_by_thread(pthread_t thread_id) const`
- `bool pt_mutex::lockState() const`
- `const char *pt_mutex::operation_error_error_str_at(ft_size_t index) const`
- `const char *pt_mutex::operation_error_last_error_str() const`
- `ft_size_t pt_mutex::operation_error_depth() const`
- `ft_size_t pt_mutex::operation_error_find_by_id(unsigned long long operation_id) const`
- `int pt_mutex::lock_internal(bool *lock_acquired) const`
- `int pt_mutex::lock_state(bool *lock_acquired) const`
- `int pt_mutex::operation_error_error_at(ft_size_t index) const`
- `int pt_mutex::operation_error_last_error() const`
- `int pt_mutex::operation_error_pop_last() const`
- `int pt_mutex::operation_error_pop_newest() const`
- `int pt_mutex::unlock_internal(bool lock_acquired) const`
- `pthread_mutex_t *pt_mutex::get_native_mutex() const`
- `unsigned long long pt_mutex::operation_error_get_id_at(ft_size_t index) const`
  - `void pt_mutex::operation_error_pop_all() const`
- `void pt_mutex::teardown_thread_safety()`
- `void pt_mutex::unlock_state(bool lock_acquired) const`

### PThread/pthread_recursive_mutex.cpp

- `bool pt_recursive_mutex::ensure_native_mutex() const`
- `bool pt_recursive_mutex::is_owned_by_thread(pthread_t thread_id) const`
- `bool pt_recursive_mutex::lockState() const`
- `const char *pt_recursive_mutex::operation_error_error_str_at(ft_size_t index) const`
- `const char *pt_recursive_mutex::operation_error_last_error_str() const`
- `ft_size_t pt_recursive_mutex::operation_error_depth() const`
- `ft_size_t pt_recursive_mutex::operation_error_find_by_id(unsigned long long operation_id) const`
- `int pt_recursive_mutex::lock_internal(bool *lock_acquired) const`
- `int pt_recursive_mutex::lock_state(bool *lock_acquired) const`
- `int pt_recursive_mutex::operation_error_error_at(ft_size_t index) const`
- `int pt_recursive_mutex::operation_error_last_error() const`
- `int pt_recursive_mutex::operation_error_pop_last() const`
- `int pt_recursive_mutex::operation_error_pop_newest() const`
- `int pt_recursive_mutex::unlock_internal(bool lock_acquired) const`
- `pthread_mutex_t *pt_recursive_mutex::get_native_mutex() const`
- `unsigned long long pt_recursive_mutex::operation_error_get_id_at(ft_size_t index) const`
- `unsigned long long pt_recursive_mutex::operation_error_push_entry(int error_code) const`
- `void pt_recursive_mutex::operation_error_pop_all() const`
- `void pt_recursive_mutex::operation_error_push(int error_code) const`
- `void pt_recursive_mutex::teardown_thread_safety()`
- `void pt_recursive_mutex::unlock_state(bool lock_acquired) const`

### PThread/pthread_recursive_timed_lock_mutex.cpp

- `int pt_recursive_mutex::try_lock_for(pthread_t thread_id, const struct timespec &relative_time) const`
- `int pt_recursive_mutex::try_lock_until(pthread_t thread_id, const struct timespec &absolute_time) const`

### PThread/pthread_recursive_unlock_mutex.cpp

- `cleanup: if (fully_release)`

### PThread/pthread_rwlock.cpp

- `const char *pt_rwlock_strategy_get_error_str(const t_pt_rwlock *rwlock)`
- `int pt_rwlock_destroy(pthread_rwlock_t *rwlock)`
- `int pt_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attributes)`
- `int pt_rwlock_rdlock(pthread_rwlock_t *rwlock)`
- `int pt_rwlock_strategy_destroy(t_pt_rwlock *rwlock)`
- `int pt_rwlock_strategy_get_error(const t_pt_rwlock *rwlock)`
- `int pt_rwlock_strategy_init(t_pt_rwlock *rwlock, t_pt_rwlock_strategy strategy)`
- `int pt_rwlock_strategy_rdlock(t_pt_rwlock *rwlock)`
- `int pt_rwlock_strategy_unlock(t_pt_rwlock *rwlock)`
- `int pt_rwlock_strategy_wrlock(t_pt_rwlock *rwlock)`
- `int pt_rwlock_unlock(pthread_rwlock_t *rwlock)`
- `int pt_rwlock_wrlock(pthread_rwlock_t *rwlock)`
- `static int pt_rwlock_strategy_map_error(t_pt_rwlock *rwlock, int system_error)`
- `static int pt_rwlock_strategy_unlock_mutex(t_pt_rwlock *rwlock)`
- `static void pt_rwlock_strategy_set_error(t_pt_rwlock *rwlock, int error_code)`

### PThread/pthread_task_scheduler.cpp

- `bool ft_scheduled_task_handle::cancel()`
- `bool ft_scheduled_task_handle::is_thread_safe_enabled() const`
- `bool ft_scheduled_task_handle::valid() const`
- `bool ft_scheduled_task_state::is_cancelled() const`
- `bool ft_scheduled_task_state::is_thread_safe_enabled() const`
- `bool ft_task_scheduler::cancel_task_state(const ft_sharedptr<ft_scheduled_task_state> &state)`
- `bool ft_task_scheduler::capture_metrics(ft_task_trace_event &event) const`
- `bool ft_task_scheduler::is_thread_safe_enabled() const`
- `bool ft_task_scheduler::scheduled_heap_pop(scheduled_task &task)`
- `bool ft_task_scheduler::scheduled_heap_push(scheduled_task &&task)`
- `bool ft_task_scheduler::scheduled_remove_index(size_t index)`
- `bool ft_task_scheduler::update_queue_size(long long delta)`
- `bool ft_task_scheduler::update_worker_counters(long long active_delta, long long idle_delta)`
- `bool ft_task_scheduler::update_worker_total(long long delta)`
- `const char *ft_scheduled_task_handle::operation_error_error_str_at(ft_size_t index) const`
- `const char *ft_scheduled_task_handle::operation_error_last_error_str() const`
- `const char *ft_scheduled_task_state::operation_error_error_str_at(ft_size_t index) const`
- `const char *ft_scheduled_task_state::operation_error_last_error_str() const`
- `const char *ft_task_scheduler::operation_error_error_str_at(ft_size_t index) const`
- `const char *ft_task_scheduler::operation_error_last_error_str() const`
- `ft_sharedptr<ft_scheduled_task_state> ft_scheduled_task_handle::get_state() const`
- `ft_size_t ft_scheduled_task_handle::operation_error_depth() const`
- `ft_size_t ft_scheduled_task_handle::operation_error_find_by_id(unsigned long long operation_id) const`
- `ft_size_t ft_scheduled_task_state::operation_error_depth() const`
- `ft_size_t ft_scheduled_task_state::operation_error_find_by_id(unsigned long long operation_id) const`
- `ft_size_t ft_task_scheduler::operation_error_depth() const`
- `ft_size_t ft_task_scheduler::operation_error_find_by_id(unsigned long long operation_id) const`
- `ft_thread timer_worker([this]()`
- `int ft_scheduled_task_handle::enable_thread_safety()`
- `int ft_scheduled_task_handle::lock(bool *lock_acquired) const`
- `int ft_scheduled_task_handle::lock_internal(bool *lock_acquired) const`
- `int ft_scheduled_task_handle::operation_error_error_at(ft_size_t index) const`
- `int ft_scheduled_task_handle::operation_error_last_error() const`
- `int ft_scheduled_task_handle::operation_error_pop_last() const`
- `int ft_scheduled_task_handle::operation_error_pop_newest() const`
- `int ft_scheduled_task_state::enable_thread_safety()`
- `int ft_scheduled_task_state::lock(bool *lock_acquired) const`
- `int ft_scheduled_task_state::lock_internal(bool *lock_acquired) const`
- `int ft_scheduled_task_state::operation_error_error_at(ft_size_t index) const`
- `int ft_scheduled_task_state::operation_error_last_error() const`
- `int ft_scheduled_task_state::operation_error_pop_last() const`
- `int ft_scheduled_task_state::operation_error_pop_newest() const`
- `int ft_task_scheduler::enable_thread_safety()`
- `int ft_task_scheduler::lock(bool *lock_acquired) const`
- `int ft_task_scheduler::lock_internal(bool *lock_acquired) const`
- `int ft_task_scheduler::operation_error_error_at(ft_size_t index) const`
- `int ft_task_scheduler::operation_error_last_error() const`
- `int ft_task_scheduler::operation_error_pop_last() const`
- `int ft_task_scheduler::operation_error_pop_newest() const`
- `long long ft_task_scheduler::get_queue_size() const`
- `long long ft_task_scheduler::get_scheduled_task_count() const`
- `long long ft_task_scheduler::get_worker_active_count() const`
- `long long ft_task_scheduler::get_worker_idle_count() const`
- `pt_mutex *ft_scheduled_task_handle::mutex_handle() const`
- `pt_mutex *ft_scheduled_task_state::mutex_handle() const`
- `pt_recursive_mutex *ft_task_scheduler::mutex_handle() const`
- `size_t ft_task_scheduler::get_worker_total_count() const`
- `static int pt_recursive_mutex_capture_error(const pt_recursive_mutex *mutex, int operation_result)`
- `static int pt_recursive_mutex_pop_error(const pt_recursive_mutex *mutex)`
- `unsigned long long ft_scheduled_task_handle::operation_error_get_id_at(ft_size_t index) const`
- `unsigned long long ft_scheduled_task_handle::operation_error_push_entry(int error_code) const`
- `unsigned long long ft_scheduled_task_handle::operation_error_push_entry_with_id( int error_code, unsigned long long operation_id) const`
- `unsigned long long ft_scheduled_task_state::operation_error_get_id_at(ft_size_t index) const`
- `unsigned long long ft_scheduled_task_state::operation_error_push_entry(int error_code) const`
- `unsigned long long ft_scheduled_task_state::operation_error_push_entry_with_id( int error_code, unsigned long long operation_id) const`
- `unsigned long long ft_task_scheduler::operation_error_get_id_at(ft_size_t index) const`
- `unsigned long long ft_task_scheduler::operation_error_push_entry(int error_code) const`
- `unsigned long long ft_task_scheduler::operation_error_push_entry_with_id( int error_code, unsigned long long operation_id) const`
- `void ft_scheduled_task_handle::disable_thread_safety()`
- `void ft_scheduled_task_handle::operation_error_pop_all() const`
- `void ft_scheduled_task_handle::operation_error_push(int error_code) const`
- `void ft_scheduled_task_handle::record_operation_error(int error_code) const noexcept`
- `void ft_scheduled_task_handle::teardown_thread_safety()`
- `void ft_scheduled_task_handle::unlock(bool lock_acquired) const`
- `void ft_scheduled_task_handle::unlock_internal(bool lock_acquired) const`
- `void ft_scheduled_task_state::cancel()`
- `void ft_scheduled_task_state::disable_thread_safety()`
- `void ft_scheduled_task_state::operation_error_pop_all() const`
- `void ft_scheduled_task_state::operation_error_push(int error_code) const`
- `void ft_scheduled_task_state::record_operation_error(int error_code) const noexcept`
- `void ft_scheduled_task_state::teardown_thread_safety()`
- `void ft_scheduled_task_state::unlock(bool lock_acquired) const`
- `void ft_scheduled_task_state::unlock_internal(bool lock_acquired) const`
- `void ft_task_scheduler::disable_thread_safety()`
- `void ft_task_scheduler::operation_error_pop_all() const`
- `void ft_task_scheduler::operation_error_push(int error_code) const`
- `void ft_task_scheduler::record_operation_error(int error_code) const noexcept`
- `void ft_task_scheduler::scheduled_heap_sift_down(size_t index)`
- `void ft_task_scheduler::scheduled_heap_sift_up(size_t index)`
- `void ft_task_scheduler::teardown_thread_safety()`
- `void ft_task_scheduler::timer_loop()`
- `void ft_task_scheduler::trace_emit_event(e_ft_task_trace_phase phase, unsigned long long trace_id, unsigned long long parent_id, const char *label, bool timer_thread)`
- `void ft_task_scheduler::unlock(bool lock_acquired) const`
- `void ft_task_scheduler::unlock_internal(bool lock_acquired) const`
- `void ft_task_scheduler::worker_loop()`

### PThread/pthread_task_scheduler_tracing.cpp

- `int task_scheduler_register_trace_sink(task_scheduler_trace_sink sink)`
- `int task_scheduler_unregister_trace_sink(task_scheduler_trace_sink sink)`
- `static std::atomic<unsigned long long> g_task_scheduler_trace_counter(1);`
- `static void task_scheduler_trace_set_error(int error)`
- `unsigned long long task_scheduler_trace_current_span(void)`
- `unsigned long long task_scheduler_trace_generate_span_id(void)`
- `unsigned long long task_scheduler_trace_push_span(unsigned long long span_id)`
- `void task_scheduler_trace_emit(const ft_task_trace_event &event)`
- `void task_scheduler_trace_pop_span(unsigned long long previous_span)`

### PThread/pthread_this_thread.cpp

- `t_thread_id ft_this_thread_get_id()`
- `void ft_this_thread_sleep_for(t_duration_milliseconds duration)`
- `void ft_this_thread_sleep_until(t_monotonic_time_point time_point)`
- `void ft_this_thread_yield()`

### PThread/pthread_thread.cpp

- `bool ft_thread::is_thread_safe_enabled() const`
- `bool ft_thread::joinable() const`
- `const char *ft_thread::get_error_str() const`
- `int ft_thread::detach_locked()`
- `int ft_thread::enable_thread_safety()`
- `int ft_thread::get_error() const`
- `int ft_thread::lock(bool *lock_acquired) const`
- `int ft_thread::lock_internal(bool *lock_acquired) const`
- `void *ft_thread::start_routine(void *data)`
- `void ft_thread::detach()`
- `void ft_thread::disable_thread_safety()`
- `void ft_thread::join()`
- `void ft_thread::set_error(int error) const`
- `void ft_thread::teardown_thread_safety()`
- `void ft_thread::unlock(bool lock_acquired) const`
- `void ft_thread::unlock_internal(bool lock_acquired) const`

### PThread/pthread_thread_create.cpp

- `int pt_thread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)`

### PThread/pthread_thread_join.cpp

- `int pt_thread_timed_join(pthread_t thread, void **retval, long timeout_ms)`

### PThread/pthread_thread_wait.cpp

- `int pt_thread_wake_one_uint32(std::atomic<uint32_t> *address)`

### PThread/pthread_timed_lock_mutex.cpp

- `int pt_mutex::try_lock_for(pthread_t thread_id, const struct timespec &relative_time) const`
- `int pt_mutex::try_lock_until(pthread_t thread_id, const struct timespec &absolute_time) const`

### PThread/recursive_mutex.hpp

- `bool ensure_native_mutex() const;`
- `bool is_owned_by_thread(pthread_t thread_id) const;`
- `bool lockState() const;`
- `const char *operation_error_error_str_at(ft_size_t index) const;`
- `const char *operation_error_last_error_str() const;`
- `ft_size_t operation_error_depth() const;`
- `ft_size_t operation_error_find_by_id(unsigned long long operation_id) const;`
- `int lock(pthread_t thread_id) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `int lock_state(bool *lock_acquired) const;`
- `int operation_error_error_at(ft_size_t index) const;`
- `int operation_error_last_error() const;`
- `int operation_error_pop_last() const;`
- `int operation_error_pop_newest() const;`
- `int try_lock(pthread_t thread_id) const;`
- `int try_lock_for(pthread_t thread_id, const struct timespec &relative_time) const;`
- `int try_lock_until(pthread_t thread_id, const struct timespec &absolute_time) const;`
- `int unlock(pthread_t thread_id) const;`
- `int unlock_internal(bool lock_acquired) const;`
- `pthread_mutex_t *get_native_mutex() const;`
- `public: pt_recursive_mutex();`
- `unsigned long long operation_error_get_id_at(ft_size_t index) const;`
- `unsigned long long operation_error_push_entry(int error_code) const;`
- `unsigned long long operation_error_push_entry_with_id(int error_code, unsigned long long operation_id) const;`
- `void operation_error_pop_all() const;`
- `void operation_error_push(int error_code) const;`
- `void teardown_thread_safety();`
- `void unlock_state(bool lock_acquired) const;`

### PThread/task_scheduler.hpp

- `static int pt_mutex_capture_error(const pt_mutex *mutex, int operation_result)`
- `static int pt_mutex_pop_error(const pt_mutex *mutex)`
- `template <typename ElementType> bool ft_blocking_queue<ElementType>::is_thread_safe_enabled() const`
- `template <typename ElementType> bool ft_blocking_queue<ElementType>::pop(ElementType &result)`
- `template <typename ElementType> bool ft_blocking_queue<ElementType>::wait_pop(ElementType &result, const std::atomic<bool> &running_flag)`
- `template <typename ElementType> const char *ft_blocking_queue<ElementType>::operation_error_error_str_at(ft_size_t index) const`
- `template <typename ElementType> const char *ft_blocking_queue<ElementType>::operation_error_last_error_str() const`
- `template <typename ElementType> ft_blocking_queue<ElementType>::ft_blocking_queue() : _mutex(), _condition(), _shutdown(false), _storage(), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ElementType> ft_blocking_queue<ElementType>::~ft_blocking_queue()`
- `template <typename ElementType> ft_size_t ft_blocking_queue<ElementType>::operation_error_depth() const`
- `template <typename ElementType> ft_size_t ft_blocking_queue<ElementType>::operation_error_find_by_id( unsigned long long operation_id) const`
- `template <typename ElementType> int ft_blocking_queue<ElementType>::enable_thread_safety()`
- `template <typename ElementType> int ft_blocking_queue<ElementType>::lock(bool *lock_acquired) const`
- `template <typename ElementType> int ft_blocking_queue<ElementType>::lock_internal(bool *lock_acquired) const`
- `template <typename ElementType> int ft_blocking_queue<ElementType>::operation_error_error_at(ft_size_t index) const`
- `template <typename ElementType> int ft_blocking_queue<ElementType>::operation_error_last_error() const`
- `template <typename ElementType> int ft_blocking_queue<ElementType>::operation_error_pop_last() const`
- `template <typename ElementType> int ft_blocking_queue<ElementType>::operation_error_pop_newest() const`
- `template <typename ElementType> pt_mutex *ft_blocking_queue<ElementType>::mutex_handle() const`
- `template <typename ElementType> unsigned long long ft_blocking_queue<ElementType>::operation_error_get_id_at(ft_size_t index) const`
- `template <typename ElementType> unsigned long long ft_blocking_queue<ElementType>::operation_error_push_entry(int error_code) const`
- `template <typename ElementType> unsigned long long ft_blocking_queue<ElementType>::operation_error_push_entry_with_id( int error_code, unsigned long long operation_id) const`
- `template <typename ElementType> void ft_blocking_queue<ElementType>::disable_thread_safety()`
- `template <typename ElementType> void ft_blocking_queue<ElementType>::operation_error_pop_all() const`
- `template <typename ElementType> void ft_blocking_queue<ElementType>::operation_error_push(int error_code) const`
- `template <typename ElementType> void ft_blocking_queue<ElementType>::push(ElementType &&value)`
- `template <typename ElementType> void ft_blocking_queue<ElementType>::record_operation_error(int error_code) const noexcept`
- `template <typename ElementType> void ft_blocking_queue<ElementType>::shutdown()`
- `template <typename ElementType> void ft_blocking_queue<ElementType>::teardown_thread_safety()`
- `template <typename ElementType> void ft_blocking_queue<ElementType>::unlock(bool lock_acquired) const`
- `template <typename ElementType> void ft_blocking_queue<ElementType>::unlock_internal(bool lock_acquired) const`
- `template <typename FunctionType, typename... Args> auto ft_task_scheduler::submit(FunctionType function, Args... args) -> ft_future<typename std::invoke_result<FunctionType, Args...>::type>`
- `template <typename Rep, typename Period, typename FunctionType, typename... Args> auto ft_task_scheduler::schedule_after(std::chrono::duration<Rep, Period> delay, FunctionType function, Args... args) -> Pair<ft_future<typename std::invoke_result<FunctionType, Args...>::type>, ft_scheduled_task_handle>`
- `template <typename Rep, typename Period, typename FunctionType, typename... Args> ft_scheduled_task_handle ft_task_scheduler::schedule_every(std::chrono::duration<Rep, Period> interval, FunctionType function, Args... args)`

### PThread/task_scheduler_tracing.hpp

- `int task_scheduler_register_trace_sink(task_scheduler_trace_sink sink);`
- `int task_scheduler_unregister_trace_sink(task_scheduler_trace_sink sink);`
- `unsigned long long task_scheduler_trace_current_span(void);`
- `unsigned long long task_scheduler_trace_generate_span_id(void);`
- `unsigned long long task_scheduler_trace_push_span(unsigned long long span_id);`
- `void task_scheduler_trace_emit(const ft_task_trace_event &event);`
- `void task_scheduler_trace_pop_span(unsigned long long previous_span);`

### PThread/unique_lock.hpp

- `MutexType *mutex() const;`
- `bool owns_lock() const;`
- `const char *last_operation_error_str() const noexcept;`
- `explicit ft_unique_lock(MutexType &mutex);`
- `ft_operation_error_stack *operation_error_stack_handle() const noexcept;`
- `int last_operation_error() const noexcept;`
- `int pop_operation_error(unsigned long long operation_id) const noexcept;`
- `public: ft_unique_lock();`
- `static int ft_unique_lock_pop_state_mutex_error(pt_mutex &mutex)`
- `template <typename MutexType> MutexType *ft_unique_lock<MutexType>::mutex() const`
- `template <typename MutexType> bool ft_unique_lock<MutexType>::owns_lock() const`
- `template <typename MutexType> const char *ft_unique_lock<MutexType>::last_operation_error_str() const noexcept`
- `template <typename MutexType> ft_operation_error_stack *ft_unique_lock<MutexType>::operation_error_stack_handle() const noexcept`
- `template <typename MutexType> ft_unique_lock<MutexType>::ft_unique_lock() : _mutex(ft_nullptr) , _owns_lock(false)`
- `template <typename MutexType> ft_unique_lock<MutexType>::ft_unique_lock(MutexType &mutex) : _mutex(&mutex) , _owns_lock(false)`
- `template <typename MutexType> ft_unique_lock<MutexType>::ft_unique_lock(ft_unique_lock &&other) : _mutex(ft_nullptr) , _owns_lock(false)`
- `template <typename MutexType> ft_unique_lock<MutexType>::~ft_unique_lock()`
- `template <typename MutexType> int ft_unique_lock<MutexType>::last_operation_error() const noexcept`
- `template <typename MutexType> int ft_unique_lock<MutexType>::pop_operation_error(unsigned long long operation_id) const noexcept`
- `template <typename MutexType> static int ft_unique_lock_pop_mutex_error(MutexType *mutex)`
- `template <typename MutexType> unsigned long long ft_unique_lock<MutexType>::last_operation_id() const noexcept`
- `template <typename MutexType> void ft_unique_lock<MutexType>::lock()`
- `template <typename MutexType> void ft_unique_lock<MutexType>::record_error(int error, bool push_global) const noexcept`
- `template <typename MutexType> void ft_unique_lock<MutexType>::unlock()`
- `unsigned long long last_operation_id() const noexcept;`
- `void lock();`
- `void record_error(int error, bool push_global = true) const noexcept;`
- `void unlock();`

### Parser/document_backend.hpp

- `const char *get_error_str() const noexcept;`
- `int get_error() const noexcept;`
- `protected: void assign_error(int error_code) const noexcept;`
- `public: ft_document_source() noexcept;`
- `virtual int read_all(ft_string &output) = 0;`
- `virtual ~ft_document_source();`
- `void set_error(int error_code) const noexcept;`

### Parser/dom.cpp

- `bool ft_dom_document::is_thread_safe_enabled() const noexcept`
- `bool ft_dom_document::thread_guard::lock_acquired() const noexcept`
- `bool ft_dom_node::has_attribute(const ft_string &key) const noexcept`
- `bool ft_dom_node::is_thread_safe_enabled() const noexcept`
- `bool ft_dom_node::thread_guard::lock_acquired() const noexcept`
- `bool ft_dom_validation_report::valid() const noexcept`
- `const char *ft_dom_document::get_error_str() const noexcept`
- `const char *ft_dom_validation_report::get_error_str() const noexcept`
- `const ft_string &ft_dom_node::get_name() const noexcept`
- `const ft_string &ft_dom_node::get_value() const noexcept`
- `const ft_vector<ft_dom_node*> &ft_dom_node::get_children() const noexcept`
- `const ft_vector<ft_dom_validation_error> &ft_dom_validation_report::errors() const noexcept`
- `const ft_vector<ft_string> &ft_dom_node::get_attribute_keys() const noexcept`
- `const ft_vector<ft_string> &ft_dom_node::get_attribute_values() const noexcept`
- `ft_dom_node *ft_dom_document::get_root() const noexcept`
- `ft_dom_node *ft_dom_node::find_child(const ft_string &name) const noexcept`
- `ft_dom_node_type ft_dom_node::get_type() const noexcept`
- `ft_string ft_dom_node::get_attribute(const ft_string &key) const noexcept`
- `int ft_dom_document::get_error() const noexcept`
- `int ft_dom_document::lock(bool *lock_acquired) const noexcept`
- `int ft_dom_document::prepare_thread_safety() noexcept`
- `int ft_dom_document::thread_guard::get_status() const noexcept`
- `int ft_dom_find_path(const ft_dom_node *root, const ft_string &path, const ft_dom_node **out_node) noexcept`
- `int ft_dom_node::add_attribute(const char *key, const char *value) noexcept`
- `int ft_dom_node::add_attribute(const ft_string &key, const ft_string &value) noexcept`
- `int ft_dom_node::add_child(ft_dom_node *child) noexcept`
- `int ft_dom_node::get_error() const noexcept`
- `int ft_dom_node::lock(bool *lock_acquired) const noexcept`
- `int ft_dom_node::prepare_thread_safety() noexcept`
- `int ft_dom_node::set_name(const char *name) noexcept`
- `int ft_dom_node::set_name(const ft_string &name) noexcept`
- `int ft_dom_node::set_value(const char *value) noexcept`
- `int ft_dom_node::set_value(const ft_string &value) noexcept`
- `int ft_dom_node::thread_guard::get_status() const noexcept`
- `int ft_dom_schema::add_rule(const ft_string &path, ft_dom_node_type type, bool required) noexcept`
- `int ft_dom_schema::validate(const ft_dom_document &document, ft_dom_validation_report &report) const noexcept`
- `int ft_dom_schema::validate_rule(const ft_dom_schema_rule &rule, const ft_dom_node *node, const ft_string &base_path, ft_dom_validation_report &report) const noexcept`
- `int ft_dom_validation_report::add_error(const ft_string &path, const ft_string &message) noexcept`
- `int ft_dom_validation_report::get_error() const noexcept`
- `static ft_string ft_dom_build_path(const ft_string &base, const ft_string &segment) noexcept`
- `void ft_dom_document::clear() noexcept`
- `void ft_dom_document::set_error(int error_code) const noexcept`
- `void ft_dom_document::set_root(ft_dom_node *root) noexcept`
- `void ft_dom_document::teardown_thread_safety() noexcept`
- `void ft_dom_document::unlock(bool lock_acquired) const noexcept`
- `void ft_dom_node::set_error(int error_code) const noexcept`
- `void ft_dom_node::set_type(ft_dom_node_type type) noexcept`
- `void ft_dom_node::teardown_thread_safety() noexcept`
- `void ft_dom_node::unlock(bool lock_acquired) const noexcept`
- `void ft_dom_schema::set_error(int error_code) const noexcept`
- `void ft_dom_validation_report::mark_invalid() noexcept`
- `void ft_dom_validation_report::mark_valid() noexcept`
- `void ft_dom_validation_report::set_error(int error_code) const noexcept`

### Parser/dom.hpp

- `int ft_dom_find_path(const ft_dom_node *root, const ft_string &path, const ft_dom_node **out_node) noexcept;`

### Parser/parser_document_backend.cpp

- `bool ft_http_document_sink::is_ssl_enabled() const noexcept`
- `bool ft_http_document_source::is_ssl_enabled() const noexcept`
- `const char *ft_document_sink::get_error_str() const noexcept`
- `const char *ft_document_source::get_error_str() const noexcept`
- `const char *ft_file_document_sink::get_path() const noexcept`
- `const char *ft_file_document_source::get_path() const noexcept`
- `const char *ft_http_document_sink::get_host() const noexcept`
- `const char *ft_http_document_sink::get_path() const noexcept`
- `const char *ft_http_document_sink::get_port() const noexcept`
- `const char *ft_http_document_source::get_host() const noexcept`
- `const char *ft_http_document_source::get_path() const noexcept`
- `const char *ft_http_document_source::get_port() const noexcept`
- `const char *ft_memory_document_source::get_data() const noexcept`
- `ft_string *ft_memory_document_sink::get_storage() const noexcept`
- `int ft_document_sink::get_error() const noexcept`
- `int ft_document_source::get_error() const noexcept`
- `int ft_file_document_sink::write_all(const char *data_pointer, size_t data_length)`
- `int ft_file_document_source::read_all(ft_string &output)`
- `int ft_http_document_sink::write_all(const char *data_pointer, size_t data_length)`
- `int ft_http_document_source::read_all(ft_string &output)`
- `int ft_memory_document_sink::write_all(const char *data_pointer, size_t data_length)`
- `int ft_memory_document_source::read_all(ft_string &output)`
- `size_t ft_memory_document_source::get_length() const noexcept`
- `void ft_document_sink::assign_error(int error_code) const noexcept`
- `void ft_document_sink::set_error(int error_code) const noexcept`
- `void ft_document_source::assign_error(int error_code) const noexcept`
- `void ft_document_source::set_error(int error_code) const noexcept`
- `void ft_file_document_sink::set_path(const char *file_path) noexcept`
- `void ft_file_document_source::set_path(const char *file_path) noexcept`
- `void ft_http_document_sink::configure(const char *host, const char *path, bool use_ssl, const char *port) noexcept`
- `void ft_http_document_source::configure(const char *host, const char *path, bool use_ssl, const char *port) noexcept`
- `void ft_memory_document_sink::set_storage(ft_string *storage_pointer) noexcept`
- `void ft_memory_document_source::set_data(const char *data_pointer, size_t data_length) noexcept`

### Printf/printf.hpp

- `int ft_fprintf(FILE *stream, const char *format, ...) __attribute__((format(printf, 2, 3), hot));`
- `int ft_vfprintf(FILE *stream, const char *format, va_list args);`
- `int pf_printf(const char *format, ...) __attribute__((format(printf, 1, 2), hot));`
- `int pf_printf_fd(int fd, const char *format, ...) __attribute__((format(printf, 2, 3), hot));`
- `int pf_register_custom_specifier(char specifier, t_pf_custom_formatter handler, void *context);`
- `int pf_snprintf(char *string, size_t size, const char *format, ...) __attribute__((format(printf, 3, 4), hot));`
- `int pf_unregister_custom_specifier(char specifier);`
- `int pf_vsnprintf(char *string, size_t size, const char *format, va_list args);`
- `void pf_reset_fflush_function(void);`
- `void pf_reset_ftell_function(void);`
- `void pf_reset_tmpfile_function(void);`
- `void pf_set_fflush_function(t_pf_fflush_function function);`
- `void pf_set_ftell_function(t_pf_ftell_function function);`
- `void pf_set_tmpfile_function(t_pf_tmpfile_function function);`

### Printf/printf_custom_specifier.cpp

- `int pf_register_custom_specifier(char specifier, t_pf_custom_formatter handler, void *context)`
- `int pf_try_format_custom_specifier(char specifier, va_list *args, ft_string &output, bool *handled)`
- `int pf_unregister_custom_specifier(char specifier)`
- `static void pf_clear_entry(t_pf_custom_specifier_entry &entry)`

### Printf/printf_engine.cpp

- `int pf_engine_format(const char *format, va_list args, t_pf_engine_write_callback writer, void *context, size_t *written_count)`
- `static bool pf_engine_is_digit(char character)`
- `static bool pf_engine_is_standard_conversion(char specifier)`
- `static ft_string pf_engine_build_format_string(const pf_engine_format_spec &spec, int width_value, bool width_specified, int precision_value, bool precision_specified)`
- `static int pf_engine_collect_argument_kinds(const std::vector<pf_engine_token> &tokens, std::vector<pf_engine_argument_kind> &kinds)`
- `static int pf_engine_fetch_int_argument(const std::vector<pf_engine_argument_value> &values, int index, int *out_value)`
- `static int pf_engine_format_boolean(int value, t_pf_engine_write_callback writer, void *context, size_t *written_count)`
- `static int pf_engine_format_standard_positional(const pf_engine_format_spec &original_spec, const std::vector<pf_engine_argument_value> &values, t_pf_engine_write_callback writer, void *context, size_t *written_count, size_t *character_count)`
- `static int pf_engine_format_standard_sequential(const pf_engine_format_spec &original_spec, va_list *args, t_pf_engine_write_callback writer, void *context, size_t *written_count, size_t *character_count)`
- `static int pf_engine_format_with_snprintf(const ft_string &format_string, t_pf_engine_write_callback writer, void *context, size_t *written_count, ...)`
- `static int pf_engine_parse_format(const char *format, std::vector<pf_engine_token> &tokens, bool *uses_positional, bool *uses_sequential)`
- `static int pf_engine_parse_number(const char *format, size_t length, size_t *cursor, int *out_value)`
- `static int pf_engine_parse_specifier(const char *format, size_t length, size_t *cursor, pf_engine_format_spec &spec, bool *uses_positional, bool *uses_sequential)`
- `static int pf_engine_process_positional(const std::vector<pf_engine_token> &tokens, va_list args, t_pf_engine_write_callback writer, void *context, size_t *written_count)`
- `static int pf_engine_process_sequential(const std::vector<pf_engine_token> &tokens, va_list args, t_pf_engine_write_callback writer, void *context, size_t *written_count)`
- `static int pf_engine_register_argument_kind(std::vector<pf_engine_argument_kind> &kinds, size_t index, pf_engine_argument_kind kind)`
- `static int pf_engine_store_arguments(const std::vector<pf_engine_argument_kind> &kinds, va_list args, std::vector<pf_engine_argument_value> &values)`
- `static int pf_engine_write_literal(const ft_string &literal, t_pf_engine_write_callback writer, void *context, size_t *written_count)`
- `static void pf_engine_append_signed_number(ft_string &target, int number)`
- `static void pf_engine_append_unsigned_number(ft_string &target, unsigned int number)`
- `static void pf_engine_argument_types_resize(std::vector<pf_engine_argument_kind> &kinds, size_t required_index)`
- `static void pf_engine_init_spec(pf_engine_format_spec &spec)`

### Printf/printf_engine.hpp

- `int pf_engine_format(const char *format, va_list args, t_pf_engine_write_callback writer, void *context, size_t *written_count);`

### Printf/printf_format.cpp

- `int pf_printf_fd_v(int fd, const char *format, va_list args)`
- `static int pf_fd_writer(const char *data_pointer, size_t data_length, void *context, size_t *written_count)`

### Printf/printf_ft_fprintf.cpp

- `int ft_fprintf(FILE *stream, const char *format, ...)`
- `int ft_vfprintf(FILE *stream, const char *format, va_list args)`
- `static int pf_stream_writer(const char *data_pointer, size_t data_length, void *context, size_t *written_count)`

### Printf/printf_internal.hpp

- `int pf_flush_stream(FILE *stream);`
- `int pf_printf_fd_v(int fd, const char *format, va_list args);`
- `int pf_string_pop_last_error(const ft_string &string_value);`
- `int pf_try_format_custom_specifier(char specifier, va_list *args, ft_string &output, bool *handled);`
- `void ft_putchar_fd(const char character, int fd, size_t *count);`
- `void ft_putfloat_fd(double number, int fd, size_t *count, int precision);`
- `void ft_putgeneral_fd(double number, bool uppercase, int fd, size_t *count, int precision);`
- `void ft_puthex_fd(uintmax_t number, int fd, bool uppercase, size_t *count);`
- `void ft_putnbr_fd(long number, int fd, size_t *count);`
- `void ft_putoctal_fd(uintmax_t number, int fd, size_t *count);`
- `void ft_putptr_fd(void *pointer, int fd, size_t *count);`
- `void ft_putscientific_fd(double number, bool uppercase, int fd, size_t *count, int precision);`
- `void ft_putstr_fd(const char *string, int fd, size_t *count);`
- `void ft_putunsigned_fd(uintmax_t number, int fd, size_t *count);`
- `void pf_write_ft_string_fd(const ft_string &output, int fd, size_t *count);`
- `void pf_write_ft_string_stream(const ft_string &output, FILE *stream, size_t *count);`

### Printf/printf_print_args.cpp

- `size_t ft_strlen_printf(const char *string)`
- `static bool count_has_error(size_t *count)`
- `static int format_double_output(char specifier, int precision, double number, ft_string &output)`
- `static void mark_count_error(size_t *count)`
- `static void write_buffer_fd(const char *buffer, size_t length, int fd, size_t *count)`
- `static void write_decimal_from_pairs(uintmax_t number, int fd, size_t *count)`
- `static void write_hex_from_pairs(uintmax_t number, bool uppercase, int fd, size_t *count)`
- `static void write_octal_from_triplets(uintmax_t number, int fd, size_t *count)`
- `void ft_putchar_fd(const char character, int fd, size_t *count)`
- `void ft_putfloat_fd(double number, int fd, size_t *count, int precision)`
- `void ft_putgeneral_fd(double number, bool uppercase, int fd, size_t *count, int precision)`
- `void ft_puthex_fd(uintmax_t number, int fd, bool uppercase, size_t *count)`
- `void ft_putnbr_fd(long number, int fd, size_t *count)`
- `void ft_putoctal_fd(uintmax_t number, int fd, size_t *count)`
- `void ft_putptr_fd(void *pointer, int fd, size_t *count)`
- `void ft_putscientific_fd(double number, bool uppercase, int fd, size_t *count, int precision)`
- `void ft_putstr_fd(const char *string, int fd, size_t *count)`
- `void ft_putunsigned_fd(uintmax_t number, int fd, size_t *count)`
- `void pf_write_ft_string_fd(const ft_string &output, int fd, size_t *count)`

### Printf/printf_printf.cpp

- `int pf_printf(const char *format, ...)`

### Printf/printf_vsnprintf.cpp

- `int pf_flush_stream(FILE *stream)`
- `int pf_vsnprintf(char *string, size_t size, const char *format, va_list args)`
- `void pf_reset_fflush_function(void)`
- `void pf_reset_ftell_function(void)`
- `void pf_reset_tmpfile_function(void)`
- `void pf_set_fflush_function(t_pf_fflush_function function)`
- `void pf_set_ftell_function(t_pf_ftell_function function)`
- `void pf_set_tmpfile_function(t_pf_tmpfile_function function)`

### RNG/deck.hpp

- `ElementType *drawTopElement() noexcept;`
- `ElementType *getRandomElement() const noexcept;`
- `ElementType *peekTopElement() const noexcept;`
- `ElementType *popRandomElement() noexcept;`
- `int lock_deck(ft_unique_lock<pt_mutex> &guard) const noexcept;`
- `public: ft_deck() noexcept;`
- `static int lock_pair(const ft_deck<ElementType> &first, const ft_deck<ElementType> &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard) noexcept;`
- `static void sleep_backoff() noexcept;`
- `template<typename ElementType> ElementType *ft_deck<ElementType>::drawTopElement() noexcept`
- `template<typename ElementType> ElementType *ft_deck<ElementType>::getRandomElement() const noexcept`
- `template<typename ElementType> ElementType *ft_deck<ElementType>::peekTopElement() const noexcept`
- `template<typename ElementType> ElementType *ft_deck<ElementType>::popRandomElement() noexcept`
- `template<typename ElementType> ft_deck<ElementType>::ft_deck() noexcept : ft_vector<ElementType*>() , _mutex()`
- `template<typename ElementType> ft_deck<ElementType>::~ft_deck() noexcept`
- `template<typename ElementType> int ft_deck<ElementType>::lock_deck(ft_unique_lock<pt_mutex> &guard) const noexcept`
- `template<typename ElementType> int ft_deck<ElementType>::lock_pair(const ft_deck<ElementType> &first, const ft_deck<ElementType> &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard) noexcept`
- `template<typename ElementType> void ft_deck<ElementType>::set_error(int error_code) const noexcept`
- `template<typename ElementType> void ft_deck<ElementType>::set_error_unlocked(int error_code) const noexcept`
- `template<typename ElementType> void ft_deck<ElementType>::shuffle() noexcept`
- `template<typename ElementType> void ft_deck<ElementType>::sleep_backoff() noexcept`
- `void set_error(int error_code) const noexcept;`
- `void set_error_unlocked(int error_code) const noexcept;`
- `void shuffle() noexcept;`

### RNG/loot_table.hpp

- `ElementType *get_item() const noexcept;`
- `const char *get_error_str() const noexcept;`
- `int get_effective_weight() const noexcept;`
- `int get_error() const noexcept;`
- `int get_rarity() const noexcept;`
- `int get_weight() const noexcept;`
- `int lock_entry(ft_unique_lock<pt_mutex> &guard) const noexcept;`
- `public: ft_loot_entry() noexcept;`
- `template<typename ElementType> ElementType *ft_loot_entry<ElementType>::get_item() const noexcept`
- `template<typename ElementType> ElementType *ft_loot_table<ElementType>::getRandomLoot() const`
- `template<typename ElementType> ElementType *ft_loot_table<ElementType>::popRandomLoot()`
- `template<typename ElementType> const char *ft_loot_entry<ElementType>::get_error_str() const noexcept`
- `template<typename ElementType> ft_loot_entry<ElementType>::ft_loot_entry() noexcept : _item(ft_nullptr) , _weight(1) , _rarity(0) , _error_code(FT_ERR_SUCCESSS) , _mutex()`
- `template<typename ElementType> ft_loot_entry<ElementType>::ft_loot_entry(ElementType *item, int weight, int rarity) noexcept : _item(item) , _weight(1) , _rarity(0) , _error_code(FT_ERR_SUCCESSS) , _mutex()`
- `template<typename ElementType> ft_loot_entry<ElementType>::ft_loot_entry(const ft_loot_entry<ElementType> &other) noexcept : _item(ft_nullptr) , _weight(1) , _rarity(0) , _error_code(FT_ERR_SUCCESSS) , _mutex()`
- `template<typename ElementType> ft_loot_entry<ElementType>::~ft_loot_entry() noexcept`
- `template<typename ElementType> ft_loot_table<ElementType>::ft_loot_table() noexcept : ft_vector<ft_loot_entry<ElementType> >() , _mutex()`
- `template<typename ElementType> ft_loot_table<ElementType>::~ft_loot_table() noexcept`
- `template<typename ElementType> int ft_loot_entry<ElementType>::get_effective_weight() const noexcept`
- `template<typename ElementType> int ft_loot_entry<ElementType>::get_error() const noexcept`
- `template<typename ElementType> int ft_loot_entry<ElementType>::get_rarity() const noexcept`
- `template<typename ElementType> int ft_loot_entry<ElementType>::get_weight() const noexcept`
- `template<typename ElementType> int ft_loot_entry<ElementType>::lock_entry(ft_unique_lock<pt_mutex> &guard) const noexcept`
- `template<typename ElementType> int ft_loot_table<ElementType>::compute_total_weight_locked(size_t entry_count, int *total_weight) const noexcept`
- `template<typename ElementType> int ft_loot_table<ElementType>::locate_entry_by_roll_locked(int roll, size_t entry_count, size_t *result_index) const noexcept`
- `template<typename ElementType> int ft_loot_table<ElementType>::lock_table(ft_unique_lock<pt_mutex> &guard) const noexcept`
- `template<typename ElementType> void ft_loot_entry<ElementType>::set_error(int error_code) const noexcept`
- `template<typename ElementType> void ft_loot_entry<ElementType>::set_error_unlocked(int error_code) const noexcept`
- `template<typename ElementType> void ft_loot_entry<ElementType>::set_item(ElementType *item) noexcept`
- `template<typename ElementType> void ft_loot_entry<ElementType>::set_rarity(int rarity) noexcept`
- `template<typename ElementType> void ft_loot_entry<ElementType>::set_weight(int weight) noexcept`
- `template<typename ElementType> void ft_loot_table<ElementType>::addElement(ElementType *elem, int weight, int rarity)`
- `template<typename ElementType> void ft_loot_table<ElementType>::set_error(int error_code) const noexcept`
- `template<typename ElementType> void ft_loot_table<ElementType>::set_error_unlocked(int error_code) const noexcept`
- `void set_error(int error_code) const noexcept;`
- `void set_error_unlocked(int error_code) const noexcept;`
- `void set_item(ElementType *item) noexcept;`
- `void set_rarity(int rarity) noexcept;`
- `void set_weight(int weight) noexcept;`

### RNG/rng.hpp

- `double rng_beta_cdf(double alpha, double beta, double value);`
- `double rng_beta_pdf(double alpha, double beta, double value);`
- `double rng_chi_squared_cdf(double degrees_of_freedom, double value);`
- `double rng_chi_squared_pdf(double degrees_of_freedom, double value);`
- `double rng_gamma_cdf(double shape, double scale, double value);`
- `double rng_gamma_pdf(double shape, double scale, double value);`
- `float ft_random_beta(float alpha, float beta);`
- `float ft_random_chi_squared(float degrees_of_freedom);`
- `float ft_random_exponential(float lambda_value);`
- `float ft_random_float(void);`
- `float ft_random_gamma(float shape, float scale);`
- `float ft_random_normal(void);`
- `int ft_dice_roll(int number, int faces);`
- `int ft_random_binomial(int trial_count, double success_probability);`
- `int ft_random_float_vector(float *output_values, size_t output_count);`
- `int ft_random_geometric(double success_probability);`
- `int ft_random_int_vector(int minimum_value, int maximum_value, int *output_values, size_t output_count);`
- `int ft_random_poisson(double lambda_value);`
- `int rng_secure_bytes(unsigned char *buffer, size_t length);`
- `int rng_secure_bytes_with_fallback(unsigned char *buffer, size_t length, int *fallback_used);`
- `int rng_secure_uint32(uint32_t *value, int *fallback_used = ft_nullptr);`
- `int rng_secure_uint64(uint64_t *value, int *fallback_used = ft_nullptr);`
- `int rng_stream_seed(uint64_t base_seed, uint64_t stream_identifier, uint64_t *stream_seed);`
- `int rng_stream_seed_from_string(const char *seed_string, uint64_t stream_identifier, uint64_t *stream_seed);`
- `int rng_stream_seed_sequence(uint64_t base_seed, uint64_t stream_identifier, uint32_t *buffer, size_t count);`
- `int rng_stream_seed_sequence_from_string(const char *seed_string, uint64_t stream_identifier, uint32_t *buffer, size_t count);`
- `uint32_t ft_random_seed(const char *seed_str = ft_nullptr);`
- `uint32_t ft_random_uint32(void);`
- `void ft_generate_uuid(char out[37]);`

### RNG/rng_distribution_functions.cpp

- `double rng_beta_cdf(double alpha, double beta, double value)`
- `double rng_beta_pdf(double alpha, double beta, double value)`
- `double rng_chi_squared_cdf(double degrees_of_freedom, double value)`
- `double rng_chi_squared_pdf(double degrees_of_freedom, double value)`
- `double rng_gamma_cdf(double shape, double scale, double value)`
- `double rng_gamma_pdf(double shape, double scale, double value)`
- `static double rng_beta_pdf_integrand(double value, void *context)`
- `static double rng_gamma_pdf_integrand(double value, void *context)`
- `static double rng_simpson_integral(double start, double end, int segment_total, rng_integrand function, void *context)`
- `static int rng_adjust_segment_total(int segment_total)`

### RNG/rng_engine.cpp

- `std::atomic<bool> g_random_engine_seeded(false);`
- `void ft_seed_random_engine(uint32_t seed_value)`
- `void ft_seed_random_engine_with_entropy(void)`

### RNG/rng_internal.hpp

- `inline __attribute__((always_inline)) void ft_init_random_engine(void)`
- `void ft_seed_random_engine(uint32_t seed_value);`
- `void ft_seed_random_engine_with_entropy(void);`

### RNG/rng_random_vector.cpp

- `int ft_random_float_vector(float *output_values, size_t output_count)`
- `int ft_random_int_vector(int minimum_value, int maximum_value, int *output_values, size_t output_count)`
- `static void ft_random_store_float_block(float *output_values, const float *generated_values) noexcept`

### RNG/rng_secure_bytes.cpp

- `uint32_t ft_random_uint32(void)`

### RNG/rng_secure_wrappers.cpp

- `int rng_secure_bytes_with_fallback(unsigned char *buffer, size_t length, int *fallback_used)`
- `int rng_secure_uint32(uint32_t *value, int *fallback_used)`
- `int rng_secure_uint64(uint64_t *value, int *fallback_used)`

### RNG/rng_stream.cpp

- `const char *rng_stream::get_error_str() const`
- `float rng_stream::random_beta(float alpha, float beta)`
- `float rng_stream::random_chi_squared(float degrees_of_freedom)`
- `float rng_stream::random_exponential(float lambda_value)`
- `float rng_stream::random_float()`
- `float rng_stream::random_float_unlocked()`
- `float rng_stream::random_gamma(float shape, float scale)`
- `float rng_stream::random_normal()`
- `int rng_stream::dice_roll(int number, int faces)`
- `int rng_stream::get_error() const`
- `int rng_stream::random_binomial(int trial_count, double success_probability)`
- `int rng_stream::random_geometric(double success_probability)`
- `int rng_stream::random_int()`
- `int rng_stream::random_int_unlocked()`
- `int rng_stream::random_poisson(double lambda_value)`
- `void rng_stream::reseed(uint32_t seed_value)`
- `void rng_stream::reseed_from_string(const char *seed_string)`
- `void rng_stream::set_error(int error_code) const`

### RNG/rng_stream.hpp

- `const char *get_error_str() const;`
- `explicit rng_stream(uint32_t seed_value);`
- `float random_beta(float alpha, float beta);`
- `float random_chi_squared(float degrees_of_freedom);`
- `float random_exponential(float lambda_value);`
- `float random_float();`
- `float random_float_unlocked();`
- `float random_gamma(float shape, float scale);`
- `float random_normal();`
- `int dice_roll(int number, int faces);`
- `int get_error() const;`
- `int random_binomial(int trial_count, double success_probability);`
- `int random_geometric(double success_probability);`
- `int random_int();`
- `int random_int_unlocked();`
- `int random_poisson(double lambda_value);`
- `public: rng_stream();`
- `void reseed(uint32_t seed_value);`
- `void reseed_from_string(const char *seed_string);`
- `void set_error(int error_code) const;`

### RNG/rng_stream_split.cpp

- `int rng_stream_seed(uint64_t base_seed, uint64_t stream_identifier, uint64_t *stream_seed)`
- `int rng_stream_seed_from_string(const char *seed_string, uint64_t stream_identifier, uint64_t *stream_seed)`
- `int rng_stream_seed_sequence(uint64_t base_seed, uint64_t stream_identifier, uint32_t *buffer, size_t count)`
- `int rng_stream_seed_sequence_from_string(const char *seed_string, uint64_t stream_identifier, uint32_t *buffer, size_t count)`
- `static uint64_t rng_initialize_state(uint64_t base_seed, uint64_t stream_identifier)`

### ReadLine/readline.cpp

- `char *rl_readline(const char *prompt)`
- `static char *rl_error(readline_state_t *state)`
- `static int rl_last_error_with_fallback(int fallback_error)`
- `static void rl_cleanup_state(readline_state_t *state)`

### ReadLine/readline.hpp

- `char *rl_readline(const char *prompt) __attribute__((warn_unused_result));`
- `const char *rl_history_get_backend(void);`
- `int rl_bind_key(int key, t_rl_key_binding_callback callback, void *user_data);`
- `int rl_completion_add_candidate(const char *candidate);`
- `int rl_history_enable_auto_save(bool enabled);`
- `int rl_history_load(void);`
- `int rl_history_save(void);`
- `int rl_history_search(const char *query, int start_index, bool search_backward, int *match_index);`
- `int rl_history_set_backend(const char *backend_name, const char *location);`
- `int rl_history_set_storage_path(const char *file_path);`
- `int rl_set_completion_callback(t_rl_completion_callback callback, void *user_data);`
- `int rl_state_delete_previous_grapheme(s_readline_state *state);`
- `int rl_state_get_buffer(s_readline_state *state, const char **out_buffer);`
- `int rl_state_get_cursor(s_readline_state *state, int *out_position);`
- `int rl_state_insert_text(s_readline_state *state, const char *text);`
- `int rl_state_refresh_display(s_readline_state *state, const char *prompt);`
- `int rl_state_set_cursor(s_readline_state *state, int new_position);`
- `int rl_unbind_key(int key);`
- `void rl_add_suggestion(const char *word);`
- `void rl_clear_history();`
- `void rl_clear_suggestions();`

### ReadLine/readline_customization.cpp

- `char *rl_completion_get_dynamic_match(int index)`
- `const char *rl_history_get_backend(void)`
- `int (*configure)(void **context_pointer, const char *location);`
- `int (*load)(void *context_pointer);`
- `int (*save)(void *context_pointer);`
- `int rl_bind_key(int key, t_rl_key_binding_callback callback, void *user_data)`
- `int rl_completion_add_candidate(const char *candidate)`
- `int rl_completion_get_dynamic_count(void)`
- `int rl_completion_prepare_candidates(const char *buffer, int cursor_position, const char *prefix, int prefix_length)`
- `int rl_dispatch_custom_key(readline_state_t *state, const char *prompt, int key)`
- `int rl_history_enable_auto_save(bool enabled)`
- `int rl_history_load(void)`
- `int rl_history_save(void)`
- `int rl_history_set_backend(const char *backend_name, const char *location)`
- `int rl_history_set_storage_path(const char *file_path)`
- `int rl_set_completion_callback(t_rl_completion_callback callback, void *user_data)`
- `int rl_state_delete_previous_grapheme(readline_state_t *state)`
- `int rl_state_get_buffer(readline_state_t *state, const char **out_buffer)`
- `int rl_state_get_cursor(readline_state_t *state, int *out_position)`
- `int rl_state_insert_text(readline_state_t *state, const char *text)`
- `int rl_state_refresh_display(readline_state_t *state, const char *prompt)`
- `int rl_state_set_cursor(readline_state_t *state, int new_position)`
- `int rl_unbind_key(int key)`
- `static const rl_history_backend *rl_history_find_backend(const char *backend_name)`
- `static int rl_customization_lock(bool *lock_acquired)`
- `static int rl_customization_lock_mutex(void)`
- `static int rl_customization_unlock(bool lock_acquired)`
- `static int rl_customization_unlock_mutex(void)`
- `static int rl_history_assign_path(char **target_path, const char *location)`
- `static int rl_history_configure_backend_locked(const rl_history_backend *backend, const char *location)`
- `static int rl_history_json_configure(void **context_pointer, const char *location)`
- `static int rl_history_json_load(void *context_pointer)`
- `static int rl_history_json_save(void *context_pointer)`
- `static int rl_history_plain_configure(void **context_pointer, const char *location)`
- `static int rl_history_plain_load(void *context_pointer)`
- `static int rl_history_plain_save(void *context_pointer)`
- `static int rl_history_prepare_path_context(void **context_pointer, const char *location)`
- `static int rl_history_sqlite_configure(void **context_pointer, const char *location)`
- `static int rl_history_sqlite_load(void *context_pointer)`
- `static int rl_history_sqlite_save(void *context_pointer)`
- `static void rl_completion_reset_dynamic_matches_locked(void)`
- `static void rl_history_json_shutdown(void *context_pointer)`
- `static void rl_history_plain_shutdown(void *context_pointer)`
- `static void rl_history_sqlite_shutdown(void *context_pointer)`
- `void (*shutdown)(void *context_pointer);`
- `void rl_completion_reset_dynamic_matches(void)`
- `void rl_history_notify_updated(void)`

### ReadLine/readline_error.cpp

- `int rl_internal_consume_error(void)`
- `int rl_internal_get_error(void)`
- `void rl_internal_set_error(int error_code)`

### ReadLine/readline_handle_keypress.cpp

- `int rl_handle_escape_sequence(readline_state_t *state, const char *prompt)`
- `int rl_read_escape_sequence(char seq[2])`
- `static int rl_copy_history_entry_to_buffer(readline_state_t *state, const char *history_entry)`
- `static int rl_handle_arrow_keys(readline_state_t *state, const char *prompt, char direction)`
- `static int rl_handle_down_arrow(readline_state_t *state, const char *prompt)`
- `static int rl_handle_up_arrow(readline_state_t *state, const char *prompt)`
- `static void rl_handle_left_arrow(readline_state_t *state, const char *prompt)`
- `static void rl_handle_right_arrow(readline_state_t *state, const char *prompt)`
- `static void rl_reset_completion_mode_locked(readline_state_t *state)`
- `void rl_reset_completion_mode(readline_state_t *state)`

### ReadLine/readline_initialize.cpp

- `int rl_initialize_state(readline_state_t *state)`

### ReadLine/readline_internal.hpp

- `char *rl_completion_get_dynamic_match(int index);`
- `char *rl_resize_buffer(char **buffer_pointer, int *current_size_pointer, int new_size);`
- `const char *rl_history_get_backend(void);`
- `int rl_bind_key(int key, t_rl_key_binding_callback callback, void *user_data);`
- `int rl_clear_line(const char *prompt, const char *buffer);`
- `int rl_completion_add_candidate(const char *candidate);`
- `int rl_completion_get_dynamic_count(void);`
- `int rl_completion_prepare_candidates(const char *buffer, int cursor_position, const char *prefix, int prefix_length);`
- `int rl_dispatch_custom_key(readline_state_t *state, const char *prompt, int key);`
- `int rl_enable_raw_mode();`
- `int rl_get_terminal_width(void);`
- `int rl_handle_backspace(readline_state_t *state, const char *prompt);`
- `int rl_handle_escape_sequence(readline_state_t *state, const char *prompt);`
- `int rl_handle_printable_char(readline_state_t *state, char c, const char *prompt);`
- `int rl_handle_tab_completion(readline_state_t *state, const char *prompt);`
- `int rl_history_enable_auto_save(bool enabled);`
- `int rl_history_load(void);`
- `int rl_history_save(void);`
- `int rl_history_search(const char *query, int start_index, bool search_backward, int *match_index);`
- `int rl_history_set_backend(const char *backend_name, const char *location);`
- `int rl_history_set_storage_path(const char *file_path);`
- `int rl_initialize_state(readline_state_t *state);`
- `int rl_internal_consume_error(void);`
- `int rl_internal_get_error(void);`
- `int rl_read_escape_sequence(char seq[2]);`
- `int rl_read_key(void);`
- `int rl_set_completion_callback(t_rl_completion_callback callback, void *user_data);`
- `int rl_state_delete_previous_grapheme(readline_state_t *state);`
- `int rl_state_get_buffer(readline_state_t *state, const char **out_buffer);`
- `int rl_state_get_cursor(readline_state_t *state, int *out_position);`
- `int rl_state_insert_text(readline_state_t *state, const char *text);`
- `int rl_state_lock(readline_state_t *state, bool *lock_acquired);`
- `int rl_state_prepare_thread_safety(readline_state_t *state);`
- `int rl_state_refresh_display(readline_state_t *state, const char *prompt);`
- `int rl_state_set_cursor(readline_state_t *state, int new_position);`
- `int rl_state_unlock(readline_state_t *state, bool lock_acquired);`
- `int rl_terminal_dimensions_get(terminal_dimensions *dimensions, unsigned short *rows, unsigned short *cols, unsigned short *x_pixels, unsigned short *y_pixels, bool *dimensions_valid);`
- `int rl_terminal_dimensions_lock(terminal_dimensions *dimensions, bool *lock_acquired);`
- `int rl_terminal_dimensions_prepare_thread_safety(terminal_dimensions *dimensions);`
- `int rl_terminal_dimensions_refresh(terminal_dimensions *dimensions);`
- `int rl_terminal_dimensions_unlock(terminal_dimensions *dimensions, bool lock_acquired);`
- `int rl_unbind_key(int key);`
- `int rl_update_display_metrics(readline_state_t *state);`
- `int rl_utf8_compute_columns(const char *string, int *columns);`
- `int rl_utf8_find_next_grapheme(const char *buffer, int cursor_pos, int *start_byte, int *end_byte, int *display_width);`
- `int rl_utf8_find_previous_grapheme(const char *buffer, int cursor_pos, int *start_byte, int *end_byte, int *display_width);`
- `void rl_completion_reset_dynamic_matches(void);`
- `void rl_disable_raw_mode();`
- `void rl_history_notify_updated(void);`
- `void rl_internal_set_error(int error_code);`
- `void rl_reset_completion_mode(readline_state_t *state);`
- `void rl_state_teardown_thread_safety(readline_state_t *state);`
- `void rl_terminal_dimensions_teardown_thread_safety(terminal_dimensions *dimensions);`
- `void rl_update_history(const char *buffer);`

### ReadLine/readline_raw_mode.cpp

- `int rl_enable_raw_mode()`

### ReadLine/readline_suggestions.cpp

- `void rl_clear_suggestions()`

### ReadLine/readline_tab_completion.cpp

- `int rl_handle_tab_completion(readline_state_t *state, const char *prompt)`
- `static int rl_apply_completion(readline_state_t *state, const char *completion)`
- `static int rl_resize_buffer_if_needed(readline_state_t *state, int required_size)`
- `static void rl_gather_matching_suggestions(readline_state_t *state, const char *prefix, int prefix_len)`
- `static void rl_update_display(const char *prompt, readline_state_t *state)`

### ReadLine/readline_terminal_dimensions.cpp

- `int rl_terminal_dimensions_get(terminal_dimensions *dimensions, unsigned short *rows, unsigned short *cols, unsigned short *x_pixels, unsigned short *y_pixels, bool *dimensions_valid)`
- `int rl_terminal_dimensions_lock(terminal_dimensions *dimensions, bool *lock_acquired)`
- `int rl_terminal_dimensions_prepare_thread_safety(terminal_dimensions *dimensions)`
- `int rl_terminal_dimensions_refresh(terminal_dimensions *dimensions)`
- `int rl_terminal_dimensions_unlock(terminal_dimensions *dimensions, bool lock_acquired)`
- `static int rl_terminal_dimensions_lock_mutex(pt_mutex *mutex_pointer)`
- `static int rl_terminal_dimensions_unlock_mutex(pt_mutex *mutex_pointer)`
- `static void rl_terminal_dimensions_clear(terminal_dimensions *dimensions)`
- `void rl_terminal_dimensions_teardown_thread_safety(terminal_dimensions *dimensions)`

### ReadLine/readline_thread_safety.cpp

- `int rl_state_lock(readline_state_t *state, bool *lock_acquired)`
- `int rl_state_prepare_thread_safety(readline_state_t *state)`
- `int rl_state_unlock(readline_state_t *state, bool lock_acquired)`
- `static int rl_state_lock_mutex(pt_mutex *mutex_pointer)`
- `static int rl_state_unlock_mutex(pt_mutex *mutex_pointer)`
- `void rl_state_teardown_thread_safety(readline_state_t *state)`

### ReadLine/readline_utf8.cpp

- `int rl_update_display_metrics(readline_state_t *state)`
- `int rl_utf8_compute_columns(const char *string, int *columns)`
- `int rl_utf8_find_next_grapheme(const char *buffer, int cursor_pos, int *start_byte, int *end_byte, int *display_width)`
- `int rl_utf8_find_previous_grapheme(const char *buffer, int cursor_pos, int *start_byte, int *end_byte, int *display_width)`
- `static int rl_utf8_compute_columns_range_internal(const char *string, size_t buffer_length, size_t start_index, size_t end_index, int *columns)`
- `static int rl_utf8_extract_grapheme(const char *buffer, size_t buffer_length, size_t start_index, size_t *end_index, size_t *byte_length, int *display_width)`
- `static int rl_utf8_measure_grapheme_width(const char *buffer, size_t grapheme_length, int *display_width)`

### ReadLine/readline_utilities.cpp

- `int rl_clear_line(const char *prompt, const char *buffer)`
- `int rl_history_search(const char *query, int start_index, bool search_backward, int *match_index)`
- `int rl_read_key(void)`
- `static int rl_history_utf32_contains(const char32_t *haystack, size_t haystack_length, const char32_t *needle, size_t needle_length)`
- `void rl_update_history(const char *buffer)`

### SCMA/SCMA.hpp

- `cleanup: if (scma_mutex_unlock() != 0)`
- `ft_size_t scma_get_size(scma_handle handle);`
- `ft_size_t scma_mutex_lock_count(void);`
- `int scma_free(scma_handle handle);`
- `int scma_get_stats(scma_stats *out_stats);`
- `int scma_handle_is_valid(scma_handle handle);`
- `int scma_initialize(ft_size_t initial_capacity);`
- `int scma_is_initialized(void);`
- `int scma_mutex_close(void);`
- `int scma_mutex_lock(void);`
- `int scma_mutex_unlock(void);`
- `int scma_pop_operation_error(void);`
- `int scma_read(scma_handle handle, ft_size_t offset, void *destination, ft_size_t size);`
- `int scma_resize(scma_handle handle, ft_size_t new_size);`
- `int scma_write(scma_handle handle, ft_size_t offset, const void *source, ft_size_t size);`
- `pt_recursive_mutex &scma_runtime_mutex(void);`
- `scma_handle scma_allocate(ft_size_t size);`
- `template <typename TValue> inline const char *scma_handle_accessor<TValue>::get_error_str(void) const`
- `template <typename TValue> inline const char *scma_handle_accessor_const_element_proxy<TValue>::get_error_str(void) const`
- `template <typename TValue> inline const char *scma_handle_accessor_element_proxy<TValue>::get_error_str(void) const`
- `template <typename TValue> inline ft_size_t scma_handle_accessor<TValue>::get_count(void) const`
- `template <typename TValue> inline int scma_handle_accessor<TValue>::bind(scma_handle handle)`
- `template <typename TValue> inline int scma_handle_accessor<TValue>::get_error(void) const`
- `template <typename TValue> inline int scma_handle_accessor<TValue>::is_bound(void) const`
- `template <typename TValue> inline int scma_handle_accessor<TValue>::read_at(TValue &destination, ft_size_t element_index) const`
- `template <typename TValue> inline int scma_handle_accessor<TValue>::read_struct(TValue &destination) const`
- `template <typename TValue> inline int scma_handle_accessor<TValue>::write_at(const TValue &source, ft_size_t element_index) const`
- `template <typename TValue> inline int scma_handle_accessor<TValue>::write_struct(const TValue &source) const`
- `template <typename TValue> inline int scma_handle_accessor_const_element_proxy<TValue>::get_error(void) const`
- `template <typename TValue> inline int scma_handle_accessor_element_proxy<TValue>::get_error(void) const`
- `template <typename TValue> inline scma_handle scma_handle_accessor<TValue>::get_handle(void) const`
- `template <typename TValue> inline scma_handle_accessor<TValue>::scma_handle_accessor(const scma_handle_accessor &other)`
- `template <typename TValue> inline scma_handle_accessor<TValue>::scma_handle_accessor(scma_handle handle)`
- `template <typename TValue> inline scma_handle_accessor<TValue>::scma_handle_accessor(scma_handle_accessor &&other)`
- `template <typename TValue> inline scma_handle_accessor<TValue>::scma_handle_accessor(void)`
- `template <typename TValue> inline scma_handle_accessor<TValue>::~scma_handle_accessor(void)`
- `template <typename TValue> inline scma_handle_accessor_const_element_proxy<TValue>::scma_handle_accessor_const_element_proxy(const scma_handle_accessor<TValue> *parent, ft_size_t element_index)`
- `template <typename TValue> inline scma_handle_accessor_const_element_proxy<TValue>::scma_handle_accessor_const_element_proxy(scma_handle_accessor_const_element_proxy &&other)`
- `template <typename TValue> inline scma_handle_accessor_const_element_proxy<TValue>::~scma_handle_accessor_const_element_proxy(void)`
- `template <typename TValue> inline scma_handle_accessor_element_proxy<TValue>::scma_handle_accessor_element_proxy(scma_handle_accessor<TValue> *parent, ft_size_t element_index)`
- `template <typename TValue> inline scma_handle_accessor_element_proxy<TValue>::scma_handle_accessor_element_proxy(scma_handle_accessor_element_proxy &&other)`
- `template <typename TValue> inline scma_handle_accessor_element_proxy<TValue>::~scma_handle_accessor_element_proxy(void)`
- `template <typename TValue> inline void scma_handle_accessor<TValue>::set_error(int error_code) const`
- `template <typename TValue> inline void scma_handle_accessor_const_element_proxy<TValue>::set_error(int error_code) const`
- `template <typename TValue> inline void scma_handle_accessor_element_proxy<TValue>::set_error(int error_code) const`
- `template <typename TValue> void scma_handle_accessor<TValue>::record_operation_error(int error_code) noexcept`
- `template <typename TValue> void scma_handle_accessor_const_element_proxy<TValue>::record_operation_error(int error_code) noexcept`
- `template <typename TValue> void scma_handle_accessor_element_proxy<TValue>::record_operation_error(int error_code) noexcept`
- `unsigned long long scma_record_operation_error(int error_code);`
- `void scma_debug_dump(void);`
- `void scma_shutdown(void);`

### SCMA/scma_allocator.cpp

- `ft_size_t scma_get_size(scma_handle handle)`
- `int scma_free(scma_handle handle)`
- `int scma_handle_is_valid(scma_handle handle)`
- `int scma_is_initialized(void)`
- `int scma_resize(scma_handle handle, ft_size_t new_size)`
- `scma_handle scma_allocate(ft_size_t size)`
- `void scma_shutdown(void)`

### SCMA/scma_debug.cpp

- `void scma_debug_dump(void)`

### SCMA/scma_error_stack.cpp

- `int scma_pop_operation_error(void)`
- `unsigned long long scma_record_operation_error(int error_code)`

### SCMA/scma_internal.hpp

- `ft_size_t &scma_block_capacity_ref(void);`
- `ft_size_t &scma_block_count_ref(void);`
- `ft_size_t &scma_heap_capacity_ref(void);`
- `ft_size_t &scma_used_size_ref(void);`
- `ft_size_t scma_next_generation(ft_size_t generation);`
- `ft_size_t scma_unlock_and_return_size(ft_size_t value);`
- `int &scma_initialized_ref(void);`
- `int scma_ensure_block_capacity(ft_size_t required_count);`
- `int scma_ensure_capacity(ft_size_t required_size);`
- `int scma_handle_is_invalid(scma_handle handle);`
- `int scma_pop_operation_error(void);`
- `int scma_unlock_and_return_int(int value);`
- `int scma_validate_handle(scma_handle handle, scma_block **out_block);`
- `scma_block *&scma_blocks_data_ref(void);`
- `scma_block_span scma_get_block_span(void);`
- `scma_handle scma_invalid_handle(void);`
- `scma_handle scma_unlock_and_return_handle(scma_handle value);`
- `unsigned char *&scma_heap_data_ref(void);`
- `unsigned char *scma_get_heap_data(void);`
- `unsigned long long scma_record_operation_error(int error_code);`
- `void *scma_unlock_and_return_pointer(void *value);`
- `void scma_compact(void);`
- `void scma_unlock_and_return_void(void);`

### SCMA/scma_io.cpp

- `int scma_read(scma_handle handle, ft_size_t offset, void *destination, ft_size_t size)`

### SCMA/scma_mutex.cpp

- `ft_size_t scma_mutex_lock_count(void)`
- `int scma_mutex_close(void)`
- `int scma_mutex_lock(void)`
- `int scma_mutex_unlock(void)`
- `pt_recursive_mutex &scma_runtime_mutex(void)`
- `static ft_size_t &scma_runtime_lock_depth(void)`

### SCMA/scma_state.cpp

- `ft_size_t &scma_block_capacity_ref(void)`
- `ft_size_t &scma_block_count_ref(void)`
- `ft_size_t &scma_heap_capacity_ref(void)`
- `ft_size_t &scma_used_size_ref(void)`
- `ft_size_t scma_next_generation(ft_size_t generation)`
- `ft_size_t scma_unlock_and_return_size(ft_size_t value)`
- `int &scma_initialized_ref(void)`
- `int scma_ensure_block_capacity(ft_size_t required_count)`
- `int scma_ensure_capacity(ft_size_t required_size)`
- `int scma_handle_is_invalid(scma_handle handle)`
- `int scma_unlock_and_return_int(int value)`
- `int scma_validate_handle(scma_handle handle, scma_block **out_block)`
- `scma_block *&scma_blocks_data_ref(void)`
- `scma_block_span scma_get_block_span(void)`
- `scma_handle scma_invalid_handle(void)`
- `scma_handle scma_unlock_and_return_handle(scma_handle value)`
- `static scma_handle scma_create_invalid_handle(void)`
- `unsigned char *&scma_heap_data_ref(void)`
- `unsigned char *scma_get_heap_data(void)`
- `void *scma_unlock_and_return_pointer(void *value)`
- `void scma_compact(void)`
- `void scma_unlock_and_return_void(void)`

### Storage/kv_store.hpp

- `int kv_store_init_delete_operation(kv_store_operation &operation, const char *key_string);`
- `int kv_store_init_set_operation(kv_store_operation &operation, const char *key_string, const char *value_string, long long ttl_seconds = -1);`

### Storage/storage_kv_store_constructor.cpp

- `template <typename ContainerType> static int storage_kv_pop_newest_error(ContainerType &container) noexcept`

### Storage/storage_kv_store_encryption.cpp

- `int kv_store::configure_encryption(const char *encryption_key, bool enable_encryption)`
- `int kv_store::decrypt_value(const ft_string &encoded_string, ft_string &plain_string) const`

### Storage/storage_kv_store_entry.cpp

- `const char *kv_store_entry::get_error_str() const noexcept`
- `int kv_store_entry::configure_expiration(bool has_expiration, long long expiration_timestamp) noexcept`
- `int kv_store_entry::copy_value(ft_string &destination) const noexcept`
- `int kv_store_entry::get_error() const noexcept`
- `int kv_store_entry::get_expiration(long long &expiration_timestamp) const noexcept`
- `int kv_store_entry::get_value_pointer(const char **value_pointer) const noexcept`
- `int kv_store_entry::has_expiration(bool &has_expiration) const noexcept`
- `int kv_store_entry::is_expired(long long current_time, bool &expired) const noexcept`
- `int kv_store_entry::lock_entry(ft_unique_lock<pt_mutex> &guard) const noexcept`
- `int kv_store_entry::set_value(const char *value_string) noexcept`
- `int kv_store_entry::set_value(const ft_string &value) noexcept`
- `void kv_store_entry::reinitialize_mutex() noexcept`
- `void kv_store_entry::set_error(int error_code) const noexcept`
- `void kv_store_entry::set_error_unlocked(int error_code) const noexcept`

### Storage/storage_kv_store_operations.cpp

- `const char *kv_store::get_error_str() const`
- `const char *kv_store::kv_get(const char *key_string) const`
- `int kv_store::apply_snapshot_locked(const ft_vector<kv_store_snapshot_entry> &entries)`
- `int kv_store::assign_backend_location(const char *location)`
- `int kv_store::compute_expiration(long long ttl_seconds, bool &has_expiration, long long &expiration_timestamp) const`
- `int kv_store::dispatch_snapshot_to_sink(kv_store_replication_snapshot_callback snapshot_callback, void *user_data) const`
- `int kv_store::export_snapshot(ft_vector<kv_store_snapshot_entry> &out_entries) const`
- `int kv_store::export_snapshot_to_file(const char *file_path) const`
- `int kv_store::flush_backend_entries(const ft_vector<kv_store_snapshot_entry> &entries) const`
- `int kv_store::flush_json_entries(const ft_vector<kv_store_snapshot_entry> &entries) const`
- `int kv_store::flush_json_lines_entries(const ft_vector<kv_store_snapshot_entry> &entries) const`
- `int kv_store::flush_memory_mapped_entries(const ft_vector<kv_store_snapshot_entry> &entries) const`
- `int kv_store::flush_sqlite_entries(const ft_vector<kv_store_snapshot_entry> &entries) const`
- `int kv_store::get_error() const`
- `int kv_store::get_metrics(kv_store_metrics &out_metrics) const`
- `int kv_store::import_snapshot(const ft_vector<kv_store_snapshot_entry> &entries)`
- `int kv_store::kv_apply(const ft_vector<kv_store_operation> &operations)`
- `int kv_store::kv_compare_and_swap(const char *key_string, const char *expected_value, const char *new_value, long long ttl_seconds)`
- `int kv_store::kv_delete(const char *key_string)`
- `int kv_store::kv_flush() const`
- `int kv_store::kv_set(const char *key_string, const char *value_string, long long ttl_seconds)`
- `int kv_store::load_backend_entries(kv_store_backend_type backend_type, const char *location, ft_vector<kv_store_snapshot_entry> &out_entries)`
- `int kv_store::load_json_entries(const char *location, ft_vector<kv_store_snapshot_entry> &out_entries)`
- `int kv_store::load_json_lines_entries(const char *location, ft_vector<kv_store_snapshot_entry> &out_entries)`
- `int kv_store::load_memory_mapped_entries(const char *location, ft_vector<kv_store_snapshot_entry> &out_entries)`
- `int kv_store::load_sqlite_entries(const char *location, ft_vector<kv_store_snapshot_entry> &out_entries)`
- `int kv_store::lock_background(ft_unique_lock<pt_mutex> &guard) const noexcept`
- `int kv_store::lock_replication(ft_unique_lock<pt_mutex> &guard) const noexcept`
- `int kv_store::lock_store(ft_unique_lock<pt_mutex> &guard) const noexcept`
- `int kv_store::notify_replication_listeners(const ft_vector<kv_store_operation> &operations) const`
- `int kv_store::parse_expiration_timestamp(const char *value_string, long long &expiration_timestamp) const`
- `int kv_store::parse_json_groups(json_group *group_head, ft_vector<kv_store_snapshot_entry> &out_entries)`
- `int kv_store::prune_expired()`
- `int kv_store::prune_expired_locked(ft_unique_lock<pt_mutex> &guard)`
- `int kv_store::read_snapshot(ft_document_source &source)`
- `int kv_store::register_replication_sink(kv_store_replication_operations_callback operations_callback, kv_store_replication_snapshot_callback snapshot_callback, void *user_data, bool ship_initial_snapshot)`
- `int kv_store::set_backend(kv_store_backend_type backend_type, const char *location)`
- `int kv_store::ship_replication_snapshot(kv_store_replication_snapshot_callback snapshot_callback, void *user_data) const`
- `int kv_store::start_background_compaction(long long interval_seconds)`
- `int kv_store::start_background_thread_locked(long long interval_seconds) noexcept`
- `int kv_store::stop_background_compaction()`
- `int kv_store::unregister_replication_sink(kv_store_replication_operations_callback operations_callback, kv_store_replication_snapshot_callback snapshot_callback, void *user_data)`
- `int kv_store::write_snapshot(ft_document_sink &sink) const`
- `int kv_store_init_delete_operation(kv_store_operation &operation, const char *key_string)`
- `int kv_store_init_set_operation(kv_store_operation &operation, const char *key_string, const char *value_string, long long ttl_seconds)`
- `kv_store_backend_type kv_store::get_backend() const`
- `long long kv_store::current_time_seconds() const`
- `static int kv_store_operation_error(kv_store_operation &operation)`
- `static int storage_kv_move_string_error(ft_string &value) noexcept`
- `static int storage_kv_pop_guard_error(const ft_unique_lock<pt_mutex> &guard) noexcept`
- `static int storage_kv_pop_string_error(ft_string &value) noexcept`
- `static int storage_kv_write_newline(su_file *stream) noexcept`
- `static long long storage_kv_parse_long_long(const char *value_string, char **end_pointer, int numeric_base) noexcept`
- `static void kv_store_finalize_lock(ft_unique_lock<pt_mutex> &guard) noexcept`
- `template <typename ContainerType> static int storage_kv_pop_newest_error(const ContainerType &container) noexcept`
- `void kv_store::background_compaction_worker(kv_store *store) noexcept`
- `void kv_store::record_delete_operation() const noexcept`
- `void kv_store::record_get_hit() const noexcept`
- `void kv_store::record_get_miss() const noexcept`
- `void kv_store::record_operation_error(int error_code) const noexcept`
- `void kv_store::record_prune_metrics(long long removed_entries, long long duration_ms) const noexcept`
- `void kv_store::record_set_operation() const noexcept`
- `void kv_store::set_error(int error_code) const noexcept`
- `void kv_store::set_error_unlocked(int error_code) const noexcept`
- `void kv_store::stop_background_thread_locked(ft_thread &thread_holder) noexcept`
- `void kv_store::unlock_store_guard(ft_unique_lock<pt_mutex> &guard, int error_code) const noexcept`

### System_utils/System_utils_abort.cpp

- `void su_abort(void)`

### System_utils/System_utils_assert.cpp

- `void su_assert(bool condition, const char *message)`

### System_utils/System_utils_env.cpp

- `char *su_getenv(const char *name)`
- `int su_environment_sandbox_begin(t_su_environment_snapshot *snapshot)`
- `int su_environment_sandbox_end(t_su_environment_snapshot *snapshot)`
- `int su_environment_snapshot_capture(t_su_environment_snapshot *snapshot)`
- `int su_environment_snapshot_restore(const t_su_environment_snapshot *snapshot)`
- `int su_putenv(char *string)`
- `int su_setenv(const char *name, const char *value, int overwrite)`
- `static int su_environment_snapshot_contains( const t_su_environment_snapshot *snapshot, const ft_string &name, int *is_present)`
- `static int su_environment_split_entry( const char *entry, ft_string &name, ft_string &value, int *has_value)`
- `static int su_environment_unlock_with_error(int error_code)`
- `void su_environment_snapshot_dispose(t_su_environment_snapshot *snapshot)`

### System_utils/System_utils_file_io.cpp

- `int su_close(int file_descriptor)`
- `ssize_t su_read(int file_descriptor, void *buffer, size_t count)`
- `ssize_t su_write(int file_descriptor, const void *buffer, size_t count)`
- `static ssize_t su_default_write_syscall(int file_descriptor, const void *buffer, size_t count)`
- `void su_reset_write_syscall_hook(void)`
- `void su_set_write_syscall_hook(t_su_write_syscall_hook hook)`

### System_utils/System_utils_file_open.cpp

- `int su_open(const char *path_name, int flags)`
- `int su_open(const char *path_name, int flags, mode_t mode)`

### System_utils/System_utils_file_stream.cpp

- `int su_fclose(su_file *stream)`
- `int su_file_lock(su_file *stream, bool *lock_acquired)`
- `int su_file_prepare_thread_safety(su_file *stream)`
- `int su_fseek(su_file *stream, long offset, int origin)`
- `long su_ftell(su_file *stream)`
- `size_t su_fread(void *buffer, size_t size, size_t count, su_file *stream)`
- `size_t su_fwrite(const void *buffer, size_t size, size_t count, su_file *stream)`
- `static int su_file_lock_mutex(pt_mutex *mutex_pointer)`
- `static int su_file_unlock_mutex(pt_mutex *mutex_pointer)`
- `static su_file *create_file_stream(int file_descriptor, int *error_code)`
- `su_file *su_fopen(const char *path_name)`
- `su_file *su_fopen(const char *path_name, int flags)`
- `su_file *su_fopen(const char *path_name, int flags, mode_t mode)`
- `void su_clear_forced_fread_failure(void)`
- `void su_file_teardown_thread_safety(su_file *stream)`
- `void su_file_unlock(su_file *stream, bool lock_acquired)`
- `void su_force_file_stream_allocation_failure(bool should_fail)`
- `void su_force_fread_failure(int error_code)`

### System_utils/System_utils_file_utils.cpp

- `int su_copy_directory_recursive(const char *source_path, const char *destination_path)`
- `int su_copy_file(const char *source_path, const char *destination_path)`
- `int su_inspect_permissions(const char *path, mode_t *permissions_out)`
- `static ft_string su_join_paths(const char *left_path, const char *right_path)`
- `static int su_copy_directory_contents(const char *source_path, const char *destination_path, int *error_code_out)`
- `static int su_copy_file_streams(su_file *source_stream, su_file *destination_stream, int *error_code_out)`
- `static int su_ensure_directory_exists(const char *path, int *error_code_out)`

### System_utils/System_utils_health.cpp

- `int su_health_register_check(const char *name, t_su_health_check check, void *context)`
- `int su_health_run_check(const char *name, t_su_health_check_result *result)`
- `int su_health_run_checks(t_su_health_check_result *results, size_t capacity, size_t *count)`
- `int su_health_unregister_check(const char *name)`
- `static int su_health_copy_entry(const s_su_health_check_entry &source, s_su_health_check_entry &destination)`
- `static int su_health_execute_entry(const s_su_health_check_entry &entry, t_su_health_check_result *result)`
- `void su_health_clear_checks(void)`

### System_utils/System_utils_locale.cpp

- `int su_locale_casefold(const char *input, const char *locale_name, ft_string &output)`
- `int su_locale_compare(const char *left, const char *right, const char *locale_name, int *result)`

### System_utils/System_utils_resource_tracer.cpp

- `const char *su_internal_take_abort_reason(void)`
- `int su_register_resource_tracer(t_su_resource_tracer tracer)`
- `int su_unregister_resource_tracer(t_su_resource_tracer tracer)`
- `static int su_resource_tracer_report(int error_code, int return_value)`
- `static void su_log_resource_tracing_event(const char *reason)`
- `static void su_resource_tracer_report_void(int error_code)`
- `void su_clear_resource_tracers(void)`
- `void su_internal_set_abort_reason(const char *reason)`
- `void su_run_resource_tracers(const char *reason)`

### System_utils/System_utils_service.cpp

- `int su_service_daemonize(const char *working_directory, const char *pid_file_path, bool redirect_standard_streams)`
- `int su_service_install_signal_handlers(t_su_service_signal_handler handler, void *user_context)`
- `static BOOL WINAPI su_service_console_handler(DWORD control_type)`
- `static int su_service_redirect_standard_streams(int *error_code)`
- `static int su_service_write_pid_file(const char *pid_file_path, int *error_code)`
- `static void (*g_su_service_previous_sigint)(int) = SIG_DFL;`
- `static void (*g_su_service_previous_sigterm)(int) = SIG_DFL;`
- `static void su_service_c_signal_dispatch(int signal_number)`
- `static void su_service_signal_dispatch(int signal_number)`
- `void su_service_clear_signal_handlers(void)`

### System_utils/System_utils_sysinfo.cpp

- `unsigned long long su_get_total_memory(void)`

### System_utils/system_utils.hpp

- `char *su_get_home_directory(void);`
- `char *su_getenv(const char *name);`
- `const char *su_internal_take_abort_reason(void);`
- `int su_close(int file_descriptor);`
- `int su_copy_directory_recursive(const char *source_path, const char *destination_path);`
- `int su_copy_file(const char *source_path, const char *destination_path);`
- `int su_environment_sandbox_begin(t_su_environment_snapshot *snapshot);`
- `int su_environment_sandbox_end(t_su_environment_snapshot *snapshot);`
- `int su_environment_snapshot_capture(t_su_environment_snapshot *snapshot);`
- `int su_environment_snapshot_restore(const t_su_environment_snapshot *snapshot);`
- `int su_fclose(su_file *stream);`
- `int su_file_lock(su_file *stream, bool *lock_acquired);`
- `int su_file_prepare_thread_safety(su_file *stream);`
- `int su_fseek(su_file *stream, long offset, int origin);`
- `int su_health_register_check(const char *name, t_su_health_check check, void *context);`
- `int su_health_run_check(const char *name, t_su_health_check_result *result);`
- `int su_health_run_checks(t_su_health_check_result *results, size_t capacity, size_t *count);`
- `int su_health_unregister_check(const char *name);`
- `int su_inspect_permissions(const char *path, mode_t *permissions_out);`
- `int su_locale_casefold(const char *input, const char *locale_name, ft_string &output);`
- `int su_locale_compare(const char *left, const char *right, const char *locale_name, int *result);`
- `int su_open(const char *path_name);`
- `int su_open(const char *path_name, int flags);`
- `int su_open(const char *path_name, int flags, mode_t mode);`
- `int su_putenv(char *string);`
- `int su_register_resource_tracer(t_su_resource_tracer tracer);`
- `int su_service_daemonize(const char *working_directory, const char *pid_file_path, bool redirect_standard_streams);`
- `int su_service_install_signal_handlers(t_su_service_signal_handler handler, void *user_context);`
- `int su_setenv(const char *name, const char *value, int overwrite);`
- `int su_unregister_resource_tracer(t_su_resource_tracer tracer);`
- `long su_ftell(su_file *stream);`
- `size_t su_fread(void *buffer, size_t size, size_t count, su_file *stream);`
- `size_t su_fwrite(const void *buffer, size_t size, size_t count, su_file *stream);`
- `ssize_t su_read(int file_descriptor, void *buffer, size_t count);`
- `ssize_t su_write(int file_descriptor, const void *buffer, size_t count);`
- `su_file *su_fopen(const char *path_name);`
- `su_file *su_fopen(const char *path_name, int flags);`
- `su_file *su_fopen(const char *path_name, int flags, mode_t mode);`
- `unsigned int su_get_cpu_count(void);`
- `unsigned long long su_get_total_memory(void);`
- `void su_abort(void);`
- `void su_assert(bool condition, const char *message);`
- `void su_clear_forced_fread_failure(void);`
- `void su_clear_resource_tracers(void);`
- `void su_environment_snapshot_dispose(t_su_environment_snapshot *snapshot);`
- `void su_file_teardown_thread_safety(su_file *stream);`
- `void su_file_unlock(su_file *stream, bool lock_acquired);`
- `void su_force_file_stream_allocation_failure(bool should_fail);`
- `void su_force_fread_failure(int error_code);`
- `void su_health_clear_checks(void);`
- `void su_internal_set_abort_reason(const char *reason);`
- `void su_reset_write_syscall_hook(void);`
- `void su_run_resource_tracers(const char *reason);`
- `void su_service_clear_signal_handlers(void);`
- `void su_service_force_no_fork(bool enable);`
- `void su_set_write_syscall_hook(t_su_write_syscall_hook hook);`
- `void su_sigabrt(void);`
- `void su_sigfpe(void);`
- `void su_sigill(void);`
- `void su_sigint(void);`
- `void su_sigsegv(void);`
- `void su_sigterm(void);`

### System_utils/test_runner.cpp

- `int ft_register_test(t_test_func func, const char *description, const char *module, const char *name)`
- `int ft_run_registered_tests(void)`
- `static const char *get_name_filter(void)`
- `static int execute_test_function(const s_test_case *test)`
- `static int get_test_capacity(void)`
- `static int name_matches_filter(const char *filter, const char *name)`
- `static int test_is_selected(const s_test_case *test)`
- `static s_test_case *get_tests(void)`
- `static void sort_tests(void)`
- `static void swap_test_cases(s_test_case *left, s_test_case *right)`
- `void ft_test_fail(const char *expression, const char *file, int line)`

### System_utils/test_runner.hpp

- `\ (stream).read((buffer), (count));`
- `\ FT_ASSERT_EQ(false, ft_stream_bad_result__);`
- `\ if (!(expression)) \`
- `\ if ((expected) != (actual)) \`
- `\ if ((expected) == (actual)) \`
- `\ if ((unexpected) == (actual)) \`
- `\ if (ft_error_stack_depth_after != ft_error_stack_depth_before + 1) \`
- `\ if (ft_error_stack_depth_after__ != ft_error_stack_depth_before__ + 1) \`
- `\ if (std::fabs(ft_expected_value - ft_actual_value) > 0.0000001) \`
- `\ if (std::strcmp(ft_expected_value, ft_actual_value) != 0) \`
- `\ static int name(void) #define FT_ASSERT(expression) \ do \`
- `\ static void register_##name(void) \`
- `\ static void register_##name(void) __attribute__((constructor));`
- `int ft_run_registered_tests(void);`
- `void ft_test_fail(const char *expression, const char *file, int line);`

### Template/algorithm.hpp

- `template <typename BidirectionalIt> void ft_reverse(BidirectionalIt first, BidirectionalIt last)`
- `template <typename RandomIt, typename T, typename Compare> bool ft_binary_search(RandomIt first, RandomIt last, const T& value, Compare comp)`
- `template <typename RandomIt, typename T> bool ft_binary_search(RandomIt first, RandomIt last, const T& value)`
- `template <typename RandomIt> void ft_shuffle(RandomIt first, RandomIt last)`
- `template <typename RandomIt> void ft_sort(RandomIt first, RandomIt last)`

### Template/bitset.hpp

- `bool is_thread_safe_enabled() const;`
- `bool test(size_t pos) const;`
- `const char* get_error_str() const;`
- `inline bool ft_bitset::is_thread_safe_enabled() const`
- `inline bool ft_bitset::test(size_t pos) const`
- `inline const char* ft_bitset::get_error_str() const`
- `inline int ft_bitset::enable_thread_safety()`
- `inline int ft_bitset::get_error() const`
- `inline int ft_bitset::lock(bool *lock_acquired) const`
- `inline int ft_bitset::lock_internal(bool *lock_acquired) const`
- `inline size_t ft_bitset::bit_mask(size_t pos) const`
- `inline size_t ft_bitset::block_index(size_t pos) const`
- `inline size_t ft_bitset::size() const`
- `inline void *ft_bitset::get_mutex_address_debug() const`
- `inline void ft_bitset::clear()`
- `inline void ft_bitset::disable_thread_safety()`
- `inline void ft_bitset::flip(size_t pos)`
- `inline void ft_bitset::reset(size_t pos)`
- `inline void ft_bitset::reset_storage(size_t size) noexcept`
- `inline void ft_bitset::set(size_t pos)`
- `inline void ft_bitset::set_error(int error) const`
- `inline void ft_bitset::teardown_thread_safety()`
- `inline void ft_bitset::unlock(bool lock_acquired) const`
- `inline void ft_bitset::unlock_internal(bool lock_acquired) const`
- `int enable_thread_safety();`
- `int get_error() const;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `public: explicit ft_bitset(size_t bits = 0);`
- `size_t bit_mask(size_t pos) const;`
- `size_t block_index(size_t pos) const;`
- `size_t size() const;`
- `void *get_mutex_address_debug() const;`
- `void clear();`
- `void disable_thread_safety();`
- `void flip(size_t pos);`
- `void reset(size_t pos);`
- `void reset_storage(size_t size) noexcept;`
- `void set(size_t pos);`
- `void set_error(int error) const;`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void unlock_internal(bool lock_acquired) const;`

### Template/cancellation.hpp

- `inline bool ft_cancellation_source::is_cancellation_requested() const noexcept`
- `inline bool ft_cancellation_token::is_cancellation_requested() const noexcept`
- `inline bool ft_cancellation_token::is_valid() const noexcept`
- `inline const char *ft_cancellation_source::get_error_str() const noexcept`
- `inline const char *ft_cancellation_token::get_error_str() const noexcept`
- `inline ft_cancellation_token ft_cancellation_source::get_token() const noexcept`
- `inline int ft_cancellation_source::get_error() const noexcept`
- `inline int ft_cancellation_token::get_error() const noexcept`
- `inline int ft_cancellation_token::register_callback(const ft_function<void()> &callback) const noexcept`
- `inline void ft_cancellation_source::request_cancel() noexcept`
- `inline void ft_cancellation_source::set_error(int error_code) const noexcept`
- `inline void ft_cancellation_token::set_error(int error_code) const noexcept`

### Template/circular_buffer.hpp

- `ElementType pop();`
- `bool is_empty() const;`
- `bool is_full() const;`
- `bool is_thread_safe() const;`
- `const char* get_error_str() const;`
- `int enable_thread_safety();`
- `int get_error() const;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `int prepare_thread_safety();`
- `public: explicit ft_circular_buffer(size_t capacity);`
- `size_t capacity() const;`
- `size_t size() const;`
- `template <typename ElementType> ElementType ft_circular_buffer<ElementType>::pop()`
- `template <typename ElementType> bool ft_circular_buffer<ElementType>::is_empty() const`
- `template <typename ElementType> bool ft_circular_buffer<ElementType>::is_full() const`
- `template <typename ElementType> bool ft_circular_buffer<ElementType>::is_thread_safe() const`
- `template <typename ElementType> const char* ft_circular_buffer<ElementType>::get_error_str() const`
- `template <typename ElementType> ft_circular_buffer<ElementType>::ft_circular_buffer(ft_circular_buffer&& other) noexcept : _buffer(ft_nullptr), _capacity(0), _head(0), _tail(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ElementType> ft_circular_buffer<ElementType>::ft_circular_buffer(size_t capacity) : _buffer(ft_nullptr), _capacity(capacity), _head(0), _tail(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ElementType> ft_circular_buffer<ElementType>::~ft_circular_buffer()`
- `template <typename ElementType> int ft_circular_buffer<ElementType>::enable_thread_safety()`
- `template <typename ElementType> int ft_circular_buffer<ElementType>::get_error() const`
- `template <typename ElementType> int ft_circular_buffer<ElementType>::lock(bool *lock_acquired) const`
- `template <typename ElementType> int ft_circular_buffer<ElementType>::lock_internal(bool *lock_acquired) const`
- `template <typename ElementType> int ft_circular_buffer<ElementType>::prepare_thread_safety()`
- `template <typename ElementType> size_t ft_circular_buffer<ElementType>::capacity() const`
- `template <typename ElementType> size_t ft_circular_buffer<ElementType>::size() const`
- `template <typename ElementType> void ft_circular_buffer<ElementType>::clear()`
- `template <typename ElementType> void ft_circular_buffer<ElementType>::destroy_elements_locked()`
- `template <typename ElementType> void ft_circular_buffer<ElementType>::disable_thread_safety()`
- `template <typename ElementType> void ft_circular_buffer<ElementType>::push(ElementType&& value)`
- `template <typename ElementType> void ft_circular_buffer<ElementType>::push(const ElementType& value)`
- `template <typename ElementType> void ft_circular_buffer<ElementType>::release_buffer_locked()`
- `template <typename ElementType> void ft_circular_buffer<ElementType>::set_error(int error) const`
- `template <typename ElementType> void ft_circular_buffer<ElementType>::set_error_unlocked(int error) const`
- `template <typename ElementType> void ft_circular_buffer<ElementType>::teardown_thread_safety()`
- `template <typename ElementType> void ft_circular_buffer<ElementType>::unlock(bool lock_acquired) const`
- `template <typename ElementType> void ft_circular_buffer<ElementType>::unlock_internal(bool lock_acquired) const`
- `void clear();`
- `void destroy_elements_locked();`
- `void disable_thread_safety();`
- `void push(ElementType&& value);`
- `void push(const ElementType& value);`
- `void release_buffer_locked();`
- `void set_error(int error) const;`
- `void set_error_unlocked(int error) const;`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void unlock_internal(bool lock_acquired) const;`

### Template/constructor.hpp

- `template <typename T> constexpr T* construct_default_at(T* destination)`
- `template <typename T> constexpr void destroy_at(T* object)`

### Template/container_serialization.hpp

- `template <typename ElementType, typename Deserializer> int ft_vector_deserialize_json(json_group *group, const char *count_key, const char *item_prefix, ft_vector<ElementType> &output, Deserializer deserializer) noexcept`
- `template <typename ElementType, typename Deserializer> int ft_vector_deserialize_yaml(const yaml_value &value, ft_vector<ElementType> &output, Deserializer deserializer) noexcept`
- `template <typename ElementType, typename Serializer> int ft_vector_serialize_json(const ft_vector<ElementType> &values, const char *group_name, Serializer serializer, json_group *&output_group, const char *count_key = "count", const char *item_prefix = "item_") noexcept`
- `template <typename ElementType, typename Serializer> int ft_vector_serialize_yaml(const ft_vector<ElementType> &values, Serializer serializer, yaml_value *&output_value) noexcept`
- `template <typename ElementType> int default_string_deserializer(const char *value_string, ElementType &output) noexcept`
- `template <typename ElementType> int default_string_serializer(const ElementType &value, ft_string &output) noexcept`
- `template <typename ElementType> int ft_vector_deserialize_json(json_group *group, ft_vector<ElementType> &output, const char *count_key = "count", const char *item_prefix = "item_") noexcept`
- `template <typename ElementType> int ft_vector_deserialize_yaml(const yaml_value &value, ft_vector<ElementType> &output) noexcept`
- `template <typename ElementType> int ft_vector_serialize_json(const ft_vector<ElementType> &values, const char *group_name, json_group *&output_group, const char *count_key = "count", const char *item_prefix = "item_") noexcept`
- `template <typename ElementType> int ft_vector_serialize_yaml(const ft_vector<ElementType> &values, yaml_value *&output_value) noexcept`

### Template/deque.hpp

- `ElementType pop_back();`
- `ElementType pop_front();`
- `ElementType& back();`
- `ElementType& front();`
- `bool empty() const;`
- `bool is_thread_safe() const;`
- `const ElementType& back() const;`
- `const ElementType& front() const;`
- `const char* get_error_str() const;`
- `int enable_thread_safety();`
- `int get_error() const;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `public: ft_deque();`
- `size_t size() const;`
- `template <typename ElementType> ElementType ft_deque<ElementType>::pop_back()`
- `template <typename ElementType> ElementType ft_deque<ElementType>::pop_front()`
- `template <typename ElementType> ElementType& ft_deque<ElementType>::back()`
- `template <typename ElementType> ElementType& ft_deque<ElementType>::front()`
- `template <typename ElementType> bool ft_deque<ElementType>::empty() const`
- `template <typename ElementType> bool ft_deque<ElementType>::is_thread_safe() const`
- `template <typename ElementType> const ElementType& ft_deque<ElementType>::back() const`
- `template <typename ElementType> const ElementType& ft_deque<ElementType>::front() const`
- `template <typename ElementType> const char* ft_deque<ElementType>::get_error_str() const`
- `template <typename ElementType> ft_deque<ElementType>::ft_deque() : _front(ft_nullptr), _back(ft_nullptr), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ElementType> ft_deque<ElementType>::ft_deque(ft_deque&& other) noexcept : _front(ft_nullptr), _back(ft_nullptr), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ElementType> ft_deque<ElementType>::~ft_deque()`
- `template <typename ElementType> int ft_deque<ElementType>::enable_thread_safety()`
- `template <typename ElementType> int ft_deque<ElementType>::get_error() const`
- `template <typename ElementType> int ft_deque<ElementType>::lock(bool *lock_acquired) const`
- `template <typename ElementType> int ft_deque<ElementType>::lock_internal(bool *lock_acquired) const`
- `template <typename ElementType> size_t ft_deque<ElementType>::size() const`
- `template <typename ElementType> void ft_deque<ElementType>::clear()`
- `template <typename ElementType> void ft_deque<ElementType>::disable_thread_safety()`
- `template <typename ElementType> void ft_deque<ElementType>::push_back(ElementType&& value)`
- `template <typename ElementType> void ft_deque<ElementType>::push_back(const ElementType& value)`
- `template <typename ElementType> void ft_deque<ElementType>::push_front(ElementType&& value)`
- `template <typename ElementType> void ft_deque<ElementType>::push_front(const ElementType& value)`
- `template <typename ElementType> void ft_deque<ElementType>::set_error(int error) const`
- `template <typename ElementType> void ft_deque<ElementType>::teardown_thread_safety()`
- `template <typename ElementType> void ft_deque<ElementType>::unlock(bool lock_acquired) const`
- `template <typename ElementType> void ft_deque<ElementType>::unlock_internal(bool lock_acquired) const`
- `void clear();`
- `void disable_thread_safety();`
- `void push_back(ElementType&& value);`
- `void push_back(const ElementType& value);`
- `void push_front(ElementType&& value);`
- `void push_front(const ElementType& value);`
- `void set_error(int error) const;`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void unlock_internal(bool lock_acquired) const;`

### Template/event_emitter.hpp

- `bool empty() const;`
- `bool ensure_capacity(size_t desired);`
- `bool ensure_capacity_unlocked(size_t desired);`
- `const char* get_error_str() const;`
- `int get_error() const;`
- `public: ft_event_emitter(size_t initial_capacity = 0);`
- `size_t size() const;`
- `template <typename EventType, typename... Args> bool ft_event_emitter<EventType, Args...>::empty() const`
- `template <typename EventType, typename... Args> bool ft_event_emitter<EventType, Args...>::ensure_capacity(size_t desired)`
- `template <typename EventType, typename... Args> bool ft_event_emitter<EventType, Args...>::ensure_capacity_unlocked(size_t desired)`
- `template <typename EventType, typename... Args> const char* ft_event_emitter<EventType, Args...>::get_error_str() const`
- `template <typename EventType, typename... Args> ft_event_emitter<EventType, Args...>::ft_event_emitter(ft_event_emitter&& other) noexcept : _listeners(ft_nullptr), _capacity(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `template <typename EventType, typename... Args> ft_event_emitter<EventType, Args...>::ft_event_emitter(size_t initial_capacity) : _listeners(ft_nullptr), _capacity(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `template <typename EventType, typename... Args> ft_event_emitter<EventType, Args...>::~ft_event_emitter()`
- `template <typename EventType, typename... Args> int ft_event_emitter<EventType, Args...>::get_error() const`
- `template <typename EventType, typename... Args> size_t ft_event_emitter<EventType, Args...>::size() const`
- `template <typename EventType, typename... Args> void ft_event_emitter<EventType, Args...>::clear()`
- `template <typename EventType, typename... Args> void ft_event_emitter<EventType, Args...>::clear_unlocked()`
- `template <typename EventType, typename... Args> void ft_event_emitter<EventType, Args...>::emit(const EventType& event, Args... args)`
- `template <typename EventType, typename... Args> void ft_event_emitter<EventType, Args...>::on(const EventType& event, void (*callback)(Args...))`
- `template <typename EventType, typename... Args> void ft_event_emitter<EventType, Args...>::remove_listener(const EventType& event, void (*callback)(Args...))`
- `template <typename EventType, typename... Args> void ft_event_emitter<EventType, Args...>::set_error_unlocked(int error) const`
- `void clear();`
- `void clear_unlocked();`
- `void emit(const EventType& event, Args... args);`
- `void on(const EventType& event, void (*callback)(Args...));`
- `void remove_listener(const EventType& event, void (*callback)(Args...));`
- `void set_error_unlocked(int error) const;`

### Template/future.hpp

- `), _state_mutex()`
- `ValueType get() const;`
- `bool valid() const;`
- `bool wait_ready() const;`
- `const ft_operation_error_stack *get_operation_error_stack_for_validation() const noexcept;`
- `explicit ft_future(ft_promise<ValueType>& promise);`
- `explicit ft_future(ft_promise<void>& promise);`
- `explicit ft_future(ft_sharedptr<ft_promise<ValueType> > promise_pointer);`
- `explicit ft_future(ft_sharedptr<ft_promise<void> > promise_pointer);`
- `ft_operation_error_stack *get_operation_error_stack_for_testing() noexcept;`
- `ft_operation_error_stack *get_operation_error_stack_for_validation() noexcept;`
- `inline bool ft_future<void>::valid() const`
- `inline bool ft_future<void>::wait_ready() const`
- `inline const ft_operation_error_stack *ft_future<void>::get_operation_error_stack_for_validation() const noexcept`
- `inline ft_future<void>::ft_future() : _promise(ft_nullptr), _shared_promise(), _operation_errors(`
- `inline ft_future<void>::ft_future(const ft_future<void> &other) : _promise(ft_nullptr), _shared_promise(), _operation_errors(`
- `inline ft_future<void>::ft_future(ft_future<void> &&other) : _promise(ft_nullptr), _shared_promise(), _operation_errors(`
- `inline ft_future<void>::ft_future(ft_promise<void>& promise) : _promise(&promise), _shared_promise(), _operation_errors(`
- `inline ft_future<void>::ft_future(ft_sharedptr<ft_promise<void> > promise_pointer) : _promise(promise_pointer.get()), _shared_promise(promise_pointer), _operation_errors(`
- `inline ft_future<void>::~ft_future()`
- `inline ft_operation_error_stack *ft_future<void>::get_operation_error_stack_for_testing() noexcept`
- `inline ft_operation_error_stack *ft_future<void>::get_operation_error_stack_for_validation() noexcept`
- `inline int ft_future<void>::last_error_code() const`
- `inline int ft_future<void>::lock(bool *lock_acquired) const`
- `inline int ft_future<void>::lock_internal(bool *lock_acquired) const`
- `inline int ft_future<void>::unlock_internal(bool lock_acquired) const`
- `inline pt_recursive_mutex *ft_future<void>::get_mutex_for_testing() noexcept`
- `inline void ft_future<void>::get() const`
- `inline void ft_future<void>::initialize_mutex_state() const`
- `inline void ft_future<void>::record_operation_error(int error_code) const noexcept`
- `inline void ft_future<void>::report_result(int error_code) const`
- `inline void ft_future<void>::unlock(bool lock_acquired) const`
- `inline void ft_future<void>::wait() const`
- `int last_error_code() const;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `int unlock_internal(bool lock_acquired) const;`
- `public: ft_future();`
- `template <typename ValueType> ValueType ft_future<ValueType>::get() const`
- `template <typename ValueType> bool ft_future<ValueType>::valid() const`
- `template <typename ValueType> bool ft_future<ValueType>::wait_ready() const`
- `template <typename ValueType> const ft_operation_error_stack *ft_future<ValueType>::get_operation_error_stack_for_validation() const noexcept`
- `template <typename ValueType> ft_future<ValueType>::ft_future() : _promise(ft_nullptr), _shared_promise(), _operation_errors(`
- `template <typename ValueType> ft_future<ValueType>::ft_future(const ft_future<ValueType> &other) : _promise(ft_nullptr), _shared_promise(), _operation_errors(`
- `template <typename ValueType> ft_future<ValueType>::ft_future(ft_future<ValueType> &&other) : _promise(ft_nullptr), _shared_promise(), _operation_errors(`
- `template <typename ValueType> ft_future<ValueType>::ft_future(ft_promise<ValueType>& promise) : _promise(&promise), _shared_promise(), _operation_errors(`
- `template <typename ValueType> ft_future<ValueType>::ft_future(ft_sharedptr<ft_promise<ValueType> > promise_pointer) : _promise(promise_pointer.get()), _shared_promise(promise_pointer), _operation_errors(`
- `template <typename ValueType> ft_future<ValueType>::~ft_future()`
- `template <typename ValueType> ft_operation_error_stack *ft_future<ValueType>::get_operation_error_stack_for_testing() noexcept`
- `template <typename ValueType> ft_operation_error_stack *ft_future<ValueType>::get_operation_error_stack_for_validation() noexcept`
- `template <typename ValueType> int ft_future<ValueType>::last_error_code() const`
- `template <typename ValueType> int ft_future<ValueType>::lock(bool *lock_acquired) const`
- `template <typename ValueType> int ft_future<ValueType>::lock_internal(bool *lock_acquired) const`
- `template <typename ValueType> int ft_future<ValueType>::unlock_internal(bool lock_acquired) const`
- `template <typename ValueType> void ft_future<ValueType>::initialize_mutex_state() const`
- `template <typename ValueType> void ft_future<ValueType>::record_operation_error(int error_code) const noexcept`
- `template <typename ValueType> void ft_future<ValueType>::report_result(int error_code) const`
- `template <typename ValueType> void ft_future<ValueType>::unlock(bool lock_acquired) const`
- `template <typename ValueType> void ft_future<ValueType>::wait() const`
- `void get() const;`
- `void initialize_mutex_state() const;`
- `void record_operation_error(int error_code) const noexcept;`
- `void report_result(int error_code) const;`
- `void unlock(bool lock_acquired) const;`
- `void wait() const;`

### Template/graph.hpp

- `bool empty() const;`
- `bool ensure_edge_capacity(GraphNode& node, size_t desired);`
- `bool ensure_node_capacity(size_t desired);`
- `bool is_thread_safe() const;`
- `const char *last_operation_error_str() const noexcept;`
- `const char *operation_error_str_at(ft_size_t index) const noexcept;`
- `const char* get_error_str() const;`
- `ft_operation_error_stack *get_operation_error_stack_for_validation() noexcept;`
- `int enable_thread_safety();`
- `int get_error() const;`
- `int last_operation_error() const noexcept;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `int operation_error_at(ft_size_t index) const noexcept;`
- `int pop_newest_operation_error() noexcept;`
- `int pop_oldest_operation_error() noexcept;`
- `public: ft_graph(size_t initialCapacity = 0);`
- `size_t add_vertex(VertexType&& value);`
- `size_t add_vertex(const VertexType& value);`
- `size_t size() const;`
- `template <typename Func> void bfs(size_t start, Func visit);`
- `template <typename Func> void dfs(size_t start, Func visit);`
- `template <typename VertexType> bool ft_graph<VertexType>::empty() const`
- `template <typename VertexType> bool ft_graph<VertexType>::ensure_edge_capacity(GraphNode& node, size_t desired)`
- `template <typename VertexType> bool ft_graph<VertexType>::ensure_node_capacity(size_t desired)`
- `template <typename VertexType> bool ft_graph<VertexType>::is_thread_safe() const`
- `template <typename VertexType> const char *ft_graph<VertexType>::last_operation_error_str() const noexcept`
- `template <typename VertexType> const char *ft_graph<VertexType>::operation_error_str_at(ft_size_t index) const noexcept`
- `template <typename VertexType> const char* ft_graph<VertexType>::get_error_str() const`
- `template <typename VertexType> ft_graph<VertexType>::ft_graph(ft_graph&& other) noexcept : _nodes(ft_nullptr), _capacity(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _operation_errors(`
- `template <typename VertexType> ft_graph<VertexType>::ft_graph(size_t initialCapacity) : _nodes(ft_nullptr), _capacity(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _operation_errors(`
- `template <typename VertexType> ft_graph<VertexType>::~ft_graph()`
- `template <typename VertexType> ft_operation_error_stack *ft_graph<VertexType>::get_operation_error_stack_for_validation() noexcept`
- `template <typename VertexType> int ft_graph<VertexType>::enable_thread_safety()`
- `template <typename VertexType> int ft_graph<VertexType>::get_error() const`
- `template <typename VertexType> int ft_graph<VertexType>::last_operation_error() const noexcept`
- `template <typename VertexType> int ft_graph<VertexType>::lock(bool *lock_acquired) const`
- `template <typename VertexType> int ft_graph<VertexType>::lock_internal(bool *lock_acquired) const`
- `template <typename VertexType> int ft_graph<VertexType>::operation_error_at(ft_size_t index) const noexcept`
- `template <typename VertexType> int ft_graph<VertexType>::pop_newest_operation_error() noexcept`
- `template <typename VertexType> int ft_graph<VertexType>::pop_oldest_operation_error() noexcept`
- `template <typename VertexType> size_t ft_graph<VertexType>::add_vertex(VertexType&& value)`
- `template <typename VertexType> size_t ft_graph<VertexType>::add_vertex(const VertexType& value)`
- `template <typename VertexType> size_t ft_graph<VertexType>::size() const`
- `template <typename VertexType> template <typename Func> void ft_graph<VertexType>::bfs(size_t start, Func visit)`
- `template <typename VertexType> template <typename Func> void ft_graph<VertexType>::dfs(size_t start, Func visit)`
- `template <typename VertexType> void ft_graph<VertexType>::add_edge(size_t from, size_t to)`
- `template <typename VertexType> void ft_graph<VertexType>::clear()`
- `template <typename VertexType> void ft_graph<VertexType>::disable_thread_safety()`
- `template <typename VertexType> void ft_graph<VertexType>::neighbors(size_t index, ft_vector<size_t> &out) const`
- `template <typename VertexType> void ft_graph<VertexType>::pop_operation_errors() noexcept`
- `template <typename VertexType> void ft_graph<VertexType>::record_operation_error(int error_code) const noexcept`
- `template <typename VertexType> void ft_graph<VertexType>::set_error(int error_code) const`
- `template <typename VertexType> void ft_graph<VertexType>::teardown_thread_safety()`
- `template <typename VertexType> void ft_graph<VertexType>::unlock(bool lock_acquired) const`
- `template <typename VertexType> void ft_graph<VertexType>::unlock_internal(bool lock_acquired) const`
- `void add_edge(size_t from, size_t to);`
- `void clear();`
- `void disable_thread_safety();`
- `void neighbors(size_t index, ft_vector<size_t> &out) const;`
- `void pop_operation_errors() noexcept;`
- `void record_operation_error(int error_code) const noexcept;`
- `void set_error(int error_code) const;`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void unlock_internal(bool lock_acquired) const;`

### Template/invoke.hpp

- `template <typename InstanceType> constexpr auto access(InstanceType &&instance) -> typename std::enable_if<!is_pointer<InstanceType>::value, InstanceType &&>::type`
- `template <typename InstanceType> constexpr auto access(InstanceType &&instance) requires (!std::is_pointer_v<std::decay_t<InstanceType>>)`
- `template <typename MemberObject, typename InstanceType> constexpr auto ft_invoke(MemberObject &&member_object, InstanceType &&instance) #if FT_TEMPLATE_HAS_CONCEPTS requires std::is_member_object_pointer_v<std::decay_t<MemberObject>> #else -> typename std::enable_if< std::is_member_object_pointer<typename std::decay<MemberObject>::type>::value, decltype(ft_invoke_detail::access(std::forward<InstanceType>(instance)).* std::forward<MemberObject>(member_object))>::type #endif`

### Template/iterator.hpp

- `bool is_thread_safe_enabled() const noexcept;`
- `const char* get_error_str() const noexcept;`
- `int enable_thread_safety();`
- `int get_error() const noexcept;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `public: Iterator(ValueType* ptr) noexcept;`
- `template <typename ValueType> Iterator<ValueType>::Iterator(Iterator&& other) noexcept : _ptr(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ValueType> Iterator<ValueType>::Iterator(ValueType* ptr) noexcept : _ptr(ptr), _error_code(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ValueType> Iterator<ValueType>::Iterator(const Iterator& other) noexcept : _ptr(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ValueType> Iterator<ValueType>::~Iterator()`
- `template <typename ValueType> bool Iterator<ValueType>::is_thread_safe_enabled() const noexcept`
- `template <typename ValueType> const char* Iterator<ValueType>::get_error_str() const noexcept`
- `template <typename ValueType> int Iterator<ValueType>::enable_thread_safety()`
- `template <typename ValueType> int Iterator<ValueType>::get_error() const noexcept`
- `template <typename ValueType> int Iterator<ValueType>::lock(bool *lock_acquired) const`
- `template <typename ValueType> int Iterator<ValueType>::lock_internal(bool *lock_acquired) const`
- `template <typename ValueType> void Iterator<ValueType>::disable_thread_safety()`
- `template <typename ValueType> void Iterator<ValueType>::set_error(int error_code) const noexcept`
- `template <typename ValueType> void Iterator<ValueType>::teardown_thread_safety()`
- `template <typename ValueType> void Iterator<ValueType>::unlock(bool lock_acquired) const`
- `template <typename ValueType> void Iterator<ValueType>::unlock_internal(bool lock_acquired) const`
- `void disable_thread_safety();`
- `void set_error(int error_code) const noexcept;`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void unlock_internal(bool lock_acquired) const;`

### Template/map.hpp

- `), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`
- `MappedType& at(const Key& key);`
- `Pair<Key, MappedType>* end();`
- `Pair<Key, MappedType>* find(const Key& key);`
- `Pair<Key, MappedType>* get_end_pointer_unlocked();`
- `bool empty() const;`
- `bool is_thread_safe_enabled() const;`
- `const MappedType& at(const Key& key) const;`
- `const Pair<Key, MappedType>* end() const;`
- `const Pair<Key, MappedType>* find(const Key& key) const;`
- `const Pair<Key, MappedType>* get_end_pointer_unlocked() const;`
- `const char* last_operation_error_str() const noexcept;`
- `const char* operation_error_str_at(ft_size_t index) const noexcept;`
- `int enable_thread_safety();`
- `int last_operation_error() const noexcept;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `int operation_error_at(ft_size_t index) const noexcept;`
- `int pop_newest_operation_error() noexcept;`
- `int pop_oldest_operation_error() noexcept;`
- `int resize_unlocked(size_t new_capacity);`
- `int unlock_internal(bool lock_acquired) const;`
- `int unlock_mutex(pt_mutex *mutex, bool lock_acquired) const;`
- `public: ft_map(size_t initial_capacity = 10);`
- `size_t capacity() const;`
- `size_t find_index_unlocked(const Key& key) const;`
- `size_t size() const;`
- `template <typename Key, typename MappedType> MappedType& ft_map<Key, MappedType>::at(const Key& key)`
- `template <typename Key, typename MappedType> Pair<Key, MappedType>* ft_map<Key, MappedType>::end()`
- `template <typename Key, typename MappedType> Pair<Key, MappedType>* ft_map<Key, MappedType>::find(const Key& key)`
- `template <typename Key, typename MappedType> Pair<Key, MappedType>* ft_map<Key, MappedType>::get_end_pointer_unlocked()`
- `template <typename Key, typename MappedType> bool ft_map<Key, MappedType>::empty() const`
- `template <typename Key, typename MappedType> bool ft_map<Key, MappedType>::is_thread_safe_enabled() const`
- `template <typename Key, typename MappedType> const MappedType& ft_map<Key, MappedType>::at(const Key& key) const`
- `template <typename Key, typename MappedType> const Pair<Key, MappedType>* ft_map<Key, MappedType>::end() const`
- `template <typename Key, typename MappedType> const Pair<Key, MappedType>* ft_map<Key, MappedType>::find(const Key& key) const`
- `template <typename Key, typename MappedType> const Pair<Key, MappedType>* ft_map<Key, MappedType>::get_end_pointer_unlocked() const`
- `template <typename Key, typename MappedType> const char* ft_map<Key, MappedType>::last_operation_error_str() const noexcept`
- `template <typename Key, typename MappedType> const char* ft_map<Key, MappedType>::operation_error_str_at(ft_size_t index) const noexcept`
- `template <typename Key, typename MappedType> ft_map<Key, MappedType>::ft_map(const ft_map<Key, MappedType>& other) : _data(ft_nullptr), _capacity(0), _size(0), _operation_errors(`
- `template <typename Key, typename MappedType> ft_map<Key, MappedType>::ft_map(ft_map<Key, MappedType>&& other) noexcept : _data(ft_nullptr), _capacity(0), _size(0), _operation_errors(`
- `template <typename Key, typename MappedType> ft_map<Key, MappedType>::ft_map(size_t initial_capacity) : _data(ft_nullptr), _capacity(initial_capacity), _size(0), _operation_errors(`
- `template <typename Key, typename MappedType> ft_map<Key, MappedType>::~ft_map()`
- `template <typename Key, typename MappedType> int ft_map<Key, MappedType>::enable_thread_safety()`
- `template <typename Key, typename MappedType> int ft_map<Key, MappedType>::last_operation_error() const noexcept`
- `template <typename Key, typename MappedType> int ft_map<Key, MappedType>::lock(bool *lock_acquired) const`
- `template <typename Key, typename MappedType> int ft_map<Key, MappedType>::lock_internal(bool *lock_acquired) const`
- `template <typename Key, typename MappedType> int ft_map<Key, MappedType>::operation_error_at(ft_size_t index) const noexcept`
- `template <typename Key, typename MappedType> int ft_map<Key, MappedType>::pop_newest_operation_error() noexcept`
- `template <typename Key, typename MappedType> int ft_map<Key, MappedType>::pop_oldest_operation_error() noexcept`
- `template <typename Key, typename MappedType> int ft_map<Key, MappedType>::resize_unlocked(size_t new_capacity)`
- `template <typename Key, typename MappedType> int ft_map<Key, MappedType>::unlock_internal(bool lock_acquired) const`
- `template <typename Key, typename MappedType> int ft_map<Key, MappedType>::unlock_mutex(pt_mutex *mutex, bool lock_acquired) const`
- `template <typename Key, typename MappedType> size_t ft_map<Key, MappedType>::capacity() const`
- `template <typename Key, typename MappedType> size_t ft_map<Key, MappedType>::find_index_unlocked(const Key& key) const`
- `template <typename Key, typename MappedType> size_t ft_map<Key, MappedType>::size() const`
- `template <typename Key, typename MappedType> void ft_map<Key, MappedType>::clear()`
- `template <typename Key, typename MappedType> void ft_map<Key, MappedType>::disable_thread_safety()`
- `template <typename Key, typename MappedType> void ft_map<Key, MappedType>::insert(const Key& key, MappedType&& value)`
- `template <typename Key, typename MappedType> void ft_map<Key, MappedType>::insert(const Key& key, const MappedType& value)`
- `template <typename Key, typename MappedType> void ft_map<Key, MappedType>::pop_operation_errors() noexcept`
- `template <typename Key, typename MappedType> void ft_map<Key, MappedType>::record_operation_error(int error_code) const noexcept`
- `template <typename Key, typename MappedType> void ft_map<Key, MappedType>::remove(const Key& key)`
- `template <typename Key, typename MappedType> void ft_map<Key, MappedType>::teardown_thread_safety()`
- `template <typename Key, typename MappedType> void ft_map<Key, MappedType>::unlock(bool lock_acquired) const`
- `template <typename Key, typename MappedType> void* ft_map<Key, MappedType>::get_mutex_address_debug() const`
- `void clear();`
- `void disable_thread_safety();`
- `void insert(const Key& key, MappedType&& value);`
- `void insert(const Key& key, const MappedType& value);`
- `void pop_operation_errors() noexcept;`
- `void record_operation_error(int error_code) const noexcept;`
- `void remove(const Key& key);`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void* get_mutex_address_debug() const;`

### Template/math.hpp

- `template <typename T, typename U, typename Compare> constexpr std::common_type_t<T, U> ft_max(const T& a, const U& b, Compare comp) noexcept`
- `template <typename T, typename U, typename Compare> constexpr std::common_type_t<T, U> ft_min(const T& a, const U& b, Compare comp) noexcept`
- `template <typename T, typename U> constexpr std::common_type_t<T, U> ft_min(const T& a, const U& b) noexcept`

### Template/matrix.hpp

- `ElementType determinant() const;`
- `ElementType& at(size_t r, size_t c);`
- `bool init(size_t rows, size_t cols);`
- `bool is_thread_safe() const;`
- `const ElementType& at(size_t r, size_t c) const;`
- `const char* get_error_str() const;`
- `ft_matrix add(const ft_matrix& other) const;`
- `ft_matrix multiply(const ft_matrix& other) const;`
- `ft_matrix transpose() const;`
- `int enable_thread_safety();`
- `int get_error() const;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `public: ft_matrix(size_t rows = 0, size_t cols = 0);`
- `size_t cols() const;`
- `size_t rows() const;`
- `template <typename ElementType> ElementType ft_matrix<ElementType>::determinant() const`
- `template <typename ElementType> ElementType& ft_matrix<ElementType>::at(size_t r, size_t c)`
- `template <typename ElementType> bool ft_matrix<ElementType>::init(size_t rows, size_t cols)`
- `template <typename ElementType> bool ft_matrix<ElementType>::is_thread_safe() const`
- `template <typename ElementType> const ElementType& ft_matrix<ElementType>::at(size_t r, size_t c) const`
- `template <typename ElementType> const char* ft_matrix<ElementType>::get_error_str() const`
- `template <typename ElementType> ft_matrix<ElementType> ft_matrix<ElementType>::add(const ft_matrix& other) const`
- `template <typename ElementType> ft_matrix<ElementType> ft_matrix<ElementType>::multiply(const ft_matrix& other) const`
- `template <typename ElementType> ft_matrix<ElementType> ft_matrix<ElementType>::transpose() const`
- `template <typename ElementType> ft_matrix<ElementType>::ft_matrix(ft_matrix&& other) noexcept : _data(ft_nullptr), _rows(0), _cols(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ElementType> ft_matrix<ElementType>::ft_matrix(size_t rows, size_t cols) : _data(ft_nullptr), _rows(0), _cols(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ElementType> ft_matrix<ElementType>::~ft_matrix()`
- `template <typename ElementType> int ft_matrix<ElementType>::enable_thread_safety()`
- `template <typename ElementType> int ft_matrix<ElementType>::get_error() const`
- `template <typename ElementType> int ft_matrix<ElementType>::lock(bool *lock_acquired) const`
- `template <typename ElementType> int ft_matrix<ElementType>::lock_internal(bool *lock_acquired) const`
- `template <typename ElementType> size_t ft_matrix<ElementType>::cols() const`
- `template <typename ElementType> size_t ft_matrix<ElementType>::rows() const`
- `template <typename ElementType> void ft_matrix<ElementType>::clear()`
- `template <typename ElementType> void ft_matrix<ElementType>::clear_unlocked()`
- `template <typename ElementType> void ft_matrix<ElementType>::disable_thread_safety()`
- `template <typename ElementType> void ft_matrix<ElementType>::set_error(int error) const`
- `template <typename ElementType> void ft_matrix<ElementType>::teardown_thread_safety()`
- `template <typename ElementType> void ft_matrix<ElementType>::unlock(bool lock_acquired) const`
- `template <typename ElementType> void ft_matrix<ElementType>::unlock_internal(bool lock_acquired) const`
- `void clear();`
- `void clear_unlocked();`
- `void disable_thread_safety();`
- `void set_error(int error) const;`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void unlock_internal(bool lock_acquired) const;`

### Template/optional.hpp

- `T& value();`
- `bool has_value() const;`
- `const T& value() const;`
- `const char* get_error_str() const;`
- `int get_error() const;`
- `int lock_self(ft_unique_lock<pt_mutex> &guard) const noexcept;`
- `public: ft_optional();`
- `static T &fallback_reference() noexcept;`
- `static int lock_pair(ft_optional &first, ft_optional &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard) noexcept;`
- `static void sleep_backoff() noexcept;`
- `template <typename T> T &ft_optional<T>::fallback_reference() noexcept`
- `template <typename T> T& ft_optional<T>::value()`
- `template <typename T> bool ft_optional<T>::has_value() const`
- `template <typename T> const T& ft_optional<T>::value() const`
- `template <typename T> const char* ft_optional<T>::get_error_str() const`
- `template <typename T> ft_optional<T>::ft_optional() : _value(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `template <typename T> ft_optional<T>::ft_optional(T&& value) : _value(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `template <typename T> ft_optional<T>::ft_optional(const T& value) : _value(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `template <typename T> ft_optional<T>::ft_optional(ft_optional&& other) noexcept : _value(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `template <typename T> ft_optional<T>::~ft_optional()`
- `template <typename T> int ft_optional<T>::get_error() const`
- `template <typename T> int ft_optional<T>::lock_pair(ft_optional &first, ft_optional &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard) noexcept`
- `template <typename T> int ft_optional<T>::lock_self(ft_unique_lock<pt_mutex> &guard) const noexcept`
- `template <typename T> void ft_optional<T>::reset()`
- `template <typename T> void ft_optional<T>::set_error(int error) const`
- `template <typename T> void ft_optional<T>::sleep_backoff() noexcept`
- `void reset();`
- `void set_error(int error) const;`

### Template/pair.hpp

- `KeyType get_key() const;`
- `ValueType get_value() const;`
- `template <typename KeyType, typename ValueType> KeyType Pair<KeyType, ValueType>::get_key() const`
- `template <typename KeyType, typename ValueType> Pair<KeyType, ValueType>::Pair() : key(), value()`
- `template <typename KeyType, typename ValueType> Pair<KeyType, ValueType>::Pair(Pair &&other) : key(ft_move(other.key)), value(ft_move(other.value))`
- `template <typename KeyType, typename ValueType> Pair<KeyType, ValueType>::Pair(const KeyType &input_key, ValueType &&input_value) : key(input_key), value(ft_move(input_value))`
- `template <typename KeyType, typename ValueType> Pair<KeyType, ValueType>::Pair(const KeyType &input_key, const ValueType &input_value) : key(input_key), value(input_value)`
- `template <typename KeyType, typename ValueType> Pair<KeyType, ValueType>::Pair(const Pair &other) : key(other.key), value(other.value)`
- `template <typename KeyType, typename ValueType> Pair<KeyType, ValueType>::~Pair()`
- `template <typename KeyType, typename ValueType> Pair<typename ft_decay<KeyType>::type, typename ft_decay<ValueType>::type> ft_make_pair(KeyType &&key, ValueType &&value)`
- `template <typename KeyType, typename ValueType> ValueType Pair<KeyType, ValueType>::get_value() const`
- `template <typename KeyType, typename ValueType> void Pair<KeyType, ValueType>::set_key(KeyType &&input_key)`
- `template <typename KeyType, typename ValueType> void Pair<KeyType, ValueType>::set_key(const KeyType &input_key)`
- `template <typename KeyType, typename ValueType> void Pair<KeyType, ValueType>::set_value(ValueType &&input_value)`
- `template <typename KeyType, typename ValueType> void Pair<KeyType, ValueType>::set_value(const ValueType &input_value)`
- `void set_key(KeyType &&input_key);`
- `void set_key(const KeyType &input_key);`
- `void set_value(ValueType &&input_value);`
- `void set_value(const ValueType &input_value);`

### Template/pool.hpp

- `T* ptrAt(size_t idx) noexcept;`
- `bool is_thread_safe_enabled() const noexcept;`
- `const char* get_error_str() const noexcept;`
- `int enable_thread_safety() noexcept;`
- `int get_error() const noexcept;`
- `int lock(bool *lock_acquired) const noexcept;`
- `int lock_internal(bool *lock_acquired) const noexcept;`
- `private: using Storage = std::aligned_storage_t<sizeof(T), alignof(T)>;`
- `public: Pool();`
- `template<typename T> Pool<T>::Pool() : _buffer() , _freeIndices() , _error_code(FT_ERR_SUCCESSS) , _state_mutex(ft_nullptr) , _thread_safe_enabled(false)`
- `template<typename T> Pool<T>::Pool(Pool&& other) : _buffer() , _freeIndices() , _error_code(FT_ERR_SUCCESSS) , _state_mutex(ft_nullptr) , _thread_safe_enabled(false)`
- `template<typename T> Pool<T>::~Pool()`
- `template<typename T> T* Pool<T>::ptrAt(size_t idx) noexcept`
- `template<typename T> bool Pool<T>::Object::is_thread_safe_enabled() const noexcept`
- `template<typename T> bool Pool<T>::is_thread_safe_enabled() const noexcept`
- `template<typename T> const char* Pool<T>::Object::get_error_str() const noexcept`
- `template<typename T> const char* Pool<T>::get_error_str() const noexcept`
- `template<typename T> int Pool<T>::Object::enable_thread_safety() noexcept`
- `template<typename T> int Pool<T>::Object::get_error() const noexcept`
- `template<typename T> int Pool<T>::Object::lock(bool *lock_acquired) const noexcept`
- `template<typename T> int Pool<T>::Object::lock_internal(bool *lock_acquired) const noexcept`
- `template<typename T> int Pool<T>::enable_thread_safety() noexcept`
- `template<typename T> int Pool<T>::get_error() const noexcept`
- `template<typename T> int Pool<T>::lock(bool *lock_acquired) const noexcept`
- `template<typename T> int Pool<T>::lock_internal(bool *lock_acquired) const noexcept`
- `template<typename T> template<typename... Args> typename Pool<T>::Object Pool<T>::acquire(Args&&... args)`
- `template<typename T> void Pool<T>::Object::disable_thread_safety() noexcept`
- `template<typename T> void Pool<T>::Object::set_error(int error_code) const noexcept`
- `template<typename T> void Pool<T>::Object::set_error_unlocked(int error_code) const noexcept`
- `template<typename T> void Pool<T>::Object::teardown_thread_safety() noexcept`
- `template<typename T> void Pool<T>::Object::unlock(bool lock_acquired) const noexcept`
- `template<typename T> void Pool<T>::Object::unlock_internal(bool lock_acquired) const noexcept`
- `template<typename T> void Pool<T>::disable_thread_safety() noexcept`
- `template<typename T> void Pool<T>::release(size_t idx) noexcept`
- `template<typename T> void Pool<T>::resize(size_t new_size)`
- `template<typename T> void Pool<T>::set_error(int error_code) const noexcept`
- `template<typename T> void Pool<T>::set_error_unlocked(int error_code) const noexcept`
- `template<typename T> void Pool<T>::teardown_thread_safety() noexcept`
- `template<typename T> void Pool<T>::unlock(bool lock_acquired) const noexcept`
- `template<typename T> void Pool<T>::unlock_internal(bool lock_acquired) const noexcept`
- `void disable_thread_safety() noexcept;`
- `void release(size_t idx) noexcept;`
- `void resize(size_t new_size);`
- `void set_error(int error_code) const noexcept;`
- `void set_error_unlocked(int error_code) const noexcept;`
- `void teardown_thread_safety() noexcept;`
- `void unlock(bool lock_acquired) const noexcept;`
- `void unlock_internal(bool lock_acquired) const noexcept;`

### Template/priority_queue.hpp

- `ElementType pop();`
- `ElementType& top();`
- `bool empty() const;`
- `bool ensure_capacity(size_t desired);`
- `bool is_thread_safe() const;`
- `const ElementType& top() const;`
- `const char* get_error_str() const;`
- `int enable_thread_safety();`
- `int get_error() const;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `public: ft_priority_queue(size_t initialCapacity = 0, const Compare& comp = Compare());`
- `size_t size() const;`
- `template <typename ElementType, typename Compare> ElementType ft_priority_queue<ElementType, Compare>::pop()`
- `template <typename ElementType, typename Compare> ElementType& ft_priority_queue<ElementType, Compare>::top()`
- `template <typename ElementType, typename Compare> bool ft_priority_queue<ElementType, Compare>::empty() const`
- `template <typename ElementType, typename Compare> bool ft_priority_queue<ElementType, Compare>::ensure_capacity(size_t desired)`
- `template <typename ElementType, typename Compare> bool ft_priority_queue<ElementType, Compare>::is_thread_safe() const`
- `template <typename ElementType, typename Compare> const ElementType& ft_priority_queue<ElementType, Compare>::top() const`
- `template <typename ElementType, typename Compare> const char* ft_priority_queue<ElementType, Compare>::get_error_str() const`
- `template <typename ElementType, typename Compare> ft_priority_queue<ElementType, Compare>::ft_priority_queue(ft_priority_queue&& other) noexcept : _data(other._data), _capacity(other._capacity), _size(other._size), _comp(other._comp), _error_code(other._error_code), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ElementType, typename Compare> ft_priority_queue<ElementType, Compare>::ft_priority_queue(size_t initialCapacity, const Compare& comp) : _data(ft_nullptr), _capacity(0), _size(0), _comp(comp), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ElementType, typename Compare> ft_priority_queue<ElementType, Compare>::~ft_priority_queue()`
- `template <typename ElementType, typename Compare> int ft_priority_queue<ElementType, Compare>::enable_thread_safety()`
- `template <typename ElementType, typename Compare> int ft_priority_queue<ElementType, Compare>::get_error() const`
- `template <typename ElementType, typename Compare> int ft_priority_queue<ElementType, Compare>::lock(bool *lock_acquired) const`
- `template <typename ElementType, typename Compare> int ft_priority_queue<ElementType, Compare>::lock_internal(bool *lock_acquired) const`
- `template <typename ElementType, typename Compare> size_t ft_priority_queue<ElementType, Compare>::size() const`
- `template <typename ElementType, typename Compare> void ft_priority_queue<ElementType, Compare>::clear()`
- `template <typename ElementType, typename Compare> void ft_priority_queue<ElementType, Compare>::disable_thread_safety()`
- `template <typename ElementType, typename Compare> void ft_priority_queue<ElementType, Compare>::heapify_down(size_t index)`
- `template <typename ElementType, typename Compare> void ft_priority_queue<ElementType, Compare>::heapify_up(size_t index)`
- `template <typename ElementType, typename Compare> void ft_priority_queue<ElementType, Compare>::push(ElementType&& value)`
- `template <typename ElementType, typename Compare> void ft_priority_queue<ElementType, Compare>::push(const ElementType& value)`
- `template <typename ElementType, typename Compare> void ft_priority_queue<ElementType, Compare>::set_error(int error) const`
- `template <typename ElementType, typename Compare> void ft_priority_queue<ElementType, Compare>::teardown_thread_safety()`
- `template <typename ElementType, typename Compare> void ft_priority_queue<ElementType, Compare>::unlock(bool lock_acquired) const`
- `template <typename ElementType, typename Compare> void ft_priority_queue<ElementType, Compare>::unlock_internal(bool lock_acquired) const`
- `void clear();`
- `void disable_thread_safety();`
- `void heapify_down(size_t index);`
- `void heapify_up(size_t index);`
- `void push(ElementType&& value);`
- `void push(const ElementType& value);`
- `void set_error(int error) const;`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void unlock_internal(bool lock_acquired) const;`

### Template/promise.hpp

- `), _mutex(ft_nullptr)`
- `ValueType get() const;`
- `bool is_ready() const;`
- `bool is_thread_safe() const;`
- `const char *get_error_str() const;`
- `const char* get_error_str() const;`
- `inline bool ft_promise<void>::is_ready() const`
- `inline bool ft_promise<void>::is_thread_safe() const`
- `inline const char *ft_promise<void>::get_error_str() const`
- `inline ft_promise<void>::ft_promise() : _ready(false), _error_code(FT_ERR_SUCCESSS), _thread_safe_enabled(false), _operation_errors(`
- `inline ft_promise<void>::~ft_promise()`
- `inline int ft_promise<void>::enable_thread_safety()`
- `inline int ft_promise<void>::get_error() const`
- `inline int ft_promise<void>::lock(bool *lock_acquired) const`
- `inline int ft_promise<void>::lock_internal(bool *lock_acquired) const`
- `inline int ft_promise<void>::prepare_thread_safety()`
- `inline int ft_promise<void>::unlock_internal(bool lock_acquired) const`
- `inline void ft_promise<void>::disable_thread_safety()`
- `inline void ft_promise<void>::get() const`
- `inline void ft_promise<void>::record_operation_error(int error_code) const noexcept`
- `inline void ft_promise<void>::set_error(int error) const`
- `inline void ft_promise<void>::set_error_unlocked(int error) const`
- `inline void ft_promise<void>::set_value()`
- `inline void ft_promise<void>::teardown_thread_safety()`
- `inline void ft_promise<void>::unlock(bool lock_acquired) const`
- `int enable_thread_safety();`
- `int get_error() const;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `int prepare_thread_safety();`
- `int unlock_internal(bool lock_acquired) const;`
- `protected: void set_error(int error) const;`
- `public: ft_promise();`
- `template <typename ValueType> ValueType ft_promise<ValueType>::get() const`
- `template <typename ValueType> bool ft_promise<ValueType>::is_ready() const`
- `template <typename ValueType> bool ft_promise<ValueType>::is_thread_safe() const`
- `template <typename ValueType> const char* ft_promise<ValueType>::get_error_str() const`
- `template <typename ValueType> ft_promise<ValueType>::ft_promise() : _value(), _ready(false), _error_code(FT_ERR_SUCCESSS), _thread_safe_enabled(false), _operation_errors(`
- `template <typename ValueType> ft_promise<ValueType>::~ft_promise()`
- `template <typename ValueType> int ft_promise<ValueType>::enable_thread_safety()`
- `template <typename ValueType> int ft_promise<ValueType>::get_error() const`
- `template <typename ValueType> int ft_promise<ValueType>::lock(bool *lock_acquired) const`
- `template <typename ValueType> int ft_promise<ValueType>::lock_internal(bool *lock_acquired) const`
- `template <typename ValueType> int ft_promise<ValueType>::prepare_thread_safety()`
- `template <typename ValueType> int ft_promise<ValueType>::unlock_internal(bool lock_acquired) const`
- `template <typename ValueType> void ft_promise<ValueType>::disable_thread_safety()`
- `template <typename ValueType> void ft_promise<ValueType>::record_operation_error(int error_code) const noexcept`
- `template <typename ValueType> void ft_promise<ValueType>::set_error(int error) const`
- `template <typename ValueType> void ft_promise<ValueType>::set_error_unlocked(int error) const`
- `template <typename ValueType> void ft_promise<ValueType>::set_value(ValueType&& value)`
- `template <typename ValueType> void ft_promise<ValueType>::set_value(const ValueType& value)`
- `template <typename ValueType> void ft_promise<ValueType>::teardown_thread_safety()`
- `template <typename ValueType> void ft_promise<ValueType>::unlock(bool lock_acquired) const`
- `void disable_thread_safety();`
- `void get() const;`
- `void record_operation_error(int error_code) const noexcept;`
- `void set_error(int error) const;`
- `void set_error_unlocked(int error) const;`
- `void set_value();`
- `void set_value(ValueType&& value);`
- `void set_value(const ValueType& value);`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`

### Template/queue.hpp

- `), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `ElementType dequeue();`
- `ElementType& front();`
- `bool empty() const;`
- `bool is_thread_safe() const;`
- `const ElementType& front() const;`
- `const char *last_operation_error_str() const noexcept;`
- `const char *operation_error_str_at(ft_size_t index) const noexcept;`
- `const char* get_error_str() const;`
- `const ft_operation_error_stack *get_operation_error_stack_for_validation() const noexcept;`
- `ft_operation_error_stack *get_operation_error_stack_for_validation() noexcept;`
- `int enable_thread_safety();`
- `int get_error() const;`
- `int last_operation_error() const noexcept;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `int operation_error_at(ft_size_t index) const noexcept;`
- `int pop_newest_operation_error() noexcept;`
- `int pop_oldest_operation_error() noexcept;`
- `int unlock_internal(bool lock_acquired) const;`
- `public: ft_queue();`
- `size_t size() const;`
- `template <typename ElementType> ElementType ft_queue<ElementType>::dequeue()`
- `template <typename ElementType> ElementType& ft_queue<ElementType>::front()`
- `template <typename ElementType> bool ft_queue<ElementType>::empty() const`
- `template <typename ElementType> bool ft_queue<ElementType>::is_thread_safe() const`
- `template <typename ElementType> const ElementType& ft_queue<ElementType>::front() const`
- `template <typename ElementType> const char *ft_queue<ElementType>::last_operation_error_str() const noexcept`
- `template <typename ElementType> const char *ft_queue<ElementType>::operation_error_str_at(ft_size_t index) const noexcept`
- `template <typename ElementType> const char* ft_queue<ElementType>::get_error_str() const`
- `template <typename ElementType> const ft_operation_error_stack *ft_queue<ElementType>::get_operation_error_stack_for_validation() const noexcept`
- `template <typename ElementType> ft_operation_error_stack *ft_queue<ElementType>::get_operation_error_stack_for_validation() noexcept`
- `template <typename ElementType> ft_queue<ElementType>::ft_queue() : _front(ft_nullptr), _rear(ft_nullptr), _size(0), _error_code(FT_ERR_SUCCESSS), _operation_errors(`
- `template <typename ElementType> ft_queue<ElementType>::ft_queue(ft_queue&& other) noexcept : _front(ft_nullptr), _rear(ft_nullptr), _size(0), _error_code(FT_ERR_SUCCESSS), _operation_errors(`
- `template <typename ElementType> ft_queue<ElementType>::~ft_queue()`
- `template <typename ElementType> int ft_queue<ElementType>::enable_thread_safety()`
- `template <typename ElementType> int ft_queue<ElementType>::get_error() const`
- `template <typename ElementType> int ft_queue<ElementType>::last_operation_error() const noexcept`
- `template <typename ElementType> int ft_queue<ElementType>::lock(bool *lock_acquired) const`
- `template <typename ElementType> int ft_queue<ElementType>::lock_internal(bool *lock_acquired) const`
- `template <typename ElementType> int ft_queue<ElementType>::operation_error_at(ft_size_t index) const noexcept`
- `template <typename ElementType> int ft_queue<ElementType>::pop_newest_operation_error() noexcept`
- `template <typename ElementType> int ft_queue<ElementType>::pop_oldest_operation_error() noexcept`
- `template <typename ElementType> int ft_queue<ElementType>::unlock_internal(bool lock_acquired) const`
- `template <typename ElementType> size_t ft_queue<ElementType>::size() const`
- `template <typename ElementType> void ft_queue<ElementType>::clear()`
- `template <typename ElementType> void ft_queue<ElementType>::disable_thread_safety()`
- `template <typename ElementType> void ft_queue<ElementType>::enqueue(ElementType&& value)`
- `template <typename ElementType> void ft_queue<ElementType>::enqueue(const ElementType& value)`
- `template <typename ElementType> void ft_queue<ElementType>::pop_operation_errors() noexcept`
- `template <typename ElementType> void ft_queue<ElementType>::record_operation_error(int error_code) const noexcept`
- `template <typename ElementType> void ft_queue<ElementType>::set_error(int error_code) const`
- `template <typename ElementType> void ft_queue<ElementType>::teardown_thread_safety()`
- `template <typename ElementType> void ft_queue<ElementType>::unlock(bool lock_acquired) const`
- `void clear();`
- `void disable_thread_safety();`
- `void enqueue(ElementType&& value);`
- `void enqueue(const ElementType& value);`
- `void pop_operation_errors() noexcept;`
- `void record_operation_error(int error_code) const noexcept;`
- `void set_error(int error_code) const;`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`

### Template/set.hpp

- `ElementType* find(const ElementType& value);`
- `bool empty() const;`
- `bool ensure_capacity(size_t desired_capacity);`
- `bool is_thread_safe() const;`
- `const ElementType* find(const ElementType& value) const;`
- `const char* get_error_str() const;`
- `int enable_thread_safety();`
- `int get_error() const;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `public: ft_set(size_t initial_capacity = 0);`
- `size_t find_index(const ElementType& value) const;`
- `size_t lower_bound(const ElementType& value) const;`
- `size_t size() const;`
- `template <typename ElementType> ElementType* ft_set<ElementType>::find(const ElementType& value)`
- `template <typename ElementType> bool ft_set<ElementType>::empty() const`
- `template <typename ElementType> bool ft_set<ElementType>::ensure_capacity(size_t desired_capacity)`
- `template <typename ElementType> bool ft_set<ElementType>::is_thread_safe() const`
- `template <typename ElementType> const ElementType* ft_set<ElementType>::find(const ElementType& value) const`
- `template <typename ElementType> const char* ft_set<ElementType>::get_error_str() const`
- `template <typename ElementType> ft_set<ElementType>::ft_set(ft_set&& other) noexcept : _data(ft_nullptr), _capacity(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ElementType> ft_set<ElementType>::ft_set(size_t initial_capacity) : _data(ft_nullptr), _capacity(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ElementType> ft_set<ElementType>::~ft_set()`
- `template <typename ElementType> int ft_set<ElementType>::enable_thread_safety()`
- `template <typename ElementType> int ft_set<ElementType>::get_error() const`
- `template <typename ElementType> int ft_set<ElementType>::lock(bool *lock_acquired) const`
- `template <typename ElementType> int ft_set<ElementType>::lock_internal(bool *lock_acquired) const`
- `template <typename ElementType> size_t ft_set<ElementType>::find_index(const ElementType& value) const`
- `template <typename ElementType> size_t ft_set<ElementType>::lower_bound(const ElementType& value) const`
- `template <typename ElementType> size_t ft_set<ElementType>::size() const`
- `template <typename ElementType> void ft_set<ElementType>::clear()`
- `template <typename ElementType> void ft_set<ElementType>::disable_thread_safety()`
- `template <typename ElementType> void ft_set<ElementType>::insert(ElementType&& value)`
- `template <typename ElementType> void ft_set<ElementType>::insert(const ElementType& value)`
- `template <typename ElementType> void ft_set<ElementType>::remove(const ElementType& value)`
- `template <typename ElementType> void ft_set<ElementType>::set_error(int error) const`
- `template <typename ElementType> void ft_set<ElementType>::teardown_thread_safety()`
- `template <typename ElementType> void ft_set<ElementType>::unlock(bool lock_acquired) const`
- `template <typename ElementType> void ft_set<ElementType>::unlock_internal(bool lock_acquired) const`
- `void clear();`
- `void disable_thread_safety();`
- `void insert(ElementType&& value);`
- `void insert(const ElementType& value);`
- `void remove(const ElementType& value);`
- `void set_error(int error) const;`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void unlock_internal(bool lock_acquired) const;`

### Template/shared_ptr.hpp

- `ManagedType* get();`
- `bool hasError() const;`
- `bool is_thread_safe() const;`
- `bool unique() const;`
- `const ManagedType* get() const;`
- `const char* get_error_str() const;`
- `const ft_operation_error_stack *operation_error_stack_handle() const noexcept;`
- `ft_operation_error_stack *operation_error_stack_handle() noexcept;`
- `int enable_thread_safety();`
- `int get_error() const;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `int prepare_thread_safety();`
- `int use_count() const;`
- `pt_mutex *mutex_handle() const;`
- `template <typename ManagedType> ManagedType* ft_sharedptr<ManagedType>::get()`
- `template <typename ManagedType> bool ft_sharedptr<ManagedType>::hasError() const`
- `template <typename ManagedType> bool ft_sharedptr<ManagedType>::is_thread_safe() const`
- `template <typename ManagedType> bool ft_sharedptr<ManagedType>::unique() const`
- `template <typename ManagedType> const ManagedType* ft_sharedptr<ManagedType>::get() const`
- `template <typename ManagedType> const char* ft_sharedptr<ManagedType>::get_error_str() const`
- `template <typename ManagedType> const ft_operation_error_stack *ft_sharedptr<ManagedType>::operation_error_stack_handle() const noexcept`
- `template <typename ManagedType> ft_operation_error_stack *ft_sharedptr<ManagedType>::operation_error_stack_handle() noexcept`
- `template <typename ManagedType> ft_sharedptr<ManagedType>::ft_sharedptr() : _managedPointer(ft_nullptr), _referenceCount(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr)`
- `template <typename ManagedType> ft_sharedptr<ManagedType>::ft_sharedptr(const ft_sharedptr<ManagedType>& other) : _managedPointer(ft_nullptr), _referenceCount(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr)`
- `template <typename ManagedType> ft_sharedptr<ManagedType>::ft_sharedptr(ft_sharedptr<ManagedType>&& other) noexcept : _managedPointer(ft_nullptr), _referenceCount(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr)`
- `template <typename ManagedType> ft_sharedptr<ManagedType>::ft_sharedptr(size_t size) : _managedPointer(ft_nullptr), _referenceCount(ft_nullptr), _arraySize(size), _isArrayType(true), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr)`
- `template <typename ManagedType> ft_sharedptr<ManagedType>::~ft_sharedptr()`
- `template <typename ManagedType> int ft_sharedptr<ManagedType>::enable_thread_safety()`
- `template <typename ManagedType> int ft_sharedptr<ManagedType>::get_error() const`
- `template <typename ManagedType> int ft_sharedptr<ManagedType>::lock(bool *lock_acquired) const`
- `template <typename ManagedType> int ft_sharedptr<ManagedType>::lock_internal(bool *lock_acquired) const`
- `template <typename ManagedType> int ft_sharedptr<ManagedType>::prepare_thread_safety()`
- `template <typename ManagedType> int ft_sharedptr<ManagedType>::use_count() const`
- `template <typename ManagedType> pt_mutex *ft_sharedptr<ManagedType>::mutex_handle() const`
- `template <typename ManagedType> void ft_sharedptr<ManagedType>::add(const ManagedType& element)`
- `template <typename ManagedType> void ft_sharedptr<ManagedType>::disable_thread_safety()`
- `template <typename ManagedType> void ft_sharedptr<ManagedType>::record_operation_error(int error_code) const noexcept`
- `template <typename ManagedType> void ft_sharedptr<ManagedType>::release_current_locked()`
- `template <typename ManagedType> void ft_sharedptr<ManagedType>::remove(int index)`
- `template <typename ManagedType> void ft_sharedptr<ManagedType>::reset(ManagedType* pointer, size_t size, bool arrayType)`
- `template <typename ManagedType> void ft_sharedptr<ManagedType>::set_error(int error) const`
- `template <typename ManagedType> void ft_sharedptr<ManagedType>::set_error_internal(int error) const`
- `template <typename ManagedType> void ft_sharedptr<ManagedType>::swap(ft_sharedptr<ManagedType>& other)`
- `template <typename ManagedType> void ft_sharedptr<ManagedType>::teardown_thread_safety()`
- `template <typename ManagedType> void ft_sharedptr<ManagedType>::unlock(bool lock_acquired) const`
- `template <typename ManagedType> void ft_sharedptr<ManagedType>::unlock_internal(bool lock_acquired) const`
- `template <typename Other, typename = std::enable_if_t<std::is_convertible_v<Other*, ManagedType*>>> ft_sharedptr(ft_sharedptr<Other>&& other) noexcept;`
- `template <typename Other> ft_sharedptr(ft_sharedptr<Other>&& other) noexcept requires ft_convertible_to<Other*, ManagedType*>;`
- `void add(const ManagedType& element);`
- `void disable_thread_safety();`
- `void record_operation_error(int error_code) const noexcept;`
- `void release_current_locked();`
- `void remove(int index);`
- `void reset(ManagedType* pointer = ft_nullptr, size_t size = 1, bool arrayType = false);`
- `void set_error(int error) const;`
- `void set_error_internal(int error) const;`
- `void swap(ft_sharedptr<ManagedType>& other);`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void unlock_internal(bool lock_acquired) const;`

### Template/stack.hpp

- `ElementType pop();`
- `ElementType& top();`
- `bool empty() const;`
- `bool is_thread_safe() const;`
- `const ElementType& top() const;`
- `const char *last_operation_error_str() const noexcept;`
- `const char *operation_error_str_at(ft_size_t index) const noexcept;`
- `const ft_operation_error_stack *get_operation_error_stack_for_validation() const noexcept;`
- `ft_operation_error_stack *get_operation_error_stack_for_validation() noexcept;`
- `int enable_thread_safety();`
- `int last_operation_error() const noexcept;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `int operation_error_at(ft_size_t index) const noexcept;`
- `int pop_newest_operation_error() noexcept;`
- `int pop_oldest_operation_error() noexcept;`
- `public: ft_stack();`
- `size_t size() const;`
- `template <typename ElementType> ElementType ft_stack<ElementType>::pop()`
- `template <typename ElementType> ElementType& ft_stack<ElementType>::top()`
- `template <typename ElementType> bool ft_stack<ElementType>::empty() const`
- `template <typename ElementType> bool ft_stack<ElementType>::is_thread_safe() const`
- `template <typename ElementType> const ElementType& ft_stack<ElementType>::top() const`
- `template <typename ElementType> const char *ft_stack<ElementType>::last_operation_error_str() const noexcept`
- `template <typename ElementType> const char *ft_stack<ElementType>::operation_error_str_at(ft_size_t index) const noexcept`
- `template <typename ElementType> const ft_operation_error_stack *ft_stack<ElementType>::get_operation_error_stack_for_validation() const noexcept`
- `template <typename ElementType> ft_operation_error_stack *ft_stack<ElementType>::get_operation_error_stack_for_validation() noexcept`
- `template <typename ElementType> ft_stack<ElementType>::ft_stack() : _top(ft_nullptr), _size(0), _mutex(ft_nullptr), _thread_safe_enabled(false), _operation_errors(`
- `template <typename ElementType> ft_stack<ElementType>::ft_stack(ft_stack&& other) noexcept : _top(ft_nullptr), _size(0), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ElementType> ft_stack<ElementType>::~ft_stack()`
- `template <typename ElementType> int ft_stack<ElementType>::enable_thread_safety()`
- `template <typename ElementType> int ft_stack<ElementType>::last_operation_error() const noexcept`
- `template <typename ElementType> int ft_stack<ElementType>::lock(bool *lock_acquired) const`
- `template <typename ElementType> int ft_stack<ElementType>::lock_internal(bool *lock_acquired) const`
- `template <typename ElementType> int ft_stack<ElementType>::operation_error_at(ft_size_t index) const noexcept`
- `template <typename ElementType> int ft_stack<ElementType>::pop_newest_operation_error() noexcept`
- `template <typename ElementType> int ft_stack<ElementType>::pop_oldest_operation_error() noexcept`
- `template <typename ElementType> size_t ft_stack<ElementType>::size() const`
- `template <typename ElementType> void ft_stack<ElementType>::clear()`
- `template <typename ElementType> void ft_stack<ElementType>::disable_thread_safety()`
- `template <typename ElementType> void ft_stack<ElementType>::pop_operation_errors() noexcept`
- `template <typename ElementType> void ft_stack<ElementType>::push(ElementType&& value)`
- `template <typename ElementType> void ft_stack<ElementType>::push(const ElementType& value)`
- `template <typename ElementType> void ft_stack<ElementType>::record_operation_error(int error_code) const noexcept`
- `template <typename ElementType> void ft_stack<ElementType>::teardown_thread_safety()`
- `template <typename ElementType> void ft_stack<ElementType>::unlock(bool lock_acquired) const`
- `template <typename ElementType> void ft_stack<ElementType>::unlock_internal(bool lock_acquired) const`
- `void clear();`
- `void disable_thread_safety();`
- `void pop_operation_errors() noexcept;`
- `void push(ElementType&& value);`
- `void push(const ElementType& value);`
- `void record_operation_error(int error_code) const noexcept;`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void unlock_internal(bool lock_acquired) const;`

### Template/string_view.hpp

- `bool empty() const;`
- `const CharType* data() const;`
- `const char* get_error_str() const;`
- `ft_string_view substr(size_t position, size_t count = npos) const;`
- `int compare(const ft_string_view& other) const;`
- `int get_error() const;`
- `int lock_self(ft_unique_lock<pt_mutex> &guard) const noexcept;`
- `size_t size() const;`
- `static int lock_pair(const ft_string_view &first, const ft_string_view &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard) noexcept;`
- `static void sleep_backoff() noexcept;`
- `template <typename CharType> bool ft_string_view<CharType>::empty() const`
- `template <typename CharType> const CharType* ft_string_view<CharType>::data() const`
- `template <typename CharType> const char* ft_string_view<CharType>::get_error_str() const`
- `template <typename CharType> const size_t ft_string_view<CharType>::npos = static_cast<size_t>(-1);`
- `template <typename CharType> ft_string_view<CharType> ft_string_view<CharType>::substr(size_t position, size_t count) const`
- `template <typename CharType> ft_string_view<CharType>::ft_string_view() : _data(ft_nullptr), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `template <typename CharType> ft_string_view<CharType>::ft_string_view(const CharType* string) : _data(string), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `template <typename CharType> ft_string_view<CharType>::ft_string_view(const CharType* string, size_t size) : _data(string), _size(size), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `template <typename CharType> ft_string_view<CharType>::ft_string_view(const ft_string_view& other) : _data(ft_nullptr), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `template <typename CharType> ft_string_view<CharType>::~ft_string_view()`
- `template <typename CharType> int ft_string_view<CharType>::compare(const ft_string_view& other) const`
- `template <typename CharType> int ft_string_view<CharType>::get_error() const`
- `template <typename CharType> int ft_string_view<CharType>::lock_pair(const ft_string_view &first, const ft_string_view &second, ft_unique_lock<pt_mutex> &first_guard, ft_unique_lock<pt_mutex> &second_guard) noexcept`
- `template <typename CharType> int ft_string_view<CharType>::lock_self(ft_unique_lock<pt_mutex> &guard) const noexcept`
- `template <typename CharType> size_t ft_string_view<CharType>::size() const`
- `template <typename CharType> void ft_string_view<CharType>::set_error(int error) const`
- `template <typename CharType> void ft_string_view<CharType>::sleep_backoff() noexcept`
- `void set_error(int error) const;`

### Template/thread_pool.hpp

- `bool is_thread_safe() const;`
- `const char* get_error_str() const;`
- `inline bool ft_thread_pool::is_thread_safe() const`
- `inline const char* ft_thread_pool::get_error_str() const`
- `inline int ft_thread_pool::enable_thread_safety()`
- `inline int ft_thread_pool::get_error() const`
- `inline int ft_thread_pool::lock(bool *lock_acquired) const`
- `inline int ft_thread_pool::lock_internal(bool *lock_acquired) const`
- `inline void ft_thread_pool::destroy()`
- `inline void ft_thread_pool::disable_thread_safety()`
- `inline void ft_thread_pool::record_operation_error_unlocked(int error_code) noexcept`
- `inline void ft_thread_pool::set_error(int error) const`
- `inline void ft_thread_pool::teardown_thread_safety()`
- `inline void ft_thread_pool::unlock(bool lock_acquired) const`
- `inline void ft_thread_pool::unlock_internal(bool lock_acquired) const`
- `inline void ft_thread_pool::wait()`
- `inline void ft_thread_pool::worker()`
- `int enable_thread_safety();`
- `int get_error() const;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `public: ft_thread_pool(size_t thread_count = 0, size_t max_tasks = 0);`
- `static void record_operation_error_unlocked(int error_code) noexcept;`
- `template <typename Function> inline void ft_thread_pool::submit(Function &&function)`
- `template <typename Function> inline void ft_thread_pool::submit(Function &&function, const ft_cancellation_token &token)`
- `template <typename Function> void submit(Function &&function);`
- `template <typename Function> void submit(Function &&function, const ft_cancellation_token &token);`
- `void destroy();`
- `void disable_thread_safety();`
- `void set_error(int error) const;`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void unlock_internal(bool lock_acquired) const;`
- `void wait();`
- `void worker();`

### Template/trie.hpp

- `bool is_thread_safe_enabled() const;`
- `const char *get_error_str() const;`
- `const node_value *search(const char *key) const;`
- `int enable_thread_safety();`
- `int get_error() const;`
- `int insert(const char *key, ValueType *value_pointer, int unset_value = 0);`
- `int insert_helper(const char *key, int unset_value, ValueType *value_pointer);`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `public: ft_trie();`
- `static void record_operation_error_unlocked(int error_code) noexcept;`
- `template <typename ValueType> bool ft_trie<ValueType>::is_thread_safe_enabled() const`
- `template <typename ValueType> const char *ft_trie<ValueType>::get_error_str() const`
- `template <typename ValueType> const typename ft_trie<ValueType>::node_value *ft_trie<ValueType>::search(const char *key) const`
- `template <typename ValueType> ft_trie<ValueType>::ft_trie() : _data(ft_nullptr), _children(), _error_code(FT_ERR_SUCCESSS), _last_error(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ValueType> ft_trie<ValueType>::~ft_trie()`
- `template <typename ValueType> int ft_trie<ValueType>::enable_thread_safety()`
- `template <typename ValueType> int ft_trie<ValueType>::get_error() const`
- `template <typename ValueType> int ft_trie<ValueType>::insert(const char *key, ValueType *value_pointer, int unset_value)`
- `template <typename ValueType> int ft_trie<ValueType>::insert_helper(const char *key, int unset_value, ValueType *value_pointer)`
- `template <typename ValueType> int ft_trie<ValueType>::lock(bool *lock_acquired) const`
- `template <typename ValueType> int ft_trie<ValueType>::lock_internal(bool *lock_acquired) const`
- `template <typename ValueType> void ft_trie<ValueType>::disable_thread_safety()`
- `template <typename ValueType> void ft_trie<ValueType>::record_operation_error_unlocked(int error_code) noexcept`
- `template <typename ValueType> void ft_trie<ValueType>::set_error(int error) const`
- `template <typename ValueType> void ft_trie<ValueType>::set_success_preserve_errno() const`
- `template <typename ValueType> void ft_trie<ValueType>::teardown_thread_safety()`
- `template <typename ValueType> void ft_trie<ValueType>::unlock(bool lock_acquired) const`
- `template <typename ValueType> void ft_trie<ValueType>::unlock_internal(bool lock_acquired) const`
- `void disable_thread_safety();`
- `void set_error(int error) const;`
- `void set_success_preserve_errno() const;`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void unlock_internal(bool lock_acquired) const;`

### Template/tuple.hpp

- `bool is_thread_safe() const;`
- `const char* get_error_str() const;`
- `int enable_thread_safety();`
- `int get_error() const;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `int prepare_thread_safety();`
- `public: ft_tuple();`
- `template <std::size_t I> const typename std::tuple_element<I, tuple_t>::type& get() const;`
- `template <std::size_t I> typename std::tuple_element<I, tuple_t>::type& get();`
- `template <typename T> T& get();`
- `template <typename T> const T& get() const;`
- `template <typename... Types> bool ft_tuple<Types...>::is_thread_safe() const`
- `template <typename... Types> const char* ft_tuple<Types...>::get_error_str() const`
- `template <typename... Types> ft_tuple<Types...>::ft_tuple() : _data(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename... Types> ft_tuple<Types...>::ft_tuple(ft_tuple&& other) noexcept : _data(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename... Types> ft_tuple<Types...>::~ft_tuple()`
- `template <typename... Types> int ft_tuple<Types...>::enable_thread_safety()`
- `template <typename... Types> int ft_tuple<Types...>::get_error() const`
- `template <typename... Types> int ft_tuple<Types...>::lock(bool *lock_acquired) const`
- `template <typename... Types> int ft_tuple<Types...>::lock_internal(bool *lock_acquired) const`
- `template <typename... Types> int ft_tuple<Types...>::prepare_thread_safety()`
- `template <typename... Types> template <std::size_t I> const typename std::tuple_element<I, typename ft_tuple<Types...>::tuple_t>::type& ft_tuple<Types...>::get() const`
- `template <typename... Types> template <std::size_t I> typename std::tuple_element<I, typename ft_tuple<Types...>::tuple_t>::type& ft_tuple<Types...>::get()`
- `template <typename... Types> template <typename T> T& ft_tuple<Types...>::get()`
- `template <typename... Types> template <typename T> const T& ft_tuple<Types...>::get() const`
- `template <typename... Types> template <typename... Args> ft_tuple<Types...>::ft_tuple(Args&&... args) : _data(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename... Types> void ft_tuple<Types...>::destroy_locked()`
- `template <typename... Types> void ft_tuple<Types...>::disable_thread_safety()`
- `template <typename... Types> void ft_tuple<Types...>::reset()`
- `template <typename... Types> void ft_tuple<Types...>::set_error(int error) const`
- `template <typename... Types> void ft_tuple<Types...>::set_error_unlocked(int error) const`
- `template <typename... Types> void ft_tuple<Types...>::teardown_thread_safety()`
- `template <typename... Types> void ft_tuple<Types...>::unlock(bool lock_acquired) const`
- `template <typename... Types> void ft_tuple<Types...>::unlock_internal(bool lock_acquired) const`
- `void destroy_locked();`
- `void disable_thread_safety();`
- `void reset();`
- `void set_error(int error) const;`
- `void set_error_unlocked(int error) const;`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void unlock_internal(bool lock_acquired) const;`

### Template/unique_ptr.hpp

- `ManagedType* get();`
- `ManagedType* release();`
- `bool hasError() const;`
- `bool is_thread_safe() const;`
- `const ManagedType* get() const;`
- `const char* get_error_str() const;`
- `int enable_thread_safety();`
- `int get_error() const;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `int prepare_thread_safety();`
- `template <typename ManagedType> ManagedType* ft_uniqueptr<ManagedType>::get()`
- `template <typename ManagedType> ManagedType* ft_uniqueptr<ManagedType>::release()`
- `template <typename ManagedType> bool ft_uniqueptr<ManagedType>::hasError() const`
- `template <typename ManagedType> bool ft_uniqueptr<ManagedType>::is_thread_safe() const`
- `template <typename ManagedType> const ManagedType* ft_uniqueptr<ManagedType>::get() const`
- `template <typename ManagedType> const char* ft_uniqueptr<ManagedType>::get_error_str() const`
- `template <typename ManagedType> ft_uniqueptr<ManagedType>::ft_uniqueptr() : _managedPointer(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ManagedType> ft_uniqueptr<ManagedType>::ft_uniqueptr(ft_uniqueptr&& other) noexcept : _managedPointer(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ManagedType> ft_uniqueptr<ManagedType>::ft_uniqueptr(size_t size) : _managedPointer(new (std::nothrow) ManagedType[size]), _arraySize(size), _isArrayType(true), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename ManagedType> ft_uniqueptr<ManagedType>::~ft_uniqueptr()`
- `template <typename ManagedType> int ft_uniqueptr<ManagedType>::enable_thread_safety()`
- `template <typename ManagedType> int ft_uniqueptr<ManagedType>::get_error() const`
- `template <typename ManagedType> int ft_uniqueptr<ManagedType>::lock(bool *lock_acquired) const`
- `template <typename ManagedType> int ft_uniqueptr<ManagedType>::lock_internal(bool *lock_acquired) const`
- `template <typename ManagedType> int ft_uniqueptr<ManagedType>::prepare_thread_safety()`
- `template <typename ManagedType> void ft_uniqueptr<ManagedType>::destroy_locked()`
- `template <typename ManagedType> void ft_uniqueptr<ManagedType>::disable_thread_safety()`
- `template <typename ManagedType> void ft_uniqueptr<ManagedType>::reset(ManagedType* pointer, size_t size, bool arrayType)`
- `template <typename ManagedType> void ft_uniqueptr<ManagedType>::set_error(int error) const`
- `template <typename ManagedType> void ft_uniqueptr<ManagedType>::set_error_unlocked(int error) const`
- `template <typename ManagedType> void ft_uniqueptr<ManagedType>::swap(ft_uniqueptr& other)`
- `template <typename ManagedType> void ft_uniqueptr<ManagedType>::teardown_thread_safety()`
- `template <typename ManagedType> void ft_uniqueptr<ManagedType>::unlock(bool lock_acquired) const`
- `template <typename ManagedType> void ft_uniqueptr<ManagedType>::unlock_internal(bool lock_acquired) const`
- `void destroy_locked();`
- `void disable_thread_safety();`
- `void reset(ManagedType* pointer = ft_nullptr, size_t size = 1, bool arrayType = false);`
- `void set_error(int error) const;`
- `void set_error_unlocked(int error) const;`
- `void swap(ft_uniqueptr& other);`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`
- `void unlock_internal(bool lock_acquired) const;`

### Template/unordered_map.hpp

- `template <typename Key, typename MappedType> MappedType& ft_unordered_map<Key, MappedType>::at(const Key& key)`
- `template <typename Key, typename MappedType> bool ft_unordered_map<Key, MappedType>::const_iterator::is_thread_safe() const`
- `template <typename Key, typename MappedType> bool ft_unordered_map<Key, MappedType>::empty() const`
- `template <typename Key, typename MappedType> bool ft_unordered_map<Key, MappedType>::has_storage() const`
- `template <typename Key, typename MappedType> bool ft_unordered_map<Key, MappedType>::has_valid_storage() const`
- `template <typename Key, typename MappedType> bool ft_unordered_map<Key, MappedType>::is_thread_safe() const`
- `template <typename Key, typename MappedType> bool ft_unordered_map<Key, MappedType>::iterator::is_thread_safe() const`
- `template <typename Key, typename MappedType> const MappedType& ft_unordered_map<Key, MappedType>::at(const Key& key) const`
- `template <typename Key, typename MappedType> const char* ft_unordered_map<Key, MappedType>::const_iterator::get_error_str() const`
- `template <typename Key, typename MappedType> const char* ft_unordered_map<Key, MappedType>::iterator::get_error_str() const`
- `template <typename Key, typename MappedType> const char* ft_unordered_map<Key, MappedType>::last_operation_error_str() noexcept`
- `template <typename Key, typename MappedType> const char* ft_unordered_map<Key, MappedType>::operation_error_str_at(ft_size_t index) noexcept`
- `template <typename Key, typename MappedType> ft_pair<Key, MappedType>::ft_pair() : first(), second()`
- `template <typename Key, typename MappedType> ft_pair<Key, MappedType>::ft_pair(const Key& k, const MappedType& m) : first(k), second(m)`
- `template <typename Key, typename MappedType> ft_unordered_map<Key, MappedType>::ft_unordered_map(const ft_unordered_map<Key, MappedType>& other) : _data(ft_nullptr), _occupied(ft_nullptr), _capacity(other._capacity), _size(other._size), _error(other._error), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename Key, typename MappedType> ft_unordered_map<Key, MappedType>::ft_unordered_map(ft_unordered_map<Key, MappedType>&& other) noexcept : _data(other._data), _occupied(other._occupied), _capacity(other._capacity), _size(other._size), _error(other._error), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename Key, typename MappedType> ft_unordered_map<Key, MappedType>::ft_unordered_map(size_t initial_capacity) : _data(ft_nullptr), _occupied(ft_nullptr), _capacity(initial_capacity), _size(0), _error(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename Key, typename MappedType> ft_unordered_map<Key, MappedType>::~ft_unordered_map()`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::const_iterator::enable_thread_safety()`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::const_iterator::get_error() const`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::const_iterator::lock(bool *lock_acquired) const`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::const_iterator::lock_internal(bool *lock_acquired) const`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::const_iterator::unlock_internal(bool lock_acquired) const`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::enable_thread_safety()`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::iterator::enable_thread_safety()`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::iterator::get_error() const`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::iterator::lock(bool *lock_acquired) const`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::iterator::lock_internal(bool *lock_acquired) const`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::iterator::unlock_internal(bool lock_acquired) const`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::last_operation_error() noexcept`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::lock(bool *lock_acquired) const`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::lock_internal(bool *lock_acquired) const`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::operation_error_at(ft_size_t index) noexcept`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::pop_newest_operation_error() noexcept`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::pop_oldest_operation_error() noexcept`
- `template <typename Key, typename MappedType> int ft_unordered_map<Key, MappedType>::unlock_internal(bool lock_acquired) const`
- `template <typename Key, typename MappedType> size_t ft_unordered_map<Key, MappedType>::bucket_count() const`
- `template <typename Key, typename MappedType> size_t ft_unordered_map<Key, MappedType>::find_index(const Key& key) const`
- `template <typename Key, typename MappedType> size_t ft_unordered_map<Key, MappedType>::hash_key(const Key& key) const`
- `template <typename Key, typename MappedType> size_t ft_unordered_map<Key, MappedType>::size() const`
- `template <typename Key, typename MappedType> typename ft_unordered_map<Key, MappedType>::const_iterator ft_unordered_map<Key, MappedType>::begin() const`
- `template <typename Key, typename MappedType> typename ft_unordered_map<Key, MappedType>::const_iterator ft_unordered_map<Key, MappedType>::end() const`
- `template <typename Key, typename MappedType> typename ft_unordered_map<Key, MappedType>::const_iterator ft_unordered_map<Key, MappedType>::find(const Key& key) const`
- `template <typename Key, typename MappedType> typename ft_unordered_map<Key, MappedType>::iterator ft_unordered_map<Key, MappedType>::begin()`
- `template <typename Key, typename MappedType> typename ft_unordered_map<Key, MappedType>::iterator ft_unordered_map<Key, MappedType>::end()`
- `template <typename Key, typename MappedType> typename ft_unordered_map<Key, MappedType>::iterator ft_unordered_map<Key, MappedType>::find(const Key& key)`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::clear()`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::const_iterator::advance_to_valid_index_unlocked()`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::const_iterator::disable_thread_safety()`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::const_iterator::push_error(int error) const`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::const_iterator::record_operation_error(int error_code) noexcept`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::const_iterator::teardown_thread_safety()`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::const_iterator::unlock(bool lock_acquired) const`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::disable_thread_safety()`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::erase(const Key& key)`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::flag_storage_error() const`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::insert(const Key& key, const MappedType& value)`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::insert_internal(const Key& key, const MappedType& value)`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::iterator::advance_to_valid_index_unlocked()`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::iterator::disable_thread_safety()`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::iterator::push_error(int error) const`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::iterator::record_operation_error(int error_code) noexcept`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::iterator::teardown_thread_safety()`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::iterator::unlock(bool lock_acquired) const`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::pop_operation_errors() noexcept`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::record_operation_error(int error_code) noexcept`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::resize(size_t new_capacity)`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::teardown_thread_safety()`
- `template <typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::unlock(bool lock_acquired) const`
- `template<typename Key, typename MappedType> void ft_unordered_map<Key, MappedType>::push_error(int error) const`

### Template/variant.hpp

- `template <typename... Types> bool ft_variant<Types...>::is_thread_safe_enabled() const`
- `template <typename... Types> const char* ft_variant<Types...>::get_error_str() const`
- `template <typename... Types> ft_variant<Types...>::ft_variant() : _data(static_cast<storage_t*>(cma_malloc(sizeof(storage_t)))), _index(npos), _error_code(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename... Types> ft_variant<Types...>::ft_variant(ft_variant&& other) noexcept : _data(ft_nullptr), _index(npos), _error_code(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename... Types> ft_variant<Types...>::~ft_variant()`
- `template <typename... Types> int ft_variant<Types...>::enable_thread_safety()`
- `template <typename... Types> int ft_variant<Types...>::get_error() const`
- `template <typename... Types> int ft_variant<Types...>::lock(bool *lock_acquired) const`
- `template <typename... Types> int ft_variant<Types...>::lock_internal(bool *lock_acquired) const`
- `template <typename... Types> template <typename T> T& ft_variant<Types...>::get()`
- `template <typename... Types> template <typename T> bool ft_variant<Types...>::holds_alternative() const`
- `template <typename... Types> template <typename T> const T& ft_variant<Types...>::get() const`
- `template <typename... Types> template <typename T> ft_variant<Types...>::ft_variant(T&& value) : ft_variant()`
- `template <typename... Types> template <typename T> ft_variant<Types...>::ft_variant(const T& value) : ft_variant()`
- `template <typename... Types> template <typename T> void ft_variant<Types...>::emplace(T&& value)`
- `template <typename... Types> template <typename Visitor> void ft_variant<Types...>::visit(Visitor&& vis)`
- `template <typename... Types> void ft_variant<Types...>::destroy_unlocked()`
- `template <typename... Types> void ft_variant<Types...>::disable_thread_safety()`
- `template <typename... Types> void ft_variant<Types...>::reset()`
- `template <typename... Types> void ft_variant<Types...>::set_error(int error) const`
- `template <typename... Types> void ft_variant<Types...>::teardown_thread_safety()`
- `template <typename... Types> void ft_variant<Types...>::unlock(bool lock_acquired) const`
- `template <typename... Types> void ft_variant<Types...>::unlock_internal(bool lock_acquired) const`

### Template/vector.hpp

- `), _mutex(ft_nullptr)`
- `ElementType *small_data();`
- `ElementType release_at(size_t index);`
- `bool empty() const;`
- `bool is_thread_safe() const;`
- `bool using_small_buffer() const;`
- `const ElementType *small_data() const;`
- `const char* get_error_str() const;`
- `const_iterator begin() const;`
- `const_iterator end() const;`
- `int get_error() const;`
- `int lock(bool *lock_acquired) const;`
- `int lock_internal(bool *lock_acquired) const;`
- `int reserve_internal_unlocked(size_t new_capacity);`
- `int unlock_internal(bool lock_acquired) const;`
- `iterator begin();`
- `iterator end();`
- `iterator erase(iterator pos);`
- `iterator insert(iterator pos, const ElementType& value);`
- `protected: void set_error(int error_code) const;`
- `pt_mutex *mutex_handle() const;`
- `size_t capacity() const;`
- `size_t size() const;`
- `template <typename ElementType> ElementType ft_vector<ElementType>::release_at(size_t index)`
- `template <typename ElementType> ElementType* ft_vector<ElementType>::small_data()`
- `template <typename ElementType> bool ft_vector<ElementType>::empty() const`
- `template <typename ElementType> bool ft_vector<ElementType>::is_thread_safe() const`
- `template <typename ElementType> bool ft_vector<ElementType>::using_small_buffer() const`
- `template <typename ElementType> const ElementType* ft_vector<ElementType>::small_data() const`
- `template <typename ElementType> const char* ft_vector<ElementType>::get_error_str() const`
- `template <typename ElementType> ft_vector<ElementType>::ft_vector(ft_vector<ElementType>&& other) noexcept : _data(ft_nullptr), _size(0), _capacity(0), _error_code(FT_ERR_SUCCESSS), _operation_errors(`
- `template <typename ElementType> ft_vector<ElementType>::ft_vector(size_t initial_capacity) : _data(ft_nullptr), _size(0), _capacity(0), _error_code(FT_ERR_SUCCESSS), _operation_errors(`
- `template <typename ElementType> ft_vector<ElementType>::~ft_vector()`
- `template <typename ElementType> int ft_vector<ElementType>::get_error() const`
- `template <typename ElementType> int ft_vector<ElementType>::lock(bool *lock_acquired) const`
- `template <typename ElementType> int ft_vector<ElementType>::lock_internal(bool *lock_acquired) const`
- `template <typename ElementType> int ft_vector<ElementType>::reserve_internal_unlocked(size_t new_capacity)`
- `template <typename ElementType> int ft_vector<ElementType>::unlock_internal(bool lock_acquired) const`
- `template <typename ElementType> pt_mutex *ft_vector<ElementType>::mutex_handle() const`
- `template <typename ElementType> size_t ft_vector<ElementType>::capacity() const`
- `template <typename ElementType> size_t ft_vector<ElementType>::size() const`
- `template <typename ElementType> typename ft_vector<ElementType>::const_iterator ft_vector<ElementType>::begin() const`
- `template <typename ElementType> typename ft_vector<ElementType>::const_iterator ft_vector<ElementType>::end() const`
- `template <typename ElementType> typename ft_vector<ElementType>::iterator ft_vector<ElementType>::begin()`
- `template <typename ElementType> typename ft_vector<ElementType>::iterator ft_vector<ElementType>::end()`
- `template <typename ElementType> typename ft_vector<ElementType>::iterator ft_vector<ElementType>::erase(iterator pos)`
- `template <typename ElementType> typename ft_vector<ElementType>::iterator ft_vector<ElementType>::insert(iterator pos, const ElementType& value)`
- `template <typename ElementType> void ft_vector<ElementType>::clear()`
- `template <typename ElementType> void ft_vector<ElementType>::destroy_elements_unlocked(size_t from, size_t to)`
- `template <typename ElementType> void ft_vector<ElementType>::pop_back()`
- `template <typename ElementType> void ft_vector<ElementType>::push_back(ElementType &&value)`
- `template <typename ElementType> void ft_vector<ElementType>::push_back(const ElementType &value)`
- `template <typename ElementType> void ft_vector<ElementType>::record_operation_error(int error_code) const noexcept`
- `template <typename ElementType> void ft_vector<ElementType>::reserve(size_t new_capacity)`
- `template <typename ElementType> void ft_vector<ElementType>::reset_to_small_buffer()`
- `template <typename ElementType> void ft_vector<ElementType>::resize(size_t new_size, const ElementType& value)`
- `template <typename ElementType> void ft_vector<ElementType>::set_error(int error_code) const`
- `template <typename ElementType> void ft_vector<ElementType>::teardown_thread_safety()`
- `template <typename ElementType> void ft_vector<ElementType>::unlock(bool lock_acquired) const`
- `template <typename Type> struct ft_is_complete<Type, std::void_t<decltype(sizeof(Type))> > : std::true_type`
- `void clear();`
- `void destroy_elements_unlocked(size_t from, size_t to);`
- `void pop_back();`
- `void push_back(ElementType &&value);`
- `void push_back(const ElementType &value);`
- `void record_operation_error(int error_code) const noexcept;`
- `void reserve(size_t new_capacity);`
- `void reset_to_small_buffer();`
- `void resize(size_t new_size, const ElementType& value = ElementType());`
- `void teardown_thread_safety();`
- `void unlock(bool lock_acquired) const;`

### Test/API/test_api_connection_pool.cpp

- `static void api_pool_test_server(api_pool_test_server_context *context)`
- `static void api_pool_test_sleep_small(void)`

### Test/API/test_api_http2_streaming.cpp

- `static bool http2_test_body_callback(const char *chunk_data, size_t chunk_size, bool is_final, void *user_data)`
- `static bool http2_test_drain_client_headers(int socket_fd)`
- `static bool http2_test_read_exact(int socket_fd, char *buffer, size_t length)`
- `static bool http2_test_receive_single_frame(int socket_fd, http2_frame &out_frame)`
- `static bool http2_test_send_all(int socket_fd, const char *buffer, size_t length)`
- `static bool http2_test_server_wait_until_ready(http2_test_server_state *state)`
- `static void http2_test_capture_reset(http2_stream_capture &capture)`
- `static void http2_test_headers_callback(int status_code, const char *headers, void *user_data)`
- `static void http2_test_server(http2_test_server_state *state)`
- `static void http2_test_server_reset_state(http2_test_server_state *state)`
- `static void http2_test_sleep_briefly(void)`

### Test/Compatebility/compatebility_system_test_hooks.hpp

- `void cmp_clear_force_cpu_count_result(void);`
- `void cmp_clear_force_putenv_result(void);`
- `void cmp_clear_force_rng_failures(void);`
- `void cmp_clear_force_unsetenv_result(void);`
- `void cmp_force_rng_close_failure(int error_code);`
- `void cmp_force_rng_read_eof(void);`
- `void cmp_force_rng_read_failure(int error_code);`
- `void cmp_set_force_cpu_count_failure(int errno_value);`
- `void cmp_set_force_cpu_count_success(unsigned int cpu_count);`
- `void cmp_set_force_putenv_result(int result, int errno_value);`
- `void cmp_set_force_putenv_windows_error(int last_error);`
- `void cmp_set_force_total_memory_failure(int errno_value);`
- `void cmp_set_force_total_memory_success(unsigned long long memory_size);`
- `void cmp_set_force_unsetenv_result(int result, int errno_value);`
- `void cmp_set_force_unsetenv_windows_errors(int last_error, int socket_error);`

### Test/Efficiency/efficiency_map.cpp

- `int test_efficiency_map_clear(void)`
- `int test_efficiency_map_copy(void)`
- `int test_efficiency_map_insert_remove(void)`
- `int test_efficiency_map_iterate(void)`
- `int test_efficiency_map_move(void)`
- `int test_efficiency_map_swap(void)`

### Test/Efficiency/efficiency_pair.cpp

- `int test_efficiency_pair_move(void)`
- `int test_efficiency_pair_swap(void)`

### Test/Efficiency/efficiency_queue.cpp

- `int test_efficiency_queue_interleaved(void)`
- `int test_efficiency_queue_move(void)`
- `int test_efficiency_queue_swap(void)`

### Test/Efficiency/efficiency_rwlock.cpp

- `int test_efficiency_rwlock_writer_priority(void)`

### Test/Efficiency/efficiency_shared_ptr.cpp

- `int test_efficiency_shared_ptr_copy(void)`
- `int test_efficiency_shared_ptr_move(void)`
- `int test_efficiency_shared_ptr_reset(void)`
- `int test_efficiency_shared_ptr_swap(void)`
- `int test_efficiency_shared_ptr_use_count(void)`

### Test/Efficiency/efficiency_stack.cpp

- `int test_efficiency_stack_interleaved(void)`
- `int test_efficiency_stack_move(void)`
- `int test_efficiency_stack_swap(void)`

### Test/Efficiency/efficiency_string.cpp

- `int test_efficiency_string_append(void)`
- `int test_efficiency_string_copy(void)`
- `int test_efficiency_string_move(void)`

### Test/Efficiency/efficiency_swap.cpp

- `int test_efficiency_swap_large(void)`

### Test/Efficiency/efficiency_unique_ptr.cpp

- `int test_efficiency_unique_ptr_move(void)`

### Test/Efficiency/efficiency_unordered_map.cpp

- `int test_efficiency_unordered_map_clear(void)`
- `int test_efficiency_unordered_map_copy(void)`
- `int test_efficiency_unordered_map_insert_erase(void)`
- `int test_efficiency_unordered_map_insert_find(void)`
- `int test_efficiency_unordered_map_iterate(void)`
- `int test_efficiency_unordered_map_move(void)`
- `int test_efficiency_unordered_map_swap(void)`
- `static void populate_ft_map(ft_unordered_map<int, int>& map_reference, int count)`

### Test/Efficiency/efficiency_vector.cpp

- `int test_efficiency_vector_clear(void)`
- `int test_efficiency_vector_insert_erase(void)`
- `int test_efficiency_vector_iterate(void)`
- `int test_efficiency_vector_move(void)`
- `int test_efficiency_vector_reserve_resize(void)`
- `int test_efficiency_vector_swap(void)`

### Test/Efficiency/utils.hpp

- `inline long long elapsed_us(clock_type::time_point start, clock_type::time_point end)`
- `inline void prevent_optimization(void* p)`
- `inline void print_comparison(const char *name, long long std_time, long long ft_time)`

### Test/Test/rng_test_utils.hpp

- `[[maybe_unused]] static void ft_rng_test_seed_engine(uint32_t default_seed)`
- `static void ft_rng_test_seed_engine(uint32_t default_seed, const char *context)`

### Test/Test/test_api_request.cpp

- `static bool api_request_stream_body_callback(const char *chunk_data, size_t chunk_size, bool is_final_chunk, void *user_data)`
- `static bool api_request_stream_chunked_server_wait_until_ready(void)`
- `static bool api_request_stream_large_server_wait_until_ready(void)`
- `static bool api_request_success_server_wait_until_ready(void)`
- `static bool api_request_test_stream_http1_hook(const char *ip, uint16_t port, const char *method, const char *path, const api_streaming_handler *streaming_handler, json_group *payload, const char *headers, int timeout, const api_retry_policy *retry_policy, void *user_data)`
- `static bool api_request_test_stream_http2_hook(const char *ip, uint16_t port, const char *method, const char *path, const api_streaming_handler *streaming_handler, json_group *payload, const char *headers, int timeout, bool *used_http2, const api_retry_policy *retry_policy, void *user_data)`
- `static char *api_request_build_large_header(void)`
- `static std::atomic<bool> g_api_async_retry_server_header_complete(false);`
- `static std::atomic<bool> g_api_request_stream_chunked_server_ready(false);`
- `static std::atomic<bool> g_api_request_stream_large_server_ready(false);`
- `static std::atomic<bool> g_api_request_success_server_ready(false);`
- `static std::atomic<int> g_api_async_retry_server_last_errno(0);`
- `static std::atomic<int> g_api_async_retry_server_last_recv_result(0);`
- `static std::atomic<int> g_api_request_stream_chunked_server_start_error(FT_ERR_SUCCESSS);`
- `static std::atomic<int> g_api_request_stream_large_server_start_error(FT_ERR_SUCCESSS);`
- `static std::atomic<int> g_api_request_success_server_start_error(FT_ERR_SUCCESSS);`
- `static std::atomic<size_t> g_api_async_retry_server_bytes_received(0);`
- `static void api_request_async_retry_callback(char *body, int status, void *user_data)`
- `static void api_request_async_retry_server(void)`
- `static void api_request_basic_server(api_request_basic_server_context *context)`
- `static void api_request_bearer_server(api_request_bearer_server_context *context)`
- `static void api_request_circuit_success_server( api_request_circuit_server_context *context)`
- `static void api_request_log_async_transfer_stats(void)`
- `static void api_request_retry_exhaustion_watchdog(std::atomic<bool> *completed, std::atomic<bool> *timed_out)`
- `static void api_request_retry_failure_server(void)`
- `static void api_request_retry_success_server(void)`
- `static void api_request_retry_timeout_server(void)`
- `static void api_request_send_failure_server(void)`
- `static void api_request_small_delay(void)`
- `static void api_request_stream_chunked_response_server(void)`
- `static void api_request_stream_chunked_server_reset_state(void)`
- `static void api_request_stream_chunked_server_signal_ready(int error_code)`
- `static void api_request_stream_headers_callback(int status_code, const char *headers, void *user_data)`
- `static void api_request_stream_large_response_server(void)`
- `static void api_request_stream_large_server_reset_state(void)`
- `static void api_request_stream_large_server_signal_ready(int error_code)`
- `static void api_request_success_server(void)`
- `static void api_request_success_server_reset_state(void)`
- `static void api_request_success_server_signal_ready(int error_code)`

### Test/Test/test_api_tls_diagnostics.cpp

- `static bool tls_compute_expected_fingerprint(ft_string &fingerprint)`
- `static bool tls_get_socket_port(int socket_fd, unsigned short &port_value)`
- `static bool tls_write_temp_file(const char *prefix, const char *contents, ft_string &path)`
- `static void tls_signal_server_stop(tls_test_server_context &context)`
- `static void tls_test_server_run(tls_test_server_context *context)`

### Test/Test/test_cma.cpp

- `int test_cma_checked_free_invalid(void)`
- `int test_cma_checked_free_offset(void)`

### Test/Test/test_cma_alloc.cpp

- `static void release_allocation_range(void **allocation_pointers, ft_size_t start_index, ft_size_t end_index)`

### Test/Test/test_cma_backend.cpp

- `int test_cma_backend_hooks(void)`
- `static ft_size_t test_backend_get_allocation_size(const void *memory_pointer, void *user_data)`
- `static int test_backend_owns_allocation(const void *memory_pointer, void *user_data)`
- `static void *test_backend_allocate(ft_size_t size, void *user_data)`
- `static void *test_backend_reallocate(void *memory_pointer, ft_size_t size, void *user_data)`
- `static void initialize_test_backend_state(test_backend_state *state)`
- `static void test_backend_deallocate(void *memory_pointer, void *user_data)`

### Test/Test/test_compatebility_file_ops.cpp

- `static void remove_directory_if_present(const char *path)`
- `static void write_test_file(const char *path)`

### Test/Test/test_compression_stream.cpp

- `static int compression_stream_buf_error_deflate(z_stream *stream, int flush_mode)`
- `static int compression_stream_buf_error_inflate(z_stream *stream, int flush_mode)`
- `static int compression_stream_capture_flush_deflate(z_stream *stream, int flush_mode)`
- `static int compression_stream_capture_flush_inflate(z_stream *stream, int flush_mode)`
- `static int compression_stream_counting_deflate(z_stream *stream, int flush_mode)`
- `static int compression_stream_fail_deflate(z_stream *stream, int flush_mode)`
- `static int compression_stream_fail_inflate(z_stream *stream, int flush_mode)`
- `static int compression_stream_fail_inflate_init(z_stream *stream)`
- `static int compression_stream_failing_replacement_deflate(z_stream *stream, int flush_mode)`
- `static int compression_stream_stream_error_inflate(z_stream *stream, int flush_mode)`
- `static int compression_stream_trailing_bytes_inflate(z_stream *stream, int flush_mode)`
- `static std::size_t compression_stream_collect_compressed_size(const char *payload, std::size_t payload_size, t_compress_stream_options *options)`

### Test/Test/test_config.cpp

- `static cnfg_config *create_test_config(size_t entry_count)`

### Test/Test/test_config_flag_parser.cpp

- `std::thread parse_worker([&parser, &worker_failed, &first_arguments]()`

### Test/Test/test_container_serialization.cpp

- `static int ft_entry_deserializer(const char *value_string, ft_serialized_entry &entry) noexcept`
- `static int ft_entry_serializer(const ft_serialized_entry &entry, ft_string &output) noexcept`

### Test/Test/test_cpp_class.cpp

- `int test_data_buffer_io(void)`
- `int test_ft_file_write_read(void)`
- `int test_ft_string_append(void)`
- `int test_ft_string_concat(void)`
- `static void ft_file_poll_error(ft_file_thread_context *context)`

### Test/Test/test_cpp_class_file_copy_move.cpp

- `locker_thread = std::thread([&source, &lock_acquired, &release_lock, &lock_result]()`
- `static long measure_read_duration(ft_file &file, char &character)`
- `static void fill_pipe(int write_end, const char *data)`
- `static void wait_until_true(std::atomic<bool> &flag)`

### Test/Test/test_cpp_class_istream_copy_move.cpp

- `protected: std::size_t do_read(char *buffer, std::size_t count)`
- `public: ft_test_timed_istream(char fill_character, bool slow) noexcept : ft_istream() , _fill_character(fill_character) , _slow(slow)`
- `static int create_pipe(int *read_end, int *write_end)`
- `static long measure_read_duration(ft_istream &stream)`
- `static void fill_pipe(int write_end, const char *data)`
- `void set_slow(bool slow) noexcept`
- `worker = std::thread([&slow_stream]()`
- `worker = std::thread([&source_stream]()`

### Test/Test/test_cpp_class_istream_thread_safety.cpp

- `protected: std::size_t do_read(char *buffer, std::size_t count)`
- `public: ft_test_counter_istream(std::size_t total_count, char fill_character) noexcept : ft_istream() , _remaining(total_count) , _fill_character(fill_character)`
- `std::size_t remaining() const noexcept`
- `worker = std::thread([&stream, &start_flag, &mismatch, &total_count, &digit_counts]()`
- `worker = std::thread([&stream, &start_flag, &worker_done, &worker_failure, &total_consumed]()`

### Test/Test/test_cpp_class_ofstream_thread_safety.cpp

- `worker_thread = std::thread([&stream, &start_flag, &worker_done, &worker_failed]()`

### Test/Test/test_cpp_class_stream_mutex.cpp

- `protected: std::size_t do_read(char *buffer, std::size_t count) override`
- `public: ft_test_simple_istream(char fill_character) noexcept : ft_istream() , _fill_character(fill_character)`

### Test/Test/test_cpp_class_string_thread_safety.cpp

- `worker = std::thread([&shared_string, &start_flag, &worker_done]()`

### Test/Test/test_cpp_class_stringbuf_copy_move.cpp

- `locker_thread = std::thread([&original, &lock_acquired, &release_lock, &lock_result]()`
- `locker_thread = std::thread([&source, &lock_acquired, &release_lock, &lock_result]()`
- `static void wait_until_true(std::atomic<bool> &flag)`

### Test/Test/test_cross_process_receive.cpp

- `static int create_shared_memory(const char *name_prefix, const char *payload, size_t payload_length, cross_process_message &message, void *&mapping_ptr, unsigned char *&mapping, size_t &data_offset, size_t &error_offset)`

### Test/Test/test_cross_process_write.cpp

- `static int create_shared_memory(const char *name_prefix, size_t payload_length, cross_process_message &message, void *&mapping_ptr, unsigned char *&mapping, size_t &data_offset, size_t &error_offset)`
- `static size_t cross_process_available_length(uint64_t total_size, size_t offset) noexcept`

### Test/Test/test_encryption_aead.cpp

- `static EVP_PKEY *load_key_from_string(const char *pem_string)`
- `static X509 *load_certificate_from_string(const char *pem_string)`
- `static bool perform_tls_handshake(SSL *client_ssl, SSL *server_ssl)`

### Test/Test/test_encryption_aead_copy_move.cpp

- `locker_thread = std::thread([&source, &lock_acquired, &release_lock, &lock_result]()`
- `static long encrypt_small_message(encryption_aead_context &context, unsigned char *ciphertext, unsigned char *authentication_tag, size_t &output_length)`
- `static void wait_for_lock(std::atomic<bool> &flag)`

### Test/Test/test_encryption_basic.cpp

- `static ssize_t mock_write_failure(int file_descriptor, const void *buffer, size_t count)`

### Test/Test/test_encryption_hardware_acceleration.cpp

- `static void encryption_test_decrypt_hook(uint8_t *block, const uint8_t *key)`
- `static void encryption_test_encrypt_hook(uint8_t *block, const uint8_t *key)`

### Test/Test/test_errno.cpp

- `worker_thread = std::thread( [&thread_errno_value]()`

### Test/Test/test_extra_libft.cpp

- `int test_abs_basic(void)`
- `int test_abs_int_min(void)`
- `int test_abs_llong_min(void)`
- `int test_abs_positive(void)`
- `int test_abs_zero(void)`
- `int test_atol_basic(void)`
- `int test_atol_invalid_input(void)`
- `int test_atol_longmax(void)`
- `int test_atol_longmin(void)`
- `int test_atol_plus_sign(void)`
- `int test_atol_trailing_chars(void)`
- `int test_atol_whitespace(void)`
- `int test_bzero_basic(void)`
- `int test_bzero_zero(void)`
- `int test_fabs_nan(void)`
- `int test_fabs_negative_zero(void)`
- `int test_isalnum_false(void)`
- `int test_isalnum_true(void)`
- `int test_isalpha_false(void)`
- `int test_isalpha_lower_true(void)`
- `int test_isalpha_true(void)`
- `int test_isspace_false(void)`
- `int test_isspace_true(void)`
- `int test_memchr_found(void)`
- `int test_memchr_not_found(void)`
- `int test_memcmp_basic(void)`
- `int test_memcmp_diff(void)`
- `int test_memcpy_basic(void)`
- `int test_memcpy_large(void)`
- `int test_memcpy_null(void)`
- `int test_memcpy_partial(void)`
- `int test_memmove_no_overlap(void)`
- `int test_memmove_overlap(void)`
- `int test_setenv_getenv_basic(void)`
- `int test_setenv_invalid_name(void)`
- `int test_setenv_no_overwrite(void)`
- `int test_setenv_null_name(void)`
- `int test_setenv_overwrite(void)`
- `int test_strchr_basic(void)`
- `int test_strchr_first_occurrence(void)`
- `int test_strchr_not_found(void)`
- `int test_strlcat_basic(void)`
- `int test_strlcat_null_destination(void)`
- `int test_strlcat_null_source(void)`
- `int test_strlcat_truncate(void)`
- `int test_strlcpy_basic(void)`
- `int test_strlcpy_truncate(void)`
- `int test_strlen_size_t_basic(void)`
- `int test_strlen_size_t_empty(void)`
- `int test_strlen_size_t_long(void)`
- `int test_strncmp_basic(void)`
- `int test_strncmp_diff(void)`
- `int test_strncpy_basic(void)`
- `int test_strncpy_padding(void)`
- `int test_strnstr_basic(void)`
- `int test_strnstr_not_found(void)`
- `int test_strrchr_basic(void)`
- `int test_strrchr_not_found(void)`
- `int test_su_get_cpu_count(void)`
- `int test_su_get_home_directory_posix(void)`
- `int test_su_get_home_directory_windows(void)`
- `int test_su_get_total_memory(void)`
- `int test_time_format_iso8601_20210101(void)`
- `int test_time_format_iso8601_epoch(void)`
- `int test_time_monotonic_increases(void)`
- `int test_tolower_basic(void)`
- `int test_tolower_no_change(void)`
- `int test_unsetenv_missing(void)`
- `int test_unsetenv_null_name(void)`

### Test/Test/test_file_directory.cpp

- `thread_one = std::thread([&result_one, directory_one, &thread_one_ready, &start_reads]()`
- `thread_two = std::thread([&result_two, directory_two, &thread_two_ready, &start_reads]()`

### Test/Test/test_file_io.cpp

- `static void force_file_descriptor_failure(FILE *file_handle)`

### Test/Test/test_file_utils.cpp

- `static size_t read_payload(const char *path, unsigned char *buffer, size_t buffer_capacity)`
- `static void build_alternate_separator_path(char *destination, const char *path_template)`
- `static void build_native_path(char *destination, const char *path_template)`
- `static void build_path_from_template(char *destination, const char *path_template, char separator)`
- `static void create_cross_device_test_file(const char *path)`
- `static void write_payload(const char *path, const unsigned char *payload, size_t payload_size)`

### Test/Test/test_full_libft_header.cpp

- `static std::string resolve_existing_path(const std::vector<std::string> &candidates)`
- `static std::vector<std::string> read_includes(const std::string &path, const std::string &prefix)`
- `static std::vector<std::string> read_manifest(const std::string &path)`

### Test/Test/test_game_basics.cpp

- `int test_buff_subtracters(void)`
- `int test_character_add_sub_coins(void)`
- `int test_character_add_sub_valor(void)`
- `int test_character_level(void)`
- `int test_character_serialization_damage(void)`
- `int test_character_valor(void)`
- `int test_debuff_subtracters(void)`
- `int test_event_subtracters(void)`
- `int test_game_save_load(void)`
- `int test_item_basic(void)`
- `int test_item_stack_subtract(void)`
- `int test_quest_progress(void)`
- `int test_restore_individual_armor(void)`
- `int test_upgrade_subtracters(void)`

### Test/Test/test_game_behavior_records.cpp

- `static int assert_profile_values(const ft_behavior_profile &profile, int id, double aggression, double caution, int first_action_id)`

### Test/Test/test_game_data_catalog.cpp

- `static int assert_item_definition_equals(const ft_item_definition &definition, int item_id, int rarity, int max_stack, int width, int height, int weight, int slot_requirement)`
- `static int assert_loadout_entry_values(const ft_loadout_blueprint &loadout, size_t index, int slot, int item_id, int quantity)`
- `static int assert_single_ingredient(const ft_recipe_blueprint &recipe, int item_id, int count, int rarity)`
- `static void populate_loadout_entry(ft_loadout_entry &entry, int slot, int item_id, int quantity)`

### Test/Test/test_game_economy_table.cpp

- `static int assert_vendor_profile_values(const ft_vendor_profile &profile, int vendor_id, double buy_markup, double sell_multiplier, double tax_rate)`

### Test/Test/test_game_event_scheduler_core.cpp

- `int test_event_scheduler_clear_queue(void)`
- `int test_event_scheduler_prioritizes_shorter_events(void)`
- `int test_event_scheduler_rejects_null_schedule(void)`
- `int test_event_scheduler_reschedule_duration(void)`

### Test/Test/test_game_event_scheduler_telemetry.cpp

- `static int game_event_scheduler_capture_sample_state(const ft_game_observability_sample &sample)`
- `static int game_event_scheduler_reset_samples_state(void)`
- `static int game_event_scheduler_strings_equal(const char *left, const char *right)`
- `static void game_event_scheduler_capture_sample(const ft_game_observability_sample &sample)`
- `static void game_event_scheduler_reset_samples(void)`

### Test/Test/test_game_event_scheduler_thread_safety.cpp

- `static void *scheduler_reschedule_task(void *argument)`
- `static void *scheduler_schedule_task(void *argument)`

### Test/Test/test_game_event_thread_safety.cpp

- `static void *game_event_assignment_task(void *argument)`
- `static void *game_event_increment_duration(void *argument)`

### Test/Test/test_game_goal_thread_safety.cpp

- `static void *game_goal_increment_task(void *argument)`
- `static void *game_goal_read_task(void *argument)`

### Test/Test/test_game_inventory_core.cpp

- `int test_inventory_count(void)`
- `int test_inventory_full(void)`

### Test/Test/test_game_map3d_thread_safety.cpp

- `static void *game_map3d_set_task(void *argument)`
- `static void *game_map3d_toggle_task(void *argument)`

### Test/Test/test_game_progress_tracker.cpp

- `static ft_quest make_basic_quest(int quest_id, int phases)`

### Test/Test/test_game_reputation_core.cpp

- `int test_reputation_subtracters(void)`

### Test/Test/test_game_resistance_thread_safety.cpp

- `static void *game_resistance_read_task(void *argument)`
- `static void *game_resistance_update_task(void *argument)`

### Test/Test/test_game_scripting_bridge.cpp

- `static int game_script_adjust_score(ft_game_script_context &context, const ft_vector<ft_string> &arguments) noexcept`

### Test/Test/test_game_scripting_bridge_additional.cpp

- `static int script_set_score(ft_game_script_context &context, const ft_vector<ft_string> &arguments) noexcept`

### Test/Test/test_game_serialization_errors.cpp

- `int deserialize_inventory(ft_inventory &inventory, json_group *group);`
- `json_group *serialize_character(const ft_character &character);`
- `json_group *serialize_equipment(const ft_character &character);`
- `json_group *serialize_quest(const ft_quest &quest);`

### Test/Test/test_game_server_thread_safety.cpp

- `static void *game_server_poll_task(void *argument)`
- `static void game_server_noop_callback(int)`

### Test/Test/test_game_thread_safety.cpp

- `static void run_achievement_assignment_task(ft_achievement *destination, ft_achievement *source, int iterations, int *failure_flag)`
- `static void run_achievement_progress_task(ft_achievement *achievement, int goal_id, int iterations, int increment, int *failure_flag)`
- `static void run_buff_assignment_task(ft_buff *destination, ft_buff *source, int iterations, int *failure_flag)`
- `static void run_debuff_assignment_task(ft_debuff *destination, ft_debuff *source, int iterations, int *failure_flag)`
- `static void run_debuff_increment_task(ft_debuff *debuff, int iterations)`
- `static void run_equipment_assignment_task(ft_equipment *destination, ft_equipment *source, int iterations, int *failure_flag)`
- `static void run_equipment_equip_task(ft_equipment *equipment, int slot, ft_sharedptr<ft_item> item, int iterations, int *failure_flag)`
- `static void run_experience_assignment_task(ft_experience_table *destination, ft_experience_table *source, int iterations, int *failure_flag)`
- `static void run_experience_set_levels_task(ft_experience_table *table, const int *levels, int count, int iterations, int *failure_flag)`
- `static void run_quest_copy_task(ft_quest *source, ft_quest *destination, int iterations, int *failure_flag)`
- `static void run_quest_phase_task(ft_quest *quest, int iterations, int phase_limit, int *failure_flag)`
- `static void run_quest_reward_task(ft_quest *quest, ft_sharedptr<ft_item> reward_one, ft_sharedptr<ft_item> reward_two, int iterations, int *failure_flag)`
- `static void run_quest_text_task(ft_quest *quest, int iterations, int *failure_flag)`
- `static void run_reputation_add_current_task(ft_reputation *reputation, int iterations, int *failure_flag)`
- `static void run_reputation_add_total_task(ft_reputation *reputation, int iterations, int *failure_flag)`
- `static void run_reputation_assignment_task(ft_reputation *destination, ft_reputation *source, int iterations, int *failure_flag)`
- `static void run_reputation_set_milestones_task(ft_reputation *reputation, int id_base, int iterations, int *failure_flag)`
- `static void run_skill_add_cooldown_task(ft_skill *skill, int iterations)`
- `static void run_skill_assignment_task(ft_skill *destination, ft_skill *source, int iterations, int *failure_flag)`
- `static void run_upgrade_assignment_task(ft_upgrade *destination, ft_upgrade *source, int iterations, int *failure_flag)`
- `static void run_upgrade_increment_task(ft_upgrade *upgrade, int iterations)`

### Test/Test/test_geometry_aabb.cpp

- `worker_thread = std::thread([&first, &second, &worker_ready, &worker_failed, &worker_completed]()`

### Test/Test/test_geometry_circle.cpp

- `worker_thread = std::thread([&first, &second, &worker_ready, &worker_failed, &worker_completed]()`

### Test/Test/test_geometry_sphere.cpp

- `worker_thread = std::thread([&first, &second, &worker_ready, &worker_failed, &worker_completed]()`

### Test/Test/test_get_next_line.cpp

- `int test_get_next_line_basic(void)`
- `int test_get_next_line_custom_buffer(void)`
- `int test_get_next_line_empty(void)`
- `static void *failing_leftover_allocator(ft_size_t size)`
- `static void *leftover_allocator_that_limits_map(ft_size_t size)`
- `static void close_temp_fd(int file_descriptor)`

### Test/Test/test_html.cpp

- `int test_html_find_by_attr(void)`
- `int test_html_find_by_selector(void)`
- `int test_html_find_by_tag(void)`
- `int test_html_query_selector(void)`
- `int test_html_write_to_string(void)`

### Test/Test/test_html_attr_thread_safety.cpp

- `static void release_html_attribute(html_attr *attribute)`

### Test/Test/test_http_client.cpp

- `static void http_client_server_run_once(http_client_server_context *context)`

### Test/Test/test_http_server.cpp

- `static int collect_response(int socket_fd, ft_string &response)`
- `static void http_server_read_error(http_server_error_context *context)`
- `static void http_server_run_once(http_server_context *context)`

### Test/Test/test_is_constant_evaluated.cpp

- `static size_t build_word_from_bytes(const unsigned char *bytes)`

### Test/Test/test_json_stream_reader.cpp

- `static size_t test_chunk_callback(void *user_data, char *buffer, size_t max_size)`

### Test/Test/test_json_streaming.cpp

- `static int capture_event(void *user_data, const json_stream_event *event)`
- `static int gather_events(const char *json_text, ft_vector<captured_event> &events)`
- `static size_t memory_stream_reader(void *user_data, char *buffer, size_t max_size)`
- `static size_t string_sink_write(void *user_data, const char *buffer, size_t size)`

### Test/Test/test_libft_utf8.cpp

- `static uint32_t ft_utf8_test_invalid_hook(uint32_t code_point)`

### Test/Test/test_logger_async_logging.cpp

- `static void logger_async_sink(const char *message, void *user_data)`

### Test/Test/test_logger_control.cpp

- `worker = std::thread([&field, &ready, &worker_failed, &wait_duration_ms]()`
- `worker = std::thread([&metrics, &ready, &worker_result, &wait_duration_ms]()`
- `worker = std::thread([&sink, &ready, &worker_failed, &wait_duration_ms]()`

### Test/Test/test_logger_file.cpp

- `static ssize_t logger_partial_write_hook(int file_descriptor, const void *buffer, size_t count)`
- `worker = std::thread([&sink, &ready, &worker_failed, &wait_duration_ms]()`

### Test/Test/test_logger_network.cpp

- `static ssize_t mock_partial_send(int socket_fd, const void *buffer, size_t length, int flags)`
- `static ssize_t mock_send_remove_sink(int socket_fd, const void *buffer, size_t length, int flags)`
- `static ssize_t mock_successful_send(int socket_fd, const void *buffer, size_t length, int flags)`
- `static void reset_mock_network_send_state(void)`
- `worker = std::thread([&sink, &ready, &worker_failed, &wait_duration_ms]()`

### Test/Test/test_math_eval.cpp

- `int test_math_eval_dice_rejected(void)`
- `int test_math_eval_parentheses(void)`

### Test/Test/test_math_isnan.cpp

- `int test_math_isnan_numbers(void)`

### Test/Test/test_math_polynomial.cpp

- `static double test_math_polynomial_square(double value, void *user_data)`

### Test/Test/test_networking.cpp

- `static bool get_socket_port_string(ft_socket &socket, ft_string &port_string)`
- `static int socket_creation_failure_hook(int domain, int type, int protocol)`
- `static void http_stream_test_server(http_stream_test_server_context *context)`
- `static void test_http_streaming_handler(int status_code, const ft_string &headers, const char *body_chunk, size_t chunk_size, bool finished)`

### Test/Test/test_networking_quic.cpp

- `static EVP_PKEY *quic_test_load_key(const char *pem_data)`
- `static X509 *quic_test_load_certificate(const char *pem_data)`
- `static bool quic_test_perform_handshake(SSL *client_ssl, SSL *server_ssl)`
- `static bool quic_test_setup_tls_pair(quic_test_tls_pair &pair)`
- `static void quic_test_teardown_tls_pair(quic_test_tls_pair &pair)`

### Test/Test/test_networking_socket_thread_safety.cpp

- `accept_thread = std::thread([server_fd, &accepted_fd]()`
- `closer_thread = std::thread([&client_socket, &received_once, &close_requested]()`
- `inspector_thread = std::thread([&client_socket, &inspector_running, &thread_failed]()`
- `reader_thread = std::thread([accepted_fd, message_length, send_iterations, &received_total]()`
- `receiver_thread = std::thread([&client_socket, &received_once]()`
- `send_thread = std::thread([&client_socket, message, message_length, send_iterations, &thread_failed]()`
- `sender_thread = std::thread([accepted_fd, &close_requested]()`
- `static void networking_socket_configure_client(SocketConfig &config, uint16_t port)`

### Test/Test/test_networking_websocket_client_thread_safety.cpp

- `static void websocket_client_inspector(websocket_client_inspector_context *context)`
- `static void websocket_client_server_run(websocket_client_server_context *context)`

### Test/Test/test_networking_websocket_server_thread_safety.cpp

- `static void websocket_server_inspector(websocket_server_inspector_context *context)`
- `static void websocket_server_run_once(websocket_server_thread_context *context)`

### Test/Test/test_observability_game_metrics.cpp

- `static bool observability_game_strings_equal(const char *left, const char *right)`
- `static void observability_game_reset_last_sample(void)`
- `static void observability_game_test_exporter(const ft_game_observability_sample &sample)`

### Test/Test/test_observability_networking_metrics.cpp

- `static bool observability_strings_equal(const char *left, const char *right)`
- `static void observability_reset_last_sample(void)`
- `static void observability_test_exporter(const ft_networking_observability_sample &sample)`

### Test/Test/test_observability_task_scheduler_bridge.cpp

- `static std::vector<ft_otel_span_metrics> observability_test_snapshot(void)`
- `static void observability_test_clear_spans(void)`
- `static void observability_test_exporter(const ft_otel_span_metrics &span)`
- `static void observability_test_wait_for_count(size_t expected_count)`

### Test/Test/test_parser_dom.cpp

- `static void initialize_simple_dom_document(ft_dom_document &document)`

### Test/Test/test_pathfinding_thread_safety.cpp

- `static void *path_step_read_task(void *argument)`
- `static void *path_step_update_task(void *argument)`
- `static void *pathfinding_read_task(void *argument)`
- `static void *pathfinding_recalc_task(void *argument)`

### Test/Test/test_printf.cpp

- `int test_pf_printf_bool(void)`
- `int test_pf_printf_float_negative(void)`
- `int test_pf_printf_float_positive(void)`
- `int test_pf_printf_float_zero(void)`
- `int test_pf_printf_misc(void)`
- `int test_pf_printf_modifiers(void)`
- `int test_pf_printf_nullptr(void)`
- `int test_pf_snprintf_basic(void)`

### Test/Test/test_printf_fprintf.cpp

- `static int call_ft_vfprintf(FILE *stream, const char *format, ...)`
- `static int close_pipe_end(int file_descriptor)`
- `static int create_pipe(int pipe_fds[2])`
- `static int pf_test_custom_handler(va_list *args, ft_string &output, void *context)`
- `static int pf_test_custom_handler_failure(va_list *args, ft_string &output, void *context)`
- `static int read_pipe_into_buffer(int read_fd, char *buffer, size_t buffer_size, ssize_t *bytes_read)`

### Test/Test/test_printf_print_args.cpp

- `static int close_pipe_end(int file_descriptor)`
- `static int read_pipe_into_buffer(int read_fd, char *buffer, size_t buffer_size, ssize_t *bytes_read)`

### Test/Test/test_printf_snprintf.cpp

- `extern void pf_reset_fflush_function(void);`
- `extern void pf_reset_ftell_function(void);`
- `extern void pf_reset_tmpfile_function(void);`
- `extern void pf_set_fflush_function(int (*function)(FILE *));`
- `extern void pf_set_ftell_function(long (*function)(FILE *));`
- `static FILE *pf_tmpfile_failure(void)`
- `static int pf_fflush_failure(FILE *stream)`
- `static int pf_vsnprintf_wrapper(char *string, size_t size, const char *format, ...)`
- `static int std_vsnprintf_wrapper(char *string, size_t size, const char *format, ...)`
- `static long pf_ftell_failure(FILE *stream)`
- `static void build_repeated_string(char *buffer, size_t length, char character)`

### Test/Test/test_pthread_condition.cpp

- `static void *pt_condition_signal_thread(void *argument)`

### Test/Test/test_pthread_condition_variable_thread_safety.cpp

- `worker_thread = std::thread([&condition, &mutex_object, &worker_ready, &wait_result]()`
- `worker_thread = std::thread([&condition, &worker_started, &worker_locked, &worker_finished]()`

### Test/Test/test_pthread_lock_tracking.cpp

- `cleanup: if (first_mutex_locked == 1)`
- `cleanup: if (thread_created == 1)`
- `static bool vector_contains_mutex(const pt_mutex_vector &owned_mutexes, pthread_mutex_t *mutex_pointer)`
- `static bool wait_for_stage(std::atomic<int> *stage, int expected_stage)`
- `static bool wait_for_thread_state(pt_thread_id_type thread_identifier, pthread_mutex_t *owned_mutex_pointer, pthread_mutex_t *waiting_mutex_pointer, ft_size_t expected_owned_count, long timeout_ms)`
- `static void *deadlock_worker(void *argument)`
- `static void *foreign_owned_mutex_worker(void *argument)`
- `static void *try_lock_worker(void *argument)`
- `static void *unlock_worker(void *argument)`
- `static void handle_sigabrt(int signal_number)`
- `static void initialize_foreign_owned_shared_state(s_foreign_owned_shared_state *shared_state, pt_mutex *mutex_pointer)`
- `static void initialize_shared_state(s_lock_cycle_shared *shared, pt_mutex *first_mutex, pt_mutex *second_mutex)`
- `static void initialize_try_lock_shared_state(s_try_lock_shared_state *shared_state, pt_mutex *mutex_pointer)`
- `static void initialize_unlock_shared_state(s_unlock_shared_state *shared_state, pt_mutex *mutex_pointer)`

### Test/Test/test_pthread_rwlock.cpp

- `int test_pt_rwlock_readers_writers(void)`
- `static void *reader_routine(void *arg)`
- `static void *writer_routine(void *arg)`

### Test/Test/test_pthread_task_scheduler_tracing.cpp

- `static std::vector<ft_task_trace_event> task_scheduler_trace_snapshot(void)`
- `static void task_scheduler_trace_clear_events(void)`
- `static void task_scheduler_trace_test_sink(const ft_task_trace_event &event)`

### Test/Test/test_pthread_thread_thread_safety.cpp

- `ft_thread worker([]()`

### Test/Test/test_pthread_timed.cpp

- `static void *pt_mutex_try_lock_for_thread(void *argument)`

### Test/Test/test_readline.cpp

- `static int test_readline_completion_callback(const char *buffer, int cursor_position, const char *prefix, void *user_data)`
- `static int test_readline_custom_key_callback(readline_state_t *state, const char *prompt, void *user_data)`
- `static void test_readline_restore_stderr(int backup_descriptor)`
- `static void test_readline_suppress_stderr(int *backup_descriptor)`
- `worker = std::thread([&dimensions, &worker_ready, &worker_has_lock, &worker_result]()`
- `worker = std::thread([&state, &worker_ready, &worker_has_lock, &worker_result]()`

### Test/Test/test_scma_shared.hpp

- `static inline int scma_test_initialize(ft_size_t capacity)`
- `static inline void scma_test_reset(void)`

### Test/Test/test_storage_kv_store.cpp

- `static std::string read_file_contents(const char *file_path)`
- `static void cleanup_paths(const char *directory_path, const char *file_path)`
- `static void create_kv_store_file(const char *file_path)`

### Test/Test/test_string_view.cpp

- `static void *string_view_assignment_worker(void *argument)`
- `static void *string_view_comparison_worker(void *argument)`

### Test/Test/test_stringbuf.cpp

- `worker_thread = std::thread([&buffer, &start_flag, &worker_done, &worker_output]()`

### Test/Test/test_striteri.cpp

- `static void record_index_iter(unsigned int index, char *character)`

### Test/Test/test_strlen.cpp

- `static int ft_assert_single_stack_error(int expected_error)`

### Test/Test/test_strmapi.cpp

- `static char index_to_digit_map(unsigned int index, char character)`

### Test/Test/test_strtok.cpp

- `std::thread first_thread([ &first_thread_buffer, &first_thread_token_one, &first_thread_token_two ]()`
- `std::thread second_thread([ &second_thread_buffer, &second_thread_token_one, &second_thread_token_two ]()`

### Test/Test/test_system_utils_file_io.cpp

- `static ssize_t su_write_zero_progress_hook(int file_descriptor, const void *buffer, size_t count)`

### Test/Test/test_system_utils_file_stream.cpp

- `static void create_test_file_stream_file(void)`

### Test/Test/test_system_utils_file_utils.cpp

- `static ft_string su_read_text_file(const char *path)`
- `static int su_write_text_file(const char *path, const char *contents)`
- `static void su_cleanup_directory_fixture(void)`
- `static void su_prepare_directory_fixture(void)`
- `static void su_remove_directory(const char *path)`

### Test/Test/test_system_utils_health.cpp

- `static int su_test_health_failure(void *context, ft_string &detail)`

### Test/Test/test_system_utils_home.cpp

- `static void restore_environment_value(const char *name, const std::string &storage, int was_present)`

### Test/Test/test_system_utils_resource_tracer.cpp

- `static void su_test_tracer(const char *reason)`

### Test/Test/test_system_utils_service.cpp

- `static void test_su_service_signal_handler(int signal_number, void *context)`

### Test/Test/test_template.cpp

- `const char *get_error_str() const;`
- `const char *vector_destructor_tracker::get_error_str() const`
- `explicit vector_destructor_tracker(int value);`
- `int get_error() const;`
- `int test_ft_map_at(void)`
- `int test_ft_map_at_missing(void)`
- `int test_ft_map_clear_empty(void)`
- `int test_ft_map_insert_find(void)`
- `int test_ft_map_remove(void)`
- `int test_ft_shared_ptr_add_remove(void)`
- `int test_ft_shared_ptr_array(void)`
- `int test_ft_shared_ptr_basic(void)`
- `int test_ft_shared_ptr_reset(void)`
- `int test_ft_unique_ptr_array(void)`
- `int test_ft_unique_ptr_basic(void)`
- `int test_ft_unique_ptr_release(void)`
- `int test_ft_unique_ptr_swap(void)`
- `int test_ft_vector_clear(void)`
- `int test_ft_vector_insert_erase(void)`
- `int test_ft_vector_push_back(void)`
- `int test_ft_vector_reserve_resize(void)`
- `int test_ft_vector_vs_std_insert_erase(void)`
- `int test_ft_vector_vs_std_push_back(void)`
- `int test_ft_vector_vs_std_reserve_resize(void)`
- `int test_json_roundtrip_file(void)`
- `int test_json_roundtrip_string(void)`
- `int vector_destructor_tracker::get_error() const`
- `int vector_destructor_tracker::live_count()`
- `public: vector_destructor_tracker();`
- `static int live_count();`
- `static void reset();`
- `void set_error(int error_code) const;`
- `void vector_destructor_tracker::reset()`
- `void vector_destructor_tracker::set_error(int error_code) const`

### Test/Test/test_template_circular_buffer_thread_safety.cpp

- `worker = std::thread([&buffer_instance, &ready, &worker_succeeded, &wait_duration_ms]()`

### Test/Test/test_template_concepts.cpp

- `const char *get_error_str() const;`
- `const char *shared_ptr_base_type::get_error_str() const`
- `const char *shared_ptr_derived_type::get_error_str() const`
- `const char *variadic_constructible::get_error_str() const`
- `double second() const;`
- `double variadic_constructible::second() const`
- `int first() const;`
- `int get_error() const;`
- `int shared_ptr_base_type::get_error() const`
- `int shared_ptr_base_type::get_marker() const`
- `int shared_ptr_derived_type::get_error() const`
- `int variadic_constructible::first() const`
- `int variadic_constructible::get_error() const`
- `public: variadic_constructible();`
- `void set_error(int error) const;`
- `void shared_ptr_base_type::set_error(int error) const`
- `void shared_ptr_derived_type::set_error(int error) const`
- `void variadic_constructible::set_error(int error) const`

### Test/Test/test_template_deque_thread_safety.cpp

- `worker = std::thread([&deque_instance, &ready, &worker_succeeded, &wait_duration_ms]()`

### Test/Test/test_template_event_emitter.cpp

- `static std::atomic<int> g_concurrent_listener_total(0);`
- `static void emit_in_thread(ft_event_emitter<int, int>* emitter_instance, int event_identifier, int emit_count, int emit_value)`
- `static void event_listener_add_to_atomic(int value)`
- `static void event_listener_add_to_first(int value)`
- `static void event_listener_add_to_second(int value)`

### Test/Test/test_template_graph_thread_safety.cpp

- `worker_thread = std::thread([&graph_instance, &ready, &worker_succeeded, &wait_duration_ms]()`

### Test/Test/test_template_math.cpp

- `static bool compare_absolute_value(int left, int right)`

### Test/Test/test_template_matrix_thread_safety.cpp

- `worker = std::thread([&matrix_instance, &ready, &worker_succeeded, &wait_duration_ms]()`

### Test/Test/test_template_optional.cpp

- `const char *get_error_str() const;`
- `const char *no_default_optional_value::get_error_str() const`
- `int get_error() const;`
- `int get_value() const;`
- `int no_default_optional_value::get_error() const`
- `int no_default_optional_value::get_value() const`
- `public: no_default_optional_value(int value);`
- `void no_default_optional_value::set_error(int error) const`
- `void set_error(int error) const;`

### Test/Test/test_template_priority_queue_thread_safety.cpp

- `worker = std::thread([&queue_instance, &ready, &worker_succeeded, &wait_duration_ms]()`

### Test/Test/test_template_queue_thread_safety.cpp

- `worker = std::thread([&queue_instance, &ready, &worker_succeeded, &wait_duration_ms]()`

### Test/Test/test_template_set_thread_safety.cpp

- `worker = std::thread([&set_instance, &ready, &worker_succeeded, &wait_duration_ms]()`

### Test/Test/test_template_stack_thread_safety.cpp

- `worker = std::thread([&stack_instance, &ready, &worker_succeeded, &wait_duration_ms]()`

### Test/Test/test_template_thread_pool_thread_safety.cpp

- `worker_thread = std::thread([&pool_instance, &ready, &worker_succeeded, &wait_duration_ms]()`

### Test/Test/test_template_tuple_thread_safety.cpp

- `worker = std::thread([&tuple_instance, &ready, &worker_succeeded, &wait_duration_ms]()`

### Test/Test/test_template_unique_ptr_thread_safety.cpp

- `worker = std::thread([&unique_pointer, &ready, &worker_succeeded, &wait_duration_ms]()`

### Test/Test/test_template_unordered_map_iterator_thread_safety.cpp

- `worker = std::thread([&iterator_instance, &ready, &worker_succeeded, &wait_duration_ms]()`

### Test/Test/test_template_vector_thread_safety.cpp

- `worker = std::thread([&vector_instance, &ready, &worker_succeeded, &wait_duration_ms]()`

### Test/Test/test_time.cpp

- `static std::chrono::system_clock::time_point test_time_now_hook(void)`

### Test/Test/test_websocket_handshake.cpp

- `static void websocket_invalid_handshake_server(websocket_invalid_handshake_context *context)`

### Test/Test/test_xml.cpp

- `int test_xml_propagates_child_allocation_failure(void)`

### Test/Test/websocket_compression_test_utils.hpp

- `static bool websocket_permessage_deflate_decompress(const unsigned char *payload, std::size_t payload_length, ft_string &message)`

### Test/Test/websocket_test_utils.hpp

- `static void websocket_server_worker(websocket_server_context *context)`

### Time/fps.hpp

- `const char *get_error_str() const;`
- `int get_error() const;`
- `int set_frames_per_second(long frames_per_second);`
- `long get_frames_per_second();`
- `public: time_fps(long frames_per_second);`
- `void set_error(int error_code);`
- `void sleep_to_next_frame();`

### Time/time.hpp

- `bool time_async_sleep_is_complete(const t_time_async_sleep *sleep_state);`
- `bool time_benchmark_snapshot(const t_time_benchmark *benchmark, t_time_benchmark_snapshot *out_snapshot);`
- `bool time_convert_timezone(t_time time_value, int source_offset_minutes, int target_offset_minutes, t_time *converted_time);`
- `bool time_duration_ms_is_thread_safe_enabled(const t_duration_milliseconds *duration);`
- `bool time_get_local_offset(t_time time_value, int *offset_minutes, bool *is_daylight_saving);`
- `bool time_get_monotonic_wall_anchor(t_monotonic_time_point &anchor_monotonic, long long &anchor_wall_ms);`
- `bool time_high_resolution_now(t_high_resolution_time_point *time_point);`
- `bool time_info_is_thread_safe_enabled(const t_time_info *time_info);`
- `bool time_monotonic_point_is_thread_safe_enabled(const t_monotonic_time_point *time_point);`
- `bool time_monotonic_to_wall_ms(t_monotonic_time_point monotonic_point, t_monotonic_time_point anchor_monotonic, long long anchor_wall_ms, long long &out_wall_ms);`
- `bool time_parse_custom(const char *string_input, const char *format, std::tm *time_output, t_time *timestamp_output);`
- `bool time_parse_custom(const char *string_input, const char *format, std::tm *time_output, t_time *timestamp_output, bool interpret_as_utc);`
- `bool time_parse_iso8601(const char *string_input, std::tm *time_output, t_time *timestamp_output);`
- `bool time_trace_begin_event(const char *name, const char *category);`
- `bool time_trace_begin_session(const char *file_path);`
- `bool time_trace_end_event(void);`
- `bool time_trace_end_session(void);`
- `bool time_trace_instant_event(const char *name, const char *category);`
- `bool time_wall_ms_to_monotonic(long long wall_time_ms, t_monotonic_time_point anchor_monotonic, long long anchor_wall_ms, t_monotonic_time_point &out_monotonic);`
- `const char *time_benchmark_get_error_str(const t_time_benchmark *benchmark);`
- `double time_benchmark_get_average_ms(const t_time_benchmark *benchmark);`
- `double time_benchmark_get_jitter_ms(const t_time_benchmark *benchmark);`
- `double time_benchmark_get_maximum_ms(const t_time_benchmark *benchmark);`
- `double time_benchmark_get_minimum_ms(const t_time_benchmark *benchmark);`
- `double time_high_resolution_diff_seconds(t_high_resolution_time_point start_point, t_high_resolution_time_point end_point);`
- `ft_string time_format_iso8601(t_time time_value);`
- `ft_string time_format_iso8601_with_offset(t_time time_value, int offset_minutes);`
- `int time_async_sleep_poll(event_loop *loop, t_time_async_sleep *sleep_state);`
- `int time_benchmark_add_duration(t_time_benchmark *benchmark, t_duration_milliseconds duration);`
- `int time_benchmark_add_sample(t_time_benchmark *benchmark, double duration_ms);`
- `int time_benchmark_get_error(const t_time_benchmark *benchmark);`
- `int time_duration_ms_lock(const t_duration_milliseconds *duration, bool *lock_acquired);`
- `int time_duration_ms_prepare_thread_safety(t_duration_milliseconds *duration);`
- `int time_info_lock(const t_time_info *time_info, bool *lock_acquired);`
- `int time_info_prepare_thread_safety(t_time_info *time_info);`
- `int time_monotonic_point_compare(t_monotonic_time_point first_point, t_monotonic_time_point second_point);`
- `int time_monotonic_point_lock(const t_monotonic_time_point *time_point, bool *lock_acquired);`
- `int time_monotonic_point_prepare_thread_safety(t_monotonic_time_point *time_point);`
- `long long time_async_sleep_remaining_ms(t_time_async_sleep *sleep_state);`
- `long long time_high_resolution_diff_ns(t_high_resolution_time_point start_point, t_high_resolution_time_point end_point);`
- `long long time_monotonic(void);`
- `long long time_monotonic_point_diff_ms(t_monotonic_time_point start_point, t_monotonic_time_point end_point);`
- `long time_now_ms(void);`
- `size_t time_benchmark_get_sample_count(const t_time_benchmark *benchmark);`
- `size_t time_strftime(char *buffer, size_t size, const char *format, const t_time_info *time_info);`
- `t_duration_milliseconds time_duration_ms_create(long long milliseconds);`
- `t_monotonic_time_point time_monotonic_point_add_ms(t_monotonic_time_point time_point, long long milliseconds);`
- `t_monotonic_time_point time_monotonic_point_create(long long milliseconds);`
- `t_monotonic_time_point time_monotonic_point_now(void);`
- `t_time time_now(void);`
- `void time_async_sleep_init(t_time_async_sleep *sleep_state, long long delay_milliseconds);`
- `void time_benchmark_init(t_time_benchmark *benchmark);`
- `void time_benchmark_reset(t_time_benchmark *benchmark);`
- `void time_duration_ms_teardown_thread_safety(t_duration_milliseconds *duration);`
- `void time_duration_ms_unlock(const t_duration_milliseconds *duration, bool lock_acquired);`
- `void time_info_teardown_thread_safety(t_time_info *time_info);`
- `void time_info_unlock(const t_time_info *time_info, bool lock_acquired);`
- `void time_local(t_time time_value, t_time_info *out);`
- `void time_monotonic_point_teardown_thread_safety(t_monotonic_time_point *time_point);`
- `void time_monotonic_point_unlock(const t_monotonic_time_point *time_point, bool lock_acquired);`
- `void time_reset_clock_now_hook(void);`
- `void time_set_clock_now_hook(t_time_clock_now_hook hook);`
- `void time_sleep(unsigned int seconds);`
- `void time_sleep_ms(unsigned int milliseconds);`

### Time/time_benchmark.cpp

- `bool time_benchmark_snapshot(const t_time_benchmark *benchmark, t_time_benchmark_snapshot *out_snapshot)`
- `const char *time_benchmark_get_error_str(const t_time_benchmark *benchmark)`
- `double time_benchmark_get_average_ms(const t_time_benchmark *benchmark)`
- `double time_benchmark_get_jitter_ms(const t_time_benchmark *benchmark)`
- `double time_benchmark_get_maximum_ms(const t_time_benchmark *benchmark)`
- `double time_benchmark_get_minimum_ms(const t_time_benchmark *benchmark)`
- `int time_benchmark_add_duration(t_time_benchmark *benchmark, t_duration_milliseconds duration)`
- `int time_benchmark_add_sample(t_time_benchmark *benchmark, double duration_ms)`
- `int time_benchmark_get_error(const t_time_benchmark *benchmark)`
- `size_t time_benchmark_get_sample_count(const t_time_benchmark *benchmark)`
- `static double time_benchmark_calculate_jitter(const t_time_benchmark *benchmark)`
- `void time_benchmark_init(t_time_benchmark *benchmark)`
- `void time_benchmark_reset(t_time_benchmark *benchmark)`

### Time/time_duration_thread_safety.cpp

- `bool time_duration_ms_is_thread_safe_enabled(const t_duration_milliseconds *duration)`
- `int time_duration_ms_lock(const t_duration_milliseconds *duration, bool *lock_acquired)`
- `int time_duration_ms_prepare_thread_safety(t_duration_milliseconds *duration)`
- `static int time_duration_ms_report_result(int error_code, int return_value)`
- `void time_duration_ms_teardown_thread_safety(t_duration_milliseconds *duration)`
- `void time_duration_ms_unlock(const t_duration_milliseconds *duration, bool lock_acquired)`

### Time/time_format.cpp

- `ft_string time_format_iso8601(t_time time_value)`
- `ft_string time_format_iso8601_with_offset(t_time time_value, int offset_minutes)`

### Time/time_fps.cpp

- `const char *time_fps::get_error_str() const`
- `int time_fps::get_error() const`
- `int time_fps::set_frames_per_second(long frames_per_second)`
- `long time_fps::get_frames_per_second()`
- `void time_fps::set_error(int error_code)`
- `void time_fps::sleep_to_next_frame()`

### Time/time_high_resolution.cpp

- `double time_high_resolution_diff_seconds(t_high_resolution_time_point start_point, t_high_resolution_time_point end_point)`
- `long long time_high_resolution_diff_ns(t_high_resolution_time_point start_point, t_high_resolution_time_point end_point)`

### Time/time_info_thread_safety.cpp

- `bool time_info_is_thread_safe_enabled(const t_time_info *time_info)`
- `int time_info_lock(const t_time_info *time_info, bool *lock_acquired)`
- `int time_info_prepare_thread_safety(t_time_info *time_info)`
- `void time_info_teardown_thread_safety(t_time_info *time_info)`
- `void time_info_unlock(const t_time_info *time_info, bool lock_acquired)`

### Time/time_monotonic_point.cpp

- `int time_monotonic_point_compare(t_monotonic_time_point first_point, t_monotonic_time_point second_point)`
- `long long time_monotonic_point_diff_ms(t_monotonic_time_point start_point, t_monotonic_time_point end_point)`
- `t_monotonic_time_point time_monotonic_point_add_ms(t_monotonic_time_point time_point, long long milliseconds)`
- `t_monotonic_time_point time_monotonic_point_create(long long milliseconds)`

### Time/time_monotonic_point_thread_safety.cpp

- `bool time_monotonic_point_is_thread_safe_enabled(const t_monotonic_time_point *time_point)`
- `int time_monotonic_point_lock(const t_monotonic_time_point *time_point, bool *lock_acquired)`
- `int time_monotonic_point_prepare_thread_safety(t_monotonic_time_point *time_point)`
- `static int time_monotonic_point_report_result(int error_code, int return_value)`
- `void time_monotonic_point_teardown_thread_safety(t_monotonic_time_point *time_point)`
- `void time_monotonic_point_unlock(const t_monotonic_time_point *time_point, bool lock_acquired)`

### Time/time_monotonic_translate.cpp

- `bool time_monotonic_to_wall_ms(t_monotonic_time_point monotonic_point, t_monotonic_time_point anchor_monotonic, long long anchor_wall_ms, long long &out_wall_ms)`
- `bool time_wall_ms_to_monotonic(long long wall_time_ms, t_monotonic_time_point anchor_monotonic, long long anchor_wall_ms, t_monotonic_time_point &out_monotonic)`

### Time/time_now_ms.cpp

- `long time_now_ms(void)`
- `void time_reset_clock_now_hook(void)`
- `void time_set_clock_now_hook(t_time_clock_now_hook hook)`

### Time/time_parse.cpp

- `bool time_parse_custom(const char *string_input, const char *format, std::tm *time_output, t_time *timestamp_output)`
- `bool time_parse_custom(const char *string_input, const char *format, std::tm *time_output, t_time *timestamp_output, bool interpret_as_utc)`
- `bool time_parse_iso8601(const char *string_input, std::tm *time_output, t_time *timestamp_output)`
- `static bool parse_timezone_offset(const char *timezone_buffer, int *offset_seconds)`
- `static int get_days_in_month(int year, int month)`

### Time/time_sleep_async.cpp

- `bool time_async_sleep_is_complete(const t_time_async_sleep *sleep_state)`
- `int time_async_sleep_poll(event_loop *loop, t_time_async_sleep *sleep_state)`
- `long long time_async_sleep_remaining_ms(t_time_async_sleep *sleep_state)`

### Time/time_strftime.cpp

- `size_t time_strftime(char *buffer, size_t size, const char *format, const t_time_info *time_info)`

### Time/time_timer.cpp

- `const char *time_timer::get_error_str() const noexcept`
- `ft_operation_error_stack *time_timer::operation_error_stack_handle() const noexcept`
- `int time_timer::get_error() const noexcept`
- `long time_timer::add_time(long amount_ms) noexcept`
- `long time_timer::remove_time(long amount_ms) noexcept`
- `long time_timer::update() noexcept`
- `pt_mutex *time_timer::get_mutex_for_validation() const noexcept`
- `void time_timer::record_operation_error(int error_code) const noexcept`
- `void time_timer::sleep_remaining() noexcept`
- `void time_timer::start(long duration_ms) noexcept`

### Time/time_timezone.cpp

- `bool time_convert_timezone(t_time time_value, int source_offset_minutes, int target_offset_minutes, t_time *converted_time)`
- `bool time_get_local_offset(t_time time_value, int *offset_minutes, bool *is_daylight_saving)`

### Time/time_trace.cpp

- `bool time_trace_begin_event(const char *name, const char *category)`
- `bool time_trace_begin_session(const char *file_path)`
- `bool time_trace_end_event(void)`
- `bool time_trace_end_session(void)`
- `bool time_trace_instant_event(const char *name, const char *category)`
- `static bool time_trace_write_duration_event(const std::string &name, const std::string &category, long long start_us, long long duration_us)`
- `static bool time_trace_write_event_line(const std::string &line)`
- `static bool time_trace_write_instant_event(const std::string &name, const std::string &category, long long timestamp_us)`
- `static bool time_trace_write_raw(const char *buffer, size_t length, bool flush)`
- `static long long time_trace_elapsed_microseconds(std::chrono::steady_clock::time_point moment)`
- `static std::string time_trace_escape_json(const char *input)`
- `static std::string time_trace_long_long_to_string(long long value)`

### Time/timer.hpp

- `const char *get_error_str() const noexcept;`
- `ft_operation_error_stack *operation_error_stack_handle() const noexcept;`
- `int get_error() const noexcept;`
- `long add_time(long amount_ms) noexcept;`
- `long remove_time(long amount_ms) noexcept;`
- `long update() noexcept;`
- `pt_mutex *get_mutex_for_validation() const noexcept;`
- `public: time_timer() noexcept;`
- `void record_operation_error(int error_code) const noexcept;`
- `void sleep_remaining() noexcept;`
- `void start(long duration_ms) noexcept;`

### XML/xml.hpp

- `bool xml_node_is_thread_safe_enabled(const xml_node *node) noexcept;`
- `int xml_node_lock(const xml_node *node, bool *lock_acquired) noexcept;`
- `int xml_node_prepare_thread_safety(xml_node *node) noexcept;`
- `void xml_node_teardown_thread_safety(xml_node *node) noexcept;`
- `void xml_node_unlock(const xml_node *node, bool lock_acquired) noexcept;`

### XML/xml_document.cpp

- `bool xml_document::is_thread_safe_enabled() const noexcept`
- `bool xml_document::thread_guard::lock_acquired() const noexcept`
- `char *xml_document::write_to_string() const noexcept`
- `const char *xml_document::get_error_str() const noexcept`
- `int xml_document::get_error() const noexcept`
- `int xml_document::load_from_backend(ft_document_source &source) noexcept`
- `int xml_document::load_from_file(const char *file_path) noexcept`
- `int xml_document::load_from_string(const char *xml) noexcept`
- `int xml_document::lock(bool *lock_acquired) const noexcept`
- `int xml_document::prepare_thread_safety() noexcept`
- `int xml_document::thread_guard::get_status() const noexcept`
- `int xml_document::write_to_backend(ft_document_sink &sink) const noexcept`
- `int xml_document::write_to_file(const char *file_path) const noexcept`
- `static char *duplicate_range(const char *start, size_t length)`
- `static const char *parse_node(const char *string, xml_node **out_node, const xml_namespace_entry *scope_head)`
- `static const char *skip_whitespace(const char *string)`
- `static const char *xml_resolve_namespace_uri( const xml_namespace_entry *scope_head, const char *prefix)`
- `static const char *xml_skip_whitespace_range(const char *cursor, const char *end)`
- `static int is_xml_whitespace(char character)`
- `static int read_file_content(const char *file_path, char **out_content)`
- `static int translate_vector_error(int error_code)`
- `static int write_node(const xml_node *node, ft_vector<char> &buffer)`
- `static int xml_add_namespace_binding(xml_node *node, const char *prefix, size_t prefix_length, const char *uri, const xml_namespace_entry **active_scope)`
- `static int xml_parse_attributes(xml_node *node, const char *start, const char *end, const xml_namespace_entry *scope_head, const xml_namespace_entry **out_scope)`
- `static void append_node_qualified_name(const xml_node *node, ft_vector<char> &buffer)`
- `static void append_string(ft_vector<char> &buffer, const char *string)`
- `void xml_document::set_error(int error_code) const noexcept`
- `void xml_document::set_manual_error(int error_code) noexcept`
- `void xml_document::teardown_thread_safety() noexcept`
- `void xml_document::unlock(bool lock_acquired) const noexcept`
- `xml_node *xml_document::get_root() const noexcept`

### XML/xml_dom_bridge.cpp

- `int xml_document_from_dom(const ft_dom_document &dom, xml_document &document) noexcept`
- `int xml_document_to_dom(const xml_document &document, ft_dom_document &dom) noexcept`
- `static int xml_dom_append_text(ft_string &output, const char *text) noexcept`
- `static int xml_dom_check_string_error(const ft_string &value) noexcept`
- `static int xml_dom_pop_last_string_error(const ft_string &value) noexcept`
- `static int xml_dom_populate_node(const xml_node *source, ft_dom_node *target) noexcept`
- `static int xml_dom_populate_node(const xml_node *source, ft_dom_node *target) noexcept;`
- `static int xml_dom_populate_node_locked(const xml_node *source, ft_dom_node *target) noexcept`
- `static int xml_dom_serialize_node(ft_dom_node *node, ft_string &output) noexcept`

### XML/xml_dom_bridge.hpp

- `int xml_document_from_dom(const ft_dom_document &dom, xml_document &document) noexcept;`

### XML/xml_node_thread_safety.cpp

- `bool xml_node_is_thread_safe_enabled(const xml_node *node) noexcept`
- `int xml_node_lock(const xml_node *node, bool *lock_acquired) noexcept`
- `void xml_node_teardown_thread_safety(xml_node *node) noexcept`
- `void xml_node_unlock(const xml_node *node, bool lock_acquired) noexcept`

### YAML/yaml.hpp

- `ft_string yaml_substr(const ft_string &string, size_t start, size_t length) noexcept;`
- `ft_string yaml_substr_from(const ft_string &string, size_t start) noexcept;`
- `ft_string yaml_write_to_string(const yaml_value *value) noexcept;`
- `int yaml_split_lines(const ft_string &content, ft_vector<ft_string> &lines) noexcept;`
- `int yaml_write_to_backend(ft_document_sink &sink, const yaml_value *value) noexcept;`
- `int yaml_write_to_file(const char *file_path, const yaml_value *value) noexcept;`
- `size_t yaml_count_indent(const ft_string &line) noexcept;`
- `size_t yaml_find_char(const ft_string &string, char character) noexcept;`
- `void yaml_free(yaml_value *value) noexcept;`
- `void yaml_trim(ft_string &string) noexcept;`
- `yaml_value *yaml_read_from_backend(ft_document_source &source) noexcept;`
- `yaml_value *yaml_read_from_file(const char *file_path) noexcept;`
- `yaml_value *yaml_read_from_string(const ft_string &content) noexcept;`

### YAML/yaml_dom_bridge.cpp

- `int yaml_value_to_dom(const yaml_value *value, ft_dom_document &dom) noexcept`
- `static int yaml_dom_populate_node(const yaml_value *value, ft_dom_node *node) noexcept`
- `static void yaml_dom_delete_node(ft_dom_node *node) noexcept`
- `static yaml_value *yaml_dom_build_value(ft_dom_node *node, int *status) noexcept`
- `yaml_value *yaml_value_from_dom(const ft_dom_document &dom) noexcept`

### YAML/yaml_dom_bridge.hpp

- `int yaml_value_to_dom(const yaml_value *value, ft_dom_document &dom) noexcept;`

### YAML/yaml_reader.cpp

- `list_cleanup: if (list_value != ft_nullptr)`
- `map_cleanup: if (map_value != ft_nullptr)`
- `static yaml_value *parse_value(const ft_vector<ft_string> &lines, size_t &index, int indent, int *error_code_out) noexcept`
- `void yaml_free(yaml_value *value) noexcept`
- `yaml_value *yaml_read_from_backend(ft_document_source &source) noexcept`
- `yaml_value *yaml_read_from_file(const char *file_path) noexcept`
- `yaml_value *yaml_read_from_string(const ft_string &content) noexcept`

### YAML/yaml_reader_utils.cpp

- `ft_string yaml_substr(const ft_string &string, size_t start, size_t length) noexcept`
- `ft_string yaml_substr_from(const ft_string &string, size_t start) noexcept`
- `int yaml_split_lines(const ft_string &content, ft_vector<ft_string> &lines) noexcept`
- `size_t yaml_count_indent(const ft_string &line) noexcept`
- `void yaml_trim(ft_string &string) noexcept`

### YAML/yaml_value.cpp

- `bool yaml_value::is_thread_safe_enabled() const noexcept`
- `bool yaml_value::thread_guard::lock_acquired() const noexcept`
- `const char *yaml_value::get_error_str() const noexcept`
- `const ft_map<ft_string, yaml_value*> &yaml_value::get_map() const noexcept`
- `const ft_string &yaml_value::get_scalar() const noexcept`
- `const ft_vector<ft_string> &yaml_value::get_map_keys() const noexcept`
- `const ft_vector<yaml_value*> &yaml_value::get_list() const noexcept`
- `int yaml_value::get_error() const noexcept`
- `int yaml_value::lock(bool *lock_acquired) const noexcept`
- `int yaml_value::prepare_thread_safety() noexcept`
- `int yaml_value::thread_guard::get_status() const noexcept`
- `int yaml_value::unlock(bool lock_acquired) const noexcept`
- `pt_mutex *yaml_value::mutex_handle() const noexcept`
- `void yaml_value::add_list_item(yaml_value *item) noexcept`
- `void yaml_value::add_map_item(const ft_string &key, yaml_value *value) noexcept`
- `void yaml_value::record_operation_error_unlocked(int error_code) const noexcept`
- `void yaml_value::set_error(int error_code) const noexcept`
- `void yaml_value::set_scalar(const ft_string &value) noexcept`
- `void yaml_value::set_type(yaml_type type) noexcept`
- `void yaml_value::teardown_thread_safety() noexcept`
- `yaml_type yaml_value::get_type() const noexcept`

### YAML/yaml_writer.cpp

- `ft_string yaml_write_to_string(const yaml_value *value) noexcept`
- `int yaml_write_to_backend(ft_document_sink &sink, const yaml_value *value) noexcept`
- `int yaml_write_to_file(const char *file_path, const yaml_value *value) noexcept`
- `static int write_node(const yaml_value *value, ft_string &output, int indent) noexcept`

## Constructors

### API/api.hpp

- `api_streaming_handler() noexcept;`
- `api_streaming_handler();`
- `api_streaming_handler(api_streaming_handler &&other) noexcept;`
- `api_streaming_handler(const api_streaming_handler &other) noexcept;`

### API/api_connection_pool.cpp

- `api_pooled_connection();`

### API/api_connection_pool_handle.cpp

- `api_connection_pool_handle::api_connection_pool_handle( api_connection_pool_handle &&other) : _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), key(), socket(), tls_session(ft_nullptr), tls_context(ft_nullptr), security_mode(api_connection_security_mode::PLAIN), has_socket(false), from_pool(false), should_store(false), negotiated_http2(false), plain_socket_timed_out(false), plain_socket_validated(false)`
- `api_connection_pool_handle_lock_guard::api_connection_pool_handle_lock_guard( api_connection_pool_handle &handle) : _handle(handle), _lock_acquired(false), _lock_result(-1)`

### API/api_request.cpp

- `api_request_error_guard() {`
- `api_request_error_guard(int *value) : code(value) {`

### API/api_request_metrics.hpp

- `api_request_metrics_guard() noexcept {`
- `api_request_metrics_guard(const char *host, uint16_t port, const char *method, const char *resource, size_t request_bytes, char **result_body, int *status_pointer, int *error_pointer) noexcept {`

### API/api_request_tls.cpp

- `api_request_errno_guard() {`
- `api_request_errno_guard(int *value) : code(value) {`

### API/api_retry_policy.cpp

- `api_retry_policy::api_retry_policy() noexcept : _max_attempts(0), _initial_delay_ms(0), _max_delay_ms(0), _backoff_multiplier(0), _circuit_breaker_threshold(0), _circuit_breaker_cooldown_ms(0), _circuit_breaker_half_open_successes(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `api_retry_policy::api_retry_policy(api_retry_policy &&other) noexcept : _max_attempts(0), _initial_delay_ms(0), _max_delay_ms(0), _backoff_multiplier(0), _circuit_breaker_threshold(0), _circuit_breaker_cooldown_ms(0), _circuit_breaker_half_open_successes(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `api_retry_policy::api_retry_policy(const api_retry_policy &other) noexcept : _max_attempts(0), _initial_delay_ms(0), _max_delay_ms(0), _backoff_multiplier(0), _circuit_breaker_threshold(0), _circuit_breaker_cooldown_ms(0), _circuit_breaker_half_open_successes(0), _error_code(FT_ERR_SUCCESSS), _mutex()`

### API/api_streaming_handler.cpp

- `api_streaming_handler::api_streaming_handler( api_streaming_handler &&other) noexcept : _headers_callback(ft_nullptr), _body_callback(ft_nullptr), _user_data(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `api_streaming_handler::api_streaming_handler( const api_streaming_handler &other) noexcept : _headers_callback(ft_nullptr), _body_callback(ft_nullptr), _user_data(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `api_streaming_handler::api_streaming_handler() noexcept : _headers_callback(ft_nullptr), _body_callback(ft_nullptr), _user_data(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex()`

### API/api_tls_client.cpp

- `api_tls_client::api_tls_client(const char *host_c, uint16_t port, int timeout_ms) : _ctx(ft_nullptr), _ssl(ft_nullptr), _sock(-1), _host(""), _timeout(timeout_ms), _error_code(FT_ERR_SUCCESSS)`

### CMA/cma_alloc_limit_guard.cpp

- `cma_alloc_limit_guard::cma_alloc_limit_guard(cma_alloc_limit_guard &&other) noexcept : _previous_limit(other._previous_limit), _active(other._active), _error_code(other._error_code)`

### CMA/cma_alloc_limit_guard.hpp

- `cma_alloc_limit_guard();`
- `cma_alloc_limit_guard(cma_alloc_limit_guard &&other) noexcept;`
- `cma_alloc_limit_guard(const cma_alloc_limit_guard &) = delete;`
- `cma_alloc_limit_guard(ft_size_t new_limit);`

### CMA/cma_allocation_guard.cpp

- `cma_allocation_guard::cma_allocation_guard() : _pointer(ft_nullptr), _error_code(FT_ERR_SUCCESSS)`
- `cma_allocation_guard::cma_allocation_guard(cma_allocation_guard &&other) noexcept : _pointer(other._pointer), _error_code(other._error_code)`
- `cma_allocation_guard::cma_allocation_guard(void *memory_pointer) : _pointer(memory_pointer), _error_code(FT_ERR_SUCCESSS)`

### CMA/cma_allocation_guard.hpp

- `cma_allocation_guard();`
- `cma_allocation_guard(cma_allocation_guard &&other) noexcept;`
- `cma_allocation_guard(const cma_allocation_guard &) = delete;`
- `cma_allocation_guard(void *memory_pointer);`

### CMA/cma_allocator_guard.cpp

- `cma_allocator_guard::cma_allocator_guard() : _lock_acquired(false), _active(false), _was_active(false), _error_code(FT_ERR_SUCCESSS), _failure_logged(false), _owned_mutexes(CMA_GUARD_VECTOR_MIN_CAPACITY)`

### CMA/cma_internal.hpp

- `cma_allocator_guard();`

### CPP_class/class_big_number.hpp

- `ft_big_number() noexcept;`
- `ft_big_number(const ft_big_number& other) noexcept;`
- `ft_big_number(ft_big_number&& other) noexcept;`

### CPP_class/class_data_buffer.hpp

- `DataBuffer() noexcept;`
- `DataBuffer(DataBuffer&& other) noexcept;`
- `DataBuffer(const DataBuffer& other) noexcept;`

### CPP_class/class_fd_istream.hpp

- `ft_fd_istream() noexcept;`
- `ft_fd_istream(const ft_fd_istream &other) noexcept;`
- `ft_fd_istream(ft_fd_istream &&other) noexcept;`
- `ft_fd_istream(int fd) noexcept;`

### CPP_class/class_file.hpp

- `ft_file() noexcept;`
- `ft_file(const char* filename, int flags) noexcept;`
- `ft_file(const char* filename, int flags, mode_t mode) noexcept;`
- `ft_file(const ft_file&) = delete;`
- `ft_file(ft_file&& other) noexcept;`
- `ft_file(int fd) noexcept;`

### CPP_class/class_istream.hpp

- `ft_istream() noexcept;`
- `ft_istream(const ft_istream &other) noexcept;`
- `ft_istream(ft_istream &&other) noexcept;`

### CPP_class/class_istringstream.hpp

- `ft_istringstream() noexcept;`
- `ft_istringstream(const ft_istringstream &) = delete;`
- `ft_istringstream(const ft_string &string) noexcept;`

### CPP_class/class_nullptr.hpp

- `ft_nullptr_t() noexcept;`
- `ft_nullptr_t(const ft_nullptr_t &other) noexcept;`

### CPP_class/class_ofstream.hpp

- `ft_ofstream() noexcept;`

### CPP_class/class_string.hpp

- `ft_string() noexcept;`
- `ft_string();`
- `ft_string(const char *initial_string) noexcept;`
- `ft_string(const ft_string& other) noexcept;`
- `ft_string(ft_string&& other) noexcept;`
- `ft_string(int error_code) noexcept;`
- `ft_string(size_t count, char character) noexcept;`

### CPP_class/class_stringbuf.hpp

- `ft_stringbuf() noexcept;`
- `ft_stringbuf(const ft_string &string) noexcept;`
- `ft_stringbuf(const ft_stringbuf &other) noexcept;`
- `ft_stringbuf(ft_stringbuf &&other) noexcept;`

### CPP_class/cpp_class_big_number.cpp

- `ft_big_number::ft_big_number() noexcept : _digits(ft_nullptr) , _size(0) , _capacity(0) , _is_negative(false) , _mutex()`
- `ft_big_number::ft_big_number(const ft_big_number& other) noexcept : _digits(ft_nullptr) , _size(0) , _capacity(0) , _is_negative(false) , _mutex()`
- `ft_big_number::ft_big_number(ft_big_number&& other) noexcept : _digits(ft_nullptr) , _size(0) , _capacity(0) , _is_negative(false) , _mutex()`

### CPP_class/cpp_class_data_buffer.cpp

- `DataBuffer::DataBuffer() noexcept : _buffer(), _read_pos(0), _ok(true), _mutex()`
- `DataBuffer::DataBuffer(DataBuffer&& other) noexcept : _buffer(), _read_pos(0), _ok(true), _mutex()`
- `DataBuffer::DataBuffer(const DataBuffer &other) noexcept : _buffer(), _read_pos(0), _ok(true), _mutex()`

### CPP_class/cpp_class_fd_istream.cpp

- `ft_fd_istream::ft_fd_istream(const ft_fd_istream &other) noexcept : ft_istream(other) , _fd(0) , _mutex() , _operation_errors()`
- `ft_fd_istream::ft_fd_istream(ft_fd_istream &&other) noexcept : ft_istream(ft_move(other)) , _fd(0) , _mutex() , _operation_errors()`
- `ft_fd_istream::ft_fd_istream(int fd) noexcept : _fd(fd) , _mutex() , _operation_errors()`

### CPP_class/cpp_class_file.cpp

- `ft_file::ft_file() noexcept : _fd(-1), _mutex(), _is_open(false)`
- `ft_file::ft_file(const char* filename, int flags) noexcept : _fd(-1), _mutex(), _is_open(false)`
- `ft_file::ft_file(const char* filename, int flags, mode_t mode) noexcept : _fd(-1), _mutex(), _is_open(false)`
- `ft_file::ft_file(ft_file&& other) noexcept : _fd(-1), _mutex(), _is_open(false)`
- `ft_file::ft_file(int fd) noexcept : _fd(fd), _mutex(), _is_open(fd >= 0)`

### CPP_class/cpp_class_istream.cpp

- `ft_istream::ft_istream() noexcept : _gcount(0) , _bad(false) , _error_code(FT_ERR_SUCCESSS) , _mutex()`
- `ft_istream::ft_istream(const ft_istream &other) noexcept : _gcount(0) , _bad(false) , _error_code(FT_ERR_SUCCESSS) , _mutex()`
- `ft_istream::ft_istream(ft_istream &&other) noexcept : _gcount(0) , _bad(false) , _error_code(FT_ERR_SUCCESSS) , _mutex()`

### CPP_class/cpp_class_nullptr.cpp

- `ft_nullptr_t::ft_nullptr_t(const ft_nullptr_t &other) noexcept`

### CPP_class/cpp_class_ofstream.cpp

- `ft_ofstream::ft_ofstream() noexcept : _file(), _mutex(), _operation_errors()`

### CPP_class/cpp_class_string_constructors.cpp

- `ft_string::ft_string(const char* initial_string) noexcept : _data(ft_nullptr) , _length(0) , _capacity(0) , _mutex()`
- `ft_string::ft_string(const ft_string& other) noexcept : _data(ft_nullptr) , _length(0) , _capacity(0) , _mutex()`
- `ft_string::ft_string(ft_string&& other) noexcept : _data(ft_nullptr) , _length(0) , _capacity(0) , _mutex()`
- `ft_string::ft_string(int error_code) noexcept : _data(ft_nullptr) , _length(0) , _capacity(0) , _mutex()`
- `ft_string::ft_string(size_t count, char character) noexcept : _data(ft_nullptr) , _length(0) , _capacity(0) , _mutex()`

### CPP_class/cpp_class_string_methods.cpp

- `ft_string::mutex_guard::mutex_guard() noexcept : _mutex(ft_nullptr), _owns_lock(false), _error_code(FT_ERR_SUCCESSS)`
- `ft_string::mutex_guard::mutex_guard(mutex_guard &&other) noexcept : _mutex(other._mutex), _owns_lock(other._owns_lock), _error_code(other._error_code)`

### CPP_class/cpp_class_stringbuf.cpp

- `ft_stringbuf::ft_stringbuf(const ft_string &string) noexcept : _storage(string) , _position(0) , _error_code(FT_ERR_SUCCESSS) , _mutex()`
- `ft_stringbuf::ft_stringbuf(const ft_stringbuf &other) noexcept : _storage(other._storage) , _position(other._position) , _error_code(FT_ERR_SUCCESSS) , _mutex()`
- `ft_stringbuf::ft_stringbuf(ft_stringbuf &&other) noexcept : _storage(ft_move(other._storage)) , _position(other._position) , _error_code(FT_ERR_SUCCESSS) , _mutex()`

### Compression/compression_stream.cpp

- `t_compress_stream_options::t_compress_stream_options(void)`

### Config/config_flag_parser.cpp

- `cnfg_flag_parser::cnfg_flag_parser()`
- `cnfg_flag_parser::cnfg_flag_parser(int argument_count, char **argument_values)`

### Config/flag_parser.hpp

- `cnfg_flag_parser();`
- `cnfg_flag_parser(int argument_count, char **argument_values);`

### DUMB/dumb_render.cpp

- `ft_render_window::ft_render_window(void)`

### DUMB/dumb_sound_clip.hpp

- `ft_sound_clip(void);`

### DUMB/dumb_sound_linux_alsa.cpp

- `ft_sound_device_alsa());`
- `ft_sound_device_alsa(void) {`

### DUMB/dumb_sound_macos_coreaudio.cpp

- `ft_sound_device_coreaudio());`
- `ft_sound_device_coreaudio(void) {`

### DUMB/dumb_sound_win32.cpp

- `ft_sound_device_win32());`
- `ft_sound_device_win32(void) {`

### Encryption/encryption_aead.cpp

- `encryption_aead_context::encryption_aead_context()`
- `encryption_aead_context::encryption_aead_context(encryption_aead_context &&other) noexcept`

### Encryption/encryption_aead.hpp

- `encryption_aead_context();`
- `encryption_aead_context(const encryption_aead_context &other) = delete;`
- `encryption_aead_context(encryption_aead_context &&other) noexcept;`

### Errno/errno_code.cpp

- `ft_errno_mutex_wrapper::ft_errno_mutex_wrapper(void)`

### Errno/errno_internal.hpp

- `ft_errno_mutex_wrapper(const ft_errno_mutex_wrapper &other) = delete;`
- `ft_errno_mutex_wrapper(ft_errno_mutex_wrapper &&other) = delete;`
- `ft_errno_mutex_wrapper(void);`

### File/file_watch.hpp

- `ft_file_watch();`

### Game/ft_behavior_action.hpp

- `ft_behavior_action() = default;`
- `ft_behavior_action() noexcept;`
- `ft_behavior_action(const ft_behavior_action &other) noexcept;`
- `ft_behavior_action(ft_behavior_action &&other) noexcept;`
- `ft_behavior_action(int action_id, double weight, double cooldown_seconds) noexcept;`

### Game/ft_behavior_profile.hpp

- `ft_behavior_profile() = default;`
- `ft_behavior_profile() noexcept;`
- `ft_behavior_profile(const ft_behavior_profile &other) noexcept;`
- `ft_behavior_profile(ft_behavior_profile &&other) noexcept;`
- `ft_behavior_profile(int profile_id, double aggression_weight, double caution_weight, const ft_vector<ft_behavior_action> &actions) noexcept;`

### Game/ft_currency_rate.hpp

- `ft_currency_rate() = default;`
- `ft_currency_rate() noexcept;`
- `ft_currency_rate(const ft_currency_rate &other) noexcept;`
- `ft_currency_rate(ft_currency_rate &&other) noexcept;`
- `ft_currency_rate(int currency_id, double rate_to_base, int display_precision) noexcept;`

### Game/ft_dialogue_line.hpp

- `ft_dialogue_line() noexcept;`
- `ft_dialogue_line(const ft_dialogue_line &other) noexcept;`
- `ft_dialogue_line(ft_dialogue_line &&other) noexcept;`
- `ft_dialogue_line(int line_id, const ft_string &speaker, const ft_string &text, const ft_vector<int> &next_line_ids) noexcept;`

### Game/ft_dialogue_script.hpp

- `ft_dialogue_script() noexcept;`
- `ft_dialogue_script(const ft_dialogue_script &other) noexcept;`
- `ft_dialogue_script(ft_dialogue_script &&other) noexcept;`
- `ft_dialogue_script(int script_id, const ft_string &title, const ft_string &summary, int start_line_id, const ft_vector<ft_dialogue_line> &lines) noexcept;`

### Game/ft_price_definition.hpp

- `ft_price_definition() = default;`
- `ft_price_definition() noexcept;`
- `ft_price_definition(const ft_price_definition &other) noexcept;`
- `ft_price_definition(ft_price_definition &&other) noexcept;`
- `ft_price_definition(int item_id, int rarity, int base_value, int minimum_value, int maximum_value) noexcept;`

### Game/ft_rarity_band.hpp

- `ft_rarity_band() = default;`
- `ft_rarity_band() noexcept;`
- `ft_rarity_band(const ft_rarity_band &other) noexcept;`
- `ft_rarity_band(ft_rarity_band &&other) noexcept;`
- `ft_rarity_band(int rarity, double value_multiplier) noexcept;`

### Game/ft_region_definition.hpp

- `ft_region_definition() noexcept;`
- `ft_region_definition(const ft_region_definition &other) noexcept;`
- `ft_region_definition(ft_region_definition &&other) noexcept;`
- `ft_region_definition(int region_id, const ft_string &name, const ft_string &description, int recommended_level) noexcept;`

### Game/ft_vendor_profile.hpp

- `ft_vendor_profile() = default;`
- `ft_vendor_profile() noexcept;`
- `ft_vendor_profile(const ft_vendor_profile &other) noexcept;`
- `ft_vendor_profile(ft_vendor_profile &&other) noexcept;`
- `ft_vendor_profile(int vendor_id, double buy_markup, double sell_multiplier, double tax_rate) noexcept;`

### Game/ft_world_region.hpp

- `ft_world_region() noexcept;`
- `ft_world_region(const ft_world_region &other) noexcept;`
- `ft_world_region(ft_world_region &&other) noexcept;`
- `ft_world_region(int world_id, const ft_vector<int> &region_ids) noexcept;`

### Game/game_achievement.cpp

- `ft_achievement::ft_achievement() noexcept : _id(0), _goals(), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_achievement::ft_achievement(const ft_achievement &other) noexcept : _id(0), _goals(), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_achievement::ft_achievement(ft_achievement &&other) noexcept : _id(0), _goals(), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_goal::ft_goal() noexcept : _target(0), _progress(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_goal::ft_goal(const ft_goal &other) noexcept : _target(0), _progress(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_goal::ft_goal(ft_goal &&other) noexcept : _target(0), _progress(0), _error(FT_ERR_SUCCESSS), _mutex()`

### Game/game_achievement.hpp

- `ft_goal() noexcept;`
- `ft_goal(const ft_goal &other) noexcept;`
- `ft_goal(ft_goal &&other) noexcept;`

### Game/game_behavior_action.cpp

- `ft_behavior_action::ft_behavior_action() noexcept : _action_id(0), _weight(0.0), _cooldown_seconds(0.0), _error_code(FT_ERR_SUCCESSS)`
- `ft_behavior_action::ft_behavior_action(const ft_behavior_action &other) noexcept : _action_id(0), _weight(0.0), _cooldown_seconds(0.0), _error_code(FT_ERR_SUCCESSS)`
- `ft_behavior_action::ft_behavior_action(ft_behavior_action &&other) noexcept : _action_id(0), _weight(0.0), _cooldown_seconds(0.0), _error_code(FT_ERR_SUCCESSS)`
- `ft_behavior_action::ft_behavior_action(int action_id, double weight, double cooldown_seconds) noexcept : _action_id(action_id), _weight(weight), _cooldown_seconds(cooldown_seconds), _error_code(FT_ERR_SUCCESSS)`

### Game/game_behavior_profile.cpp

- `ft_behavior_profile::ft_behavior_profile() noexcept : _profile_id(0), _aggression_weight(0.0), _caution_weight(0.0), _actions(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_behavior_profile::ft_behavior_profile(const ft_behavior_profile &other) noexcept : _profile_id(0), _aggression_weight(0.0), _caution_weight(0.0), _actions(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_behavior_profile::ft_behavior_profile(ft_behavior_profile &&other) noexcept : _profile_id(0), _aggression_weight(0.0), _caution_weight(0.0), _actions(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_behavior_profile::ft_behavior_profile(int profile_id, double aggression_weight, double caution_weight, const ft_vector<ft_behavior_action> &actions) noexcept : _profile_id(profile_id), _aggression_weight(aggression_weight), _caution_weight(caution_weight), _actions(), _error_code(FT_ERR_SUCCESSS), _mutex()`

### Game/game_behavior_table.cpp

- `ft_behavior_table::ft_behavior_table() noexcept : _profiles(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_behavior_table::ft_behavior_table(const ft_behavior_table &other) noexcept : _profiles(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_behavior_table::ft_behavior_table(ft_behavior_table &&other) noexcept : _profiles(), _error_code(FT_ERR_SUCCESSS), _mutex()`

### Game/game_behavior_table.hpp

- `ft_behavior_table() noexcept;`
- `ft_behavior_table(const ft_behavior_table &other) noexcept;`
- `ft_behavior_table(ft_behavior_table &&other) noexcept;`

### Game/game_behavior_tree.cpp

- `ft_behavior_action::ft_behavior_action() noexcept : ft_behavior_node(), _callback()`
- `ft_behavior_action::ft_behavior_action(const ft_behavior_action &other) noexcept : ft_behavior_node(other), _callback(other._callback)`
- `ft_behavior_action::ft_behavior_action(const ft_function<int(ft_behavior_context &)> &callback) noexcept : ft_behavior_node(), _callback(callback)`
- `ft_behavior_composite::ft_behavior_composite() noexcept : ft_behavior_node(), _children()`
- `ft_behavior_composite::ft_behavior_composite(const ft_behavior_composite &other) noexcept : ft_behavior_node(other), _children()`
- `ft_behavior_context::ft_behavior_context(const ft_behavior_context &other) noexcept : _character(other._character), _user_data(other._user_data)`
- `ft_behavior_node::ft_behavior_node() noexcept : _error_code(FT_ERR_SUCCESSS)`
- `ft_behavior_node::ft_behavior_node(const ft_behavior_node &other) noexcept : _error_code(other._error_code)`
- `ft_behavior_selector::ft_behavior_selector() noexcept : ft_behavior_composite()`
- `ft_behavior_selector::ft_behavior_selector(const ft_behavior_selector &other) noexcept : ft_behavior_composite(other)`
- `ft_behavior_sequence::ft_behavior_sequence() noexcept : ft_behavior_composite()`
- `ft_behavior_sequence::ft_behavior_sequence(const ft_behavior_sequence &other) noexcept : ft_behavior_composite(other)`
- `ft_behavior_tree::ft_behavior_tree() noexcept : _root(), _error_code(FT_ERR_SUCCESSS)`
- `ft_behavior_tree::ft_behavior_tree(const ft_behavior_tree &other) noexcept : _root(other._root), _error_code(other._error_code)`

### Game/game_behavior_tree.hpp

- `ft_behavior_context() noexcept;`
- `ft_behavior_context(const ft_behavior_context &other) noexcept;`

### Game/game_buff.cpp

- `ft_buff::ft_buff() noexcept : _id(0), _duration(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_buff::ft_buff(const ft_buff &other) noexcept : _id(0), _duration(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_buff::ft_buff(ft_buff &&other) noexcept : _id(0), _duration(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _error(FT_ERR_SUCCESSS), _mutex()`

### Game/game_buff.hpp

- `ft_buff() = default;`
- `ft_buff() noexcept;`
- `ft_buff(const ft_buff &other) noexcept;`
- `ft_buff(ft_buff &&other) noexcept;`

### Game/game_character.hpp

- `ft_character() noexcept;`
- `ft_character(const ft_character &other) noexcept;`
- `ft_character(ft_character &&other) noexcept;`

### Game/game_character_constructor.cpp

- `ft_character::ft_character() noexcept : _hit_points(0), _physical_armor(0), _magic_armor(0), _current_physical_armor(0), _current_magic_armor(0), _physical_damage_multiplier(1.0), _magic_damage_multiplier(1.0), _damage_rule(FT_DAMAGE_RULE_FLAT), _might(0), _agility(0), _endurance(0), _reason(0), _insigh(0), _presence(0), _coins(0), _valor(0), _experience(0), _x(0), _y(0), _z(0), _fire_res(), _frost_res(), _lightning_res(), _air_res(), _earth_res(), _chaos_res(), _physical_res(), _skills(), _buffs(), _debuffs(), _upgrades(), _quests(), _achievements(), _reputation(), _inventory(), _equipment(), _error(FT_ERR_SUCCESSS), _mutex(), _operation_errors(`
- `ft_character::ft_character(const ft_character &other) noexcept : ft_character()`
- `ft_character::ft_character(ft_character &&other) noexcept : ft_character()`

### Game/game_crafting.cpp

- `ft_crafting::ft_crafting() noexcept : _recipes(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_crafting::ft_crafting(const ft_crafting &other) noexcept : _recipes(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_crafting::ft_crafting(ft_crafting &&other) noexcept : _recipes(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_crafting_ingredient::ft_crafting_ingredient() noexcept : _item_id(0), _count(0), _rarity(-1), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_crafting_ingredient::ft_crafting_ingredient(const ft_crafting_ingredient &other) noexcept : _item_id(0), _count(0), _rarity(-1), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_crafting_ingredient::ft_crafting_ingredient(ft_crafting_ingredient &&other) noexcept : _item_id(0), _count(0), _rarity(-1), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_crafting_ingredient::ft_crafting_ingredient(int item_id, int count, int rarity) noexcept : _item_id(item_id), _count(count), _rarity(rarity), _error_code(FT_ERR_SUCCESSS), _mutex()`

### Game/game_crafting.hpp

- `ft_crafting_ingredient() = default;`
- `ft_crafting_ingredient() noexcept;`
- `ft_crafting_ingredient(const ft_crafting_ingredient &other) noexcept;`
- `ft_crafting_ingredient(ft_crafting_ingredient &&other) noexcept;`
- `ft_crafting_ingredient(int item_id, int count, int rarity) noexcept;`

### Game/game_currency_rate.cpp

- `ft_currency_rate::ft_currency_rate() noexcept : _currency_id(0), _rate_to_base(1.0), _display_precision(2), _error_code(FT_ERR_SUCCESSS)`
- `ft_currency_rate::ft_currency_rate(const ft_currency_rate &other) noexcept : _currency_id(0), _rate_to_base(1.0), _display_precision(2), _error_code(FT_ERR_SUCCESSS)`
- `ft_currency_rate::ft_currency_rate(ft_currency_rate &&other) noexcept : _currency_id(0), _rate_to_base(1.0), _display_precision(2), _error_code(FT_ERR_SUCCESSS)`
- `ft_currency_rate::ft_currency_rate(int currency_id, double rate_to_base, int display_precision) noexcept : _currency_id(currency_id), _rate_to_base(rate_to_base), _display_precision(display_precision), _error_code(FT_ERR_SUCCESSS)`

### Game/game_data_catalog.cpp

- `ft_data_catalog::ft_data_catalog() noexcept : _item_definitions(), _recipes(), _loadouts(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_data_catalog::ft_data_catalog(const ft_data_catalog &other) noexcept : _item_definitions(), _recipes(), _loadouts(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_data_catalog::ft_data_catalog(ft_data_catalog &&other) noexcept : _item_definitions(), _recipes(), _loadouts(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_item_definition::ft_item_definition() noexcept : _item_id(0), _rarity(0), _max_stack(0), _width(0), _height(0), _weight(0), _slot_requirement(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_item_definition::ft_item_definition(const ft_item_definition &other) noexcept : _item_id(0), _rarity(0), _max_stack(0), _width(0), _height(0), _weight(0), _slot_requirement(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_item_definition::ft_item_definition(ft_item_definition &&other) noexcept : _item_id(0), _rarity(0), _max_stack(0), _width(0), _height(0), _weight(0), _slot_requirement(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_item_definition::ft_item_definition(int item_id, int rarity, int max_stack, int width, int height, int weight, int slot_requirement) noexcept : _item_id(item_id), _rarity(rarity), _max_stack(max_stack), _width(width), _height(height), _weight(weight), _slot_requirement(slot_requirement), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_loadout_blueprint::ft_loadout_blueprint() noexcept : _loadout_id(0), _entries(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_loadout_blueprint::ft_loadout_blueprint(const ft_loadout_blueprint &other) noexcept : _loadout_id(0), _entries(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_loadout_blueprint::ft_loadout_blueprint(ft_loadout_blueprint &&other) noexcept : _loadout_id(0), _entries(ft_move(other._entries)), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_loadout_blueprint::ft_loadout_blueprint(int loadout_id, const ft_vector<ft_loadout_entry> &entries) noexcept : _loadout_id(loadout_id), _entries(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_loadout_entry::ft_loadout_entry() noexcept : _slot(0), _item_id(0), _quantity(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_loadout_entry::ft_loadout_entry(const ft_loadout_entry &other) noexcept : _slot(0), _item_id(0), _quantity(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_loadout_entry::ft_loadout_entry(ft_loadout_entry &&other) noexcept : _slot(0), _item_id(0), _quantity(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_loadout_entry::ft_loadout_entry(int slot, int item_id, int quantity) noexcept : _slot(slot), _item_id(item_id), _quantity(quantity), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_recipe_blueprint::ft_recipe_blueprint() noexcept : _recipe_id(0), _result_item_id(0), _ingredients(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_recipe_blueprint::ft_recipe_blueprint(const ft_recipe_blueprint &other) noexcept : _recipe_id(0), _result_item_id(0), _ingredients(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_recipe_blueprint::ft_recipe_blueprint(ft_recipe_blueprint &&other) noexcept : _recipe_id(0), _result_item_id(0), _ingredients(ft_move(other._ingredients)), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_recipe_blueprint::ft_recipe_blueprint(int recipe_id, int result_item_id, const ft_vector<ft_crafting_ingredient> &ingredients) noexcept : _recipe_id(recipe_id), _result_item_id(result_item_id), _ingredients(), _error_code(FT_ERR_SUCCESSS), _mutex()`

### Game/game_data_catalog.hpp

- `ft_item_definition() = default;`
- `ft_item_definition() noexcept;`
- `ft_item_definition(const ft_item_definition &other) noexcept;`
- `ft_item_definition(ft_item_definition &&other) noexcept;`
- `ft_item_definition(int item_id, int rarity, int max_stack, int width, int height, int weight, int slot_requirement) noexcept;`

### Game/game_debuff.cpp

- `ft_debuff::ft_debuff() noexcept : _id(0), _duration(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_debuff::ft_debuff(const ft_debuff &other) noexcept : _id(0), _duration(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_debuff::ft_debuff(ft_debuff &&other) noexcept : _id(0), _duration(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _error(FT_ERR_SUCCESSS), _mutex()`

### Game/game_debuff.hpp

- `ft_debuff() = default;`
- `ft_debuff() noexcept;`
- `ft_debuff(const ft_debuff &other) noexcept;`
- `ft_debuff(ft_debuff &&other) noexcept;`

### Game/game_dialogue_line.cpp

- `ft_dialogue_line::ft_dialogue_line() noexcept : _line_id(0), _speaker(), _text(), _next_line_ids(), _error_code(FT_ERR_SUCCESSS)`
- `ft_dialogue_line::ft_dialogue_line(const ft_dialogue_line &other) noexcept : _line_id(0), _speaker(), _text(), _next_line_ids(), _error_code(FT_ERR_SUCCESSS)`
- `ft_dialogue_line::ft_dialogue_line(ft_dialogue_line &&other) noexcept : _line_id(0), _speaker(), _text(), _next_line_ids(), _error_code(FT_ERR_SUCCESSS)`
- `ft_dialogue_line::ft_dialogue_line(int line_id, const ft_string &speaker, const ft_string &text, const ft_vector<int> &next_line_ids) noexcept : _line_id(line_id), _speaker(speaker), _text(text), _next_line_ids(), _error_code(FT_ERR_SUCCESSS)`

### Game/game_dialogue_script.cpp

- `ft_dialogue_script::ft_dialogue_script() noexcept : _script_id(0), _title(), _summary(), _start_line_id(0), _lines(), _error_code(FT_ERR_SUCCESSS)`
- `ft_dialogue_script::ft_dialogue_script(const ft_dialogue_script &other) noexcept : _script_id(0), _title(), _summary(), _start_line_id(0), _lines(), _error_code(FT_ERR_SUCCESSS)`
- `ft_dialogue_script::ft_dialogue_script(ft_dialogue_script &&other) noexcept : _script_id(0), _title(), _summary(), _start_line_id(0), _lines(), _error_code(FT_ERR_SUCCESSS)`
- `ft_dialogue_script::ft_dialogue_script(int script_id, const ft_string &title, const ft_string &summary, int start_line_id, const ft_vector<ft_dialogue_line> &lines) noexcept : _script_id(script_id), _title(title), _summary(summary), _start_line_id(start_line_id), _lines(), _error_code(FT_ERR_SUCCESSS)`

### Game/game_dialogue_table.cpp

- `ft_dialogue_table::ft_dialogue_table() noexcept : _lines(), _scripts(), _error_code(FT_ERR_SUCCESSS)`
- `ft_dialogue_table::ft_dialogue_table(const ft_dialogue_table &other) noexcept : _lines(), _scripts(), _error_code(FT_ERR_SUCCESSS)`
- `ft_dialogue_table::ft_dialogue_table(ft_dialogue_table &&other) noexcept : _lines(), _scripts(), _error_code(FT_ERR_SUCCESSS)`

### Game/game_dialogue_table.hpp

- `ft_dialogue_table() noexcept;`
- `ft_dialogue_table(const ft_dialogue_table &other) noexcept;`
- `ft_dialogue_table(ft_dialogue_table &&other) noexcept;`

### Game/game_economy_table.cpp

- `ft_economy_table::ft_economy_table() noexcept : _error_code(FT_ERR_SUCCESSS)`
- `ft_economy_table::ft_economy_table(const ft_economy_table &other) noexcept : _error_code(FT_ERR_SUCCESSS) , _mutex()`
- `ft_economy_table::ft_economy_table(ft_economy_table &&other) noexcept : _error_code(FT_ERR_SUCCESSS) , _mutex()`

### Game/game_economy_table.hpp

- `ft_economy_table() noexcept;`
- `ft_economy_table(const ft_economy_table &other) noexcept;`
- `ft_economy_table(ft_economy_table &&other) noexcept;`

### Game/game_equipment.cpp

- `ft_equipment::ft_equipment() noexcept : _head(ft_sharedptr<ft_item>()), _chest(ft_sharedptr<ft_item>()), _weapon(ft_sharedptr<ft_item>()), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_equipment::ft_equipment(const ft_equipment &other) noexcept : _head(ft_sharedptr<ft_item>()), _chest(ft_sharedptr<ft_item>()), _weapon(ft_sharedptr<ft_item>()), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_equipment::ft_equipment(ft_equipment &&other) noexcept : _head(ft_sharedptr<ft_item>()), _chest(ft_sharedptr<ft_item>()), _weapon(ft_sharedptr<ft_item>()), _error_code(FT_ERR_SUCCESSS), _mutex()`

### Game/game_equipment.hpp

- `ft_equipment() = default;`
- `ft_equipment() noexcept;`
- `ft_equipment(const ft_equipment &other) noexcept;`
- `ft_equipment(ft_equipment &&other) noexcept;`

### Game/game_event.cpp

- `ft_event::ft_event() noexcept : _id(0), _duration(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _callback(), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_event::ft_event(const ft_event &other) noexcept : _id(0), _duration(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _callback(), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_event::ft_event(ft_event &&other) noexcept : _id(0), _duration(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _callback(), _error(FT_ERR_SUCCESSS), _mutex()`

### Game/game_event.hpp

- `ft_event() noexcept;`
- `ft_event(const ft_event &other) noexcept;`
- `ft_event(ft_event &&other) noexcept;`

### Game/game_event_scheduler.cpp

- `ft_event_scheduler::ft_event_scheduler() noexcept : _events(), _error_code(FT_ERR_SUCCESSS), _mutex(), _profiling_enabled(false), _profile(), _ready_cache()`
- `ft_event_scheduler::ft_event_scheduler(const ft_event_scheduler &other) noexcept : _events(), _error_code(FT_ERR_SUCCESSS), _mutex(), _profiling_enabled(false), _profile(), _ready_cache()`
- `ft_event_scheduler::ft_event_scheduler(ft_event_scheduler &&other) noexcept : _events(), _error_code(FT_ERR_SUCCESSS), _mutex(), _profiling_enabled(false), _profile(), _ready_cache()`

### Game/game_experience_table.cpp

- `ft_experience_table::ft_experience_table(const ft_experience_table &other) noexcept : _levels(ft_nullptr), _count(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_experience_table::ft_experience_table(ft_experience_table &&other) noexcept : _levels(ft_nullptr), _count(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_experience_table::ft_experience_table(int count) noexcept : _levels(ft_nullptr), _count(0), _error(FT_ERR_SUCCESSS), _mutex()`

### Game/game_experience_table.hpp

- `ft_experience_table();`
- `ft_experience_table(const ft_experience_table &other) noexcept;`
- `ft_experience_table(ft_experience_table &&other) noexcept;`
- `ft_experience_table(int count = 0) noexcept;`

### Game/game_hooks.cpp

- `ft_game_hooks::ft_game_hooks() noexcept : _legacy_item_crafted(), _legacy_character_damaged(), _legacy_event_triggered(), _listener_catalog(), _catalog_metadata(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_game_hooks::ft_game_hooks(const ft_game_hooks &other) noexcept : _legacy_item_crafted(), _legacy_character_damaged(), _legacy_event_triggered(), _listener_catalog(), _catalog_metadata(), _error_code(other._error_code), _mutex()`
- `ft_game_hooks::ft_game_hooks(ft_game_hooks &&other) noexcept : _legacy_item_crafted(), _legacy_character_damaged(), _legacy_event_triggered(), _listener_catalog(), _catalog_metadata(), _error_code(FT_ERR_SUCCESSS), _mutex()`

### Game/game_inventory.cpp

- `ft_inventory::ft_inventory(const ft_inventory &other) noexcept : _items(), _capacity(0), _used_slots(0), _weight_limit(0), _current_weight(0), _next_slot(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_inventory::ft_inventory(ft_inventory &&other) noexcept : _items(), _capacity(0), _used_slots(0), _weight_limit(0), _current_weight(0), _next_slot(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_inventory::ft_inventory(size_t capacity, int weight_limit) noexcept : _items(), _capacity(capacity), _used_slots(0), _weight_limit(weight_limit), _current_weight(0), _next_slot(0), _error(FT_ERR_SUCCESSS), _mutex()`

### Game/game_inventory.hpp

- `ft_inventory() = default;`
- `ft_inventory(const ft_inventory &other) noexcept;`
- `ft_inventory(ft_inventory &&other) noexcept;`
- `ft_inventory(size_t capacity = 0, int weight_limit = 0) noexcept;`

### Game/game_item.cpp

- `ft_item::ft_item() noexcept : _max_stack(0), _stack_size(0), _item_id(0), _rarity(0), _width(1), _height(1), _modifier1(), _modifier2(), _modifier3(), _modifier4(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_item::ft_item(const ft_item &other) noexcept : _max_stack(0), _stack_size(0), _item_id(0), _rarity(0), _width(1), _height(1), _modifier1(), _modifier2(), _modifier3(), _modifier4(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_item::ft_item(ft_item &&other) noexcept : _max_stack(0), _stack_size(0), _item_id(0), _rarity(0), _width(1), _height(1), _modifier1(), _modifier2(), _modifier3(), _modifier4(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_item_modifier::ft_item_modifier() noexcept : _id(0), _value(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_item_modifier::ft_item_modifier(const ft_item_modifier &other) noexcept : _id(0), _value(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_item_modifier::ft_item_modifier(ft_item_modifier &&other) noexcept : _id(0), _value(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_item_modifier::ft_item_modifier(int id, int value) noexcept : _id(id), _value(value), _error_code(FT_ERR_SUCCESSS), _mutex()`

### Game/game_item.hpp

- `ft_item_modifier() = default;`
- `ft_item_modifier() noexcept;`
- `ft_item_modifier(const ft_item_modifier &other) noexcept;`
- `ft_item_modifier(ft_item_modifier &&other) noexcept;`
- `ft_item_modifier(int id, int value) noexcept;`

### Game/game_map3d.cpp

- `ft_map3d::ft_map3d(const ft_map3d &other) : _data(ft_nullptr), _width(0), _height(0), _depth(0), _error(FT_ERR_SUCCESSS), _mutex(), _operation_errors(`
- `ft_map3d::ft_map3d(ft_map3d &&other) noexcept : _data(ft_nullptr), _width(0), _height(0), _depth(0), _error(FT_ERR_SUCCESSS), _mutex(), _operation_errors(`
- `ft_map3d::ft_map3d(size_t width, size_t height, size_t depth, int value) : _data(ft_nullptr), _width(0), _height(0), _depth(0), _error(FT_ERR_SUCCESSS), _mutex(), _operation_errors(`

### Game/game_map3d.hpp

- `ft_map3d();`
- `ft_map3d(const ft_map3d &other);`
- `ft_map3d(ft_map3d &&other) noexcept;`
- `ft_map3d(size_t width = 0, size_t height = 0, size_t depth = 0, int value = 0);`

### Game/game_pathfinding.cpp

- `ft_path_step::ft_path_step() noexcept : _x(0), _y(0), _z(0), _error_code(FT_ERR_SUCCESSS), _system_error_code(FT_SYS_ERR_SUCCESS), _mutex()`
- `ft_path_step::ft_path_step(const ft_path_step &other) noexcept : _x(0), _y(0), _z(0), _error_code(FT_ERR_SUCCESSS), _system_error_code(FT_SYS_ERR_SUCCESS), _mutex()`
- `ft_path_step::ft_path_step(ft_path_step &&other) noexcept : _x(0), _y(0), _z(0), _error_code(FT_ERR_SUCCESSS), _system_error_code(FT_SYS_ERR_SUCCESS), _mutex()`
- `ft_pathfinding::ft_pathfinding() noexcept : _error_code(FT_ERR_SUCCESSS), _current_path(), _needs_replan(false), _mutex()`
- `ft_pathfinding::ft_pathfinding(const ft_pathfinding &other) noexcept : _error_code(FT_ERR_SUCCESSS), _current_path(), _needs_replan(false), _mutex()`
- `ft_pathfinding::ft_pathfinding(ft_pathfinding &&other) noexcept : _error_code(FT_ERR_SUCCESSS), _current_path(), _needs_replan(false), _mutex()`

### Game/game_pathfinding.hpp

- `ft_path_step() noexcept;`
- `ft_path_step(const ft_path_step &other) noexcept;`
- `ft_path_step(ft_path_step &&other) noexcept;`

### Game/game_price_definition.cpp

- `ft_price_definition::ft_price_definition() noexcept : _item_id(0), _rarity(0), _base_value(0), _minimum_value(0), _maximum_value(0), _error_code(FT_ERR_SUCCESSS)`
- `ft_price_definition::ft_price_definition(const ft_price_definition &other) noexcept : _item_id(0), _rarity(0), _base_value(0), _minimum_value(0), _maximum_value(0), _error_code(FT_ERR_SUCCESSS)`
- `ft_price_definition::ft_price_definition(ft_price_definition &&other) noexcept : _item_id(0), _rarity(0), _base_value(0), _minimum_value(0), _maximum_value(0), _error_code(FT_ERR_SUCCESSS)`
- `ft_price_definition::ft_price_definition(int item_id, int rarity, int base_value, int minimum_value, int maximum_value) noexcept : _item_id(item_id), _rarity(rarity), _base_value(base_value), _minimum_value(minimum_value), _maximum_value(maximum_value), _error_code(FT_ERR_SUCCESSS)`

### Game/game_progress_tracker.cpp

- `ft_progress_tracker::ft_progress_tracker() noexcept : _achievements(), _quests(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_progress_tracker::ft_progress_tracker(const ft_progress_tracker &other) noexcept : _achievements(), _quests(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_progress_tracker::ft_progress_tracker(ft_progress_tracker &&other) noexcept : _achievements(), _quests(), _error_code(FT_ERR_SUCCESSS), _mutex()`

### Game/game_progress_tracker.hpp

- `ft_progress_tracker() noexcept;`
- `ft_progress_tracker(const ft_progress_tracker &other) noexcept;`
- `ft_progress_tracker(ft_progress_tracker &&other) noexcept;`

### Game/game_quest.cpp

- `ft_quest::ft_quest() noexcept : _id(0), _phases(0), _current_phase(0), _description(), _objective(), _reward_experience(0), _reward_items(), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_quest::ft_quest(const ft_quest &other) noexcept : _id(0), _phases(0), _current_phase(0), _description(), _objective(), _reward_experience(0), _reward_items(), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_quest::ft_quest(ft_quest &&other) noexcept : _id(0), _phases(0), _current_phase(0), _description(), _objective(), _reward_experience(0), _reward_items(), _error(FT_ERR_SUCCESSS), _mutex()`

### Game/game_quest.hpp

- `ft_quest() noexcept;`
- `ft_quest(const ft_quest &other) noexcept;`
- `ft_quest(ft_quest &&other) noexcept;`

### Game/game_rarity_band.cpp

- `ft_rarity_band::ft_rarity_band() noexcept : _rarity(0), _value_multiplier(1.0), _error_code(FT_ERR_SUCCESSS)`
- `ft_rarity_band::ft_rarity_band(const ft_rarity_band &other) noexcept : _rarity(0), _value_multiplier(1.0), _error_code(FT_ERR_SUCCESSS)`
- `ft_rarity_band::ft_rarity_band(ft_rarity_band &&other) noexcept : _rarity(0), _value_multiplier(1.0), _error_code(FT_ERR_SUCCESSS)`
- `ft_rarity_band::ft_rarity_band(int rarity, double value_multiplier) noexcept : _rarity(rarity), _value_multiplier(value_multiplier), _error_code(FT_ERR_SUCCESSS)`

### Game/game_region_definition.cpp

- `ft_region_definition::ft_region_definition() noexcept : _region_id(0), _name(), _description(), _recommended_level(0), _error_code(FT_ERR_SUCCESSS)`
- `ft_region_definition::ft_region_definition(const ft_region_definition &other) noexcept : _region_id(0), _name(), _description(), _recommended_level(0), _error_code(FT_ERR_SUCCESSS)`
- `ft_region_definition::ft_region_definition(ft_region_definition &&other) noexcept : _region_id(0), _name(), _description(), _recommended_level(0), _error_code(FT_ERR_SUCCESSS)`
- `ft_region_definition::ft_region_definition(int region_id, const ft_string &name, const ft_string &description, int recommended_level) noexcept : _region_id(region_id), _name(name), _description(description), _recommended_level(recommended_level), _error_code(FT_ERR_SUCCESSS)`

### Game/game_reputation.cpp

- `ft_reputation::ft_reputation() noexcept : _milestones(), _reps(), _total_rep(0), _current_rep(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_reputation::ft_reputation(const ft_map<int, int> &milestones, int total) noexcept : _milestones(milestones), _reps(), _total_rep(total), _current_rep(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_reputation::ft_reputation(const ft_reputation &other) noexcept : _milestones(), _reps(), _total_rep(0), _current_rep(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_reputation::ft_reputation(ft_reputation &&other) noexcept : _milestones(), _reps(), _total_rep(0), _current_rep(0), _error(FT_ERR_SUCCESSS), _mutex()`

### Game/game_reputation.hpp

- `ft_reputation() = default;`
- `ft_reputation() noexcept;`
- `ft_reputation(const ft_map<int, int> &milestones, int total = 0) noexcept;`
- `ft_reputation(const ft_reputation &other) noexcept;`
- `ft_reputation(ft_reputation &&other) noexcept;`

### Game/game_resistance.cpp

- `ft_resistance::ft_resistance() noexcept : _percent_value(0), _flat_value(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_resistance::ft_resistance(const ft_resistance &other) noexcept : _percent_value(0), _flat_value(0), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_resistance::ft_resistance(ft_resistance &&other) noexcept : _percent_value(0), _flat_value(0), _error_code(FT_ERR_SUCCESSS), _mutex()`

### Game/game_resistance.hpp

- `ft_resistance() noexcept;`
- `ft_resistance(const ft_resistance &other) noexcept;`
- `ft_resistance(ft_resistance &&other) noexcept;`

### Game/game_scripting_bridge.cpp

- `ft_game_script_bridge::ft_game_script_bridge(const ft_game_script_bridge &other) noexcept : _world(other._world), _callbacks(other._callbacks), _language(other._language), _max_operations(other._max_operations), _error_code(other._error_code), _mutex()`
- `ft_game_script_bridge::ft_game_script_bridge(const ft_sharedptr<ft_world> &world, const char *language) noexcept : _world(world), _callbacks(), _language(), _max_operations(32), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_game_script_bridge::ft_game_script_bridge(ft_game_script_bridge &&other) noexcept : _world(ft_move(other._world)), _callbacks(ft_move(other._callbacks)), _language(ft_move(other._language)), _max_operations(other._max_operations), _error_code(other._error_code), _mutex()`
- `ft_game_script_context::ft_game_script_context() noexcept : _state(ft_nullptr), _world(), _variables(), _error_code(FT_ERR_SUCCESSS)`
- `ft_game_script_context::ft_game_script_context(const ft_game_script_context &other) noexcept : _state(other._state), _world(other._world), _variables(other._variables), _error_code(other._error_code)`
- `ft_game_script_context::ft_game_script_context(ft_game_state *state, const ft_sharedptr<ft_world> &world) noexcept : _state(state), _world(world), _variables(), _error_code(FT_ERR_SUCCESSS)`

### Game/game_scripting_bridge.hpp

- `ft_game_script_context() noexcept;`
- `ft_game_script_context(const ft_game_script_context &other) noexcept;`
- `ft_game_script_context(ft_game_state *state, const ft_sharedptr<ft_world> &world) noexcept;`

### Game/game_server.cpp

- `ft_game_server::ft_game_server(const ft_game_server &other) noexcept : _server(ft_nullptr), _world(), _clients(), _auth_token(), _on_join(ft_nullptr), _on_leave(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_game_server::ft_game_server(const ft_sharedptr<ft_world> &world, const char *auth_token) noexcept : _server(ft_nullptr), _world(world), _clients(), _auth_token(), _on_join(ft_nullptr), _on_leave(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_game_server::ft_game_server(ft_game_server &&other) noexcept : _server(ft_nullptr), _world(), _clients(), _auth_token(), _on_join(ft_nullptr), _on_leave(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex()`

### Game/game_server.hpp

- `ft_game_server();`
- `ft_game_server(const ft_game_server &other) noexcept;`
- `ft_game_server(const ft_sharedptr<ft_world> &world, const char *auth_token = ft_nullptr) noexcept;`
- `ft_game_server(ft_game_server &&other) noexcept;`

### Game/game_skill.cpp

- `ft_skill::ft_skill() noexcept : _id(0), _level(0), _cooldown(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_skill::ft_skill(const ft_skill &other) noexcept : _id(0), _level(0), _cooldown(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_skill::ft_skill(ft_skill &&other) noexcept : _id(0), _level(0), _cooldown(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _error(FT_ERR_SUCCESSS), _mutex()`

### Game/game_skill.hpp

- `ft_skill() noexcept;`
- `ft_skill(const ft_skill &other) noexcept;`
- `ft_skill(ft_skill &&other) noexcept;`

### Game/game_state.cpp

- `ft_game_state::ft_game_state() noexcept : _worlds(), _characters(), _variables(), _hooks(), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_game_state::ft_game_state(const ft_game_state &other) noexcept : _worlds(), _characters(), _variables(), _hooks(), _error_code(other._error_code), _mutex()`
- `ft_game_state::ft_game_state(ft_game_state &&other) noexcept : _worlds(), _characters(), _variables(), _hooks(), _error_code(FT_ERR_SUCCESSS), _mutex()`

### Game/game_state.hpp

- `ft_game_state() noexcept;`
- `ft_game_state(const ft_game_state &other) noexcept;`
- `ft_game_state(ft_game_state &&other) noexcept;`

### Game/game_upgrade.cpp

- `ft_upgrade::ft_upgrade() noexcept : _id(0), _current_level(0), _max_level(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_upgrade::ft_upgrade(const ft_upgrade &other) noexcept : _id(0), _current_level(0), _max_level(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _error(FT_ERR_SUCCESSS), _mutex()`
- `ft_upgrade::ft_upgrade(ft_upgrade &&other) noexcept : _id(0), _current_level(0), _max_level(0), _modifier1(0), _modifier2(0), _modifier3(0), _modifier4(0), _error(FT_ERR_SUCCESSS), _mutex()`

### Game/game_upgrade.hpp

- `ft_upgrade() noexcept;`
- `ft_upgrade(const ft_upgrade &other) noexcept;`
- `ft_upgrade(ft_upgrade &&other) noexcept;`

### Game/game_vendor_profile.cpp

- `ft_vendor_profile::ft_vendor_profile() noexcept : _vendor_id(0), _buy_markup(1.0), _sell_multiplier(1.0), _tax_rate(0.0), _error_code(FT_ERR_SUCCESSS)`
- `ft_vendor_profile::ft_vendor_profile(const ft_vendor_profile &other) noexcept : _vendor_id(0), _buy_markup(1.0), _sell_multiplier(1.0), _tax_rate(0.0), _error_code(FT_ERR_SUCCESSS)`
- `ft_vendor_profile::ft_vendor_profile(ft_vendor_profile &&other) noexcept : _vendor_id(0), _buy_markup(1.0), _sell_multiplier(1.0), _tax_rate(0.0), _error_code(FT_ERR_SUCCESSS)`
- `ft_vendor_profile::ft_vendor_profile(int vendor_id, double buy_markup, double sell_multiplier, double tax_rate) noexcept : _vendor_id(vendor_id), _buy_markup(buy_markup), _sell_multiplier(sell_multiplier), _tax_rate(tax_rate), _error_code(FT_ERR_SUCCESSS)`

### Game/game_world.cpp

- `ft_world::ft_world() noexcept : _event_scheduler(new (std::nothrow) ft_event_scheduler()), _world_registry(new (std::nothrow) ft_world_registry()), _replay_session(new (std::nothrow) ft_world_replay_session()), _economy_table(new (std::nothrow) ft_economy_table()), _crafting(new (std::nothrow) ft_crafting()), _dialogue_table(new (std::nothrow) ft_dialogue_table()), _world_region(new (std::nothrow) ft_world_region()), _quest(new (std::nothrow) ft_quest()), _vendor_profile(new (std::nothrow) ft_vendor_profile()), _upgrade(new (std::nothrow) ft_upgrade()), _error(FT_ERR_SUCCESSS)`
- `ft_world::ft_world(const ft_world &other) noexcept : _event_scheduler(other._event_scheduler), _world_registry(other._world_registry), _replay_session(other._replay_session), _economy_table(other._economy_table), _crafting(other._crafting), _dialogue_table(other._dialogue_table), _world_region(other._world_region), _quest(other._quest), _vendor_profile(other._vendor_profile), _upgrade(other._upgrade), _error(other._error)`
- `ft_world::ft_world(ft_world &&other) noexcept : _event_scheduler(ft_move(other._event_scheduler)), _world_registry(ft_move(other._world_registry)), _replay_session(ft_move(other._replay_session)), _economy_table(ft_move(other._economy_table)), _crafting(ft_move(other._crafting)), _dialogue_table(ft_move(other._dialogue_table)), _world_region(ft_move(other._world_region)), _quest(ft_move(other._quest)), _vendor_profile(ft_move(other._vendor_profile)), _upgrade(ft_move(other._upgrade)), _error(other._error)`

### Game/game_world.hpp

- `ft_world() = default;`
- `ft_world() noexcept;`
- `ft_world(const ft_world &other) noexcept;`
- `ft_world(ft_world &&other) noexcept;`

### Game/game_world_region.cpp

- `ft_world_region::ft_world_region() noexcept : _world_id(0), _region_ids(), _error_code(FT_ERR_SUCCESSS)`
- `ft_world_region::ft_world_region(const ft_world_region &other) noexcept : _world_id(0), _region_ids(), _error_code(FT_ERR_SUCCESSS)`
- `ft_world_region::ft_world_region(ft_world_region &&other) noexcept : _world_id(0), _region_ids(), _error_code(FT_ERR_SUCCESSS)`
- `ft_world_region::ft_world_region(int world_id, const ft_vector<int> &region_ids) noexcept : _world_id(world_id), _region_ids(), _error_code(FT_ERR_SUCCESSS)`

### Game/game_world_registry.cpp

- `ft_world_registry::ft_world_registry(const ft_world_registry &other) noexcept : _regions(), _world_regions(), _error_code(FT_ERR_SUCCESSS)`
- `ft_world_registry::ft_world_registry(ft_world_registry &&other) noexcept : _regions(), _world_regions(), _error_code(FT_ERR_SUCCESSS)`

### Game/game_world_registry.hpp

- `ft_world_registry() noexcept;`
- `ft_world_registry(const ft_world_registry &other) noexcept;`
- `ft_world_registry(ft_world_registry &&other) noexcept;`

### Game/game_world_replay.cpp

- `ft_world_replay_session::ft_world_replay_session() noexcept : _snapshot_payload(), _event_callbacks(), _error_code(FT_ERR_SUCCESSS)`
- `ft_world_replay_session::ft_world_replay_session(const ft_world_replay_session &other) noexcept : _snapshot_payload(other._snapshot_payload), _event_callbacks(), _error_code(other._error_code)`
- `ft_world_replay_session::ft_world_replay_session(ft_world_replay_session &&other) noexcept : _snapshot_payload(ft_move(other._snapshot_payload)), _event_callbacks(ft_move(other._event_callbacks)), _error_code(other._error_code)`

### Game/game_world_replay.hpp

- `ft_world_replay_session() noexcept;`
- `ft_world_replay_session(const ft_world_replay_session &other) noexcept;`
- `ft_world_replay_session(ft_world_replay_session &&other) noexcept;`

### Geometry/geometry_aabb.cpp

- `aabb::aabb()`
- `aabb::aabb(aabb &&other) noexcept : _minimum_x(0.0), _minimum_y(0.0), _maximum_x(0.0), _maximum_y(0.0)`
- `aabb::aabb(const aabb &other) : _minimum_x(0.0), _minimum_y(0.0), _maximum_x(0.0), _maximum_y(0.0)`
- `aabb::aabb(double minimum_x, double minimum_y, double maximum_x, double maximum_y)`

### Geometry/geometry_aabb.hpp

- `aabb();`
- `aabb(aabb &&other) noexcept;`
- `aabb(const aabb &other);`
- `aabb(double minimum_x, double minimum_y, double maximum_x, double maximum_y);`

### Geometry/geometry_circle.cpp

- `circle::circle()`
- `circle::circle(circle &&other) noexcept : _center_x(0.0), _center_y(0.0), _radius(0.0)`
- `circle::circle(const circle &other) : _center_x(0.0), _center_y(0.0), _radius(0.0)`
- `circle::circle(double center_x, double center_y, double radius)`

### Geometry/geometry_circle.hpp

- `circle();`
- `circle(circle &&other) noexcept;`
- `circle(const circle &other);`
- `circle(double center_x, double center_y, double radius);`

### Geometry/geometry_sphere.cpp

- `sphere::sphere()`
- `sphere::sphere(const sphere &other) : _center_x(0.0), _center_y(0.0), _center_z(0.0), _radius(0.0)`
- `sphere::sphere(double center_x, double center_y, double center_z, double radius)`
- `sphere::sphere(sphere &&other) noexcept : _center_x(0.0), _center_y(0.0), _center_z(0.0), _radius(0.0)`

### Geometry/geometry_sphere.hpp

- `sphere();`
- `sphere(const sphere &other);`
- `sphere(double center_x, double center_y, double center_z, double radius);`
- `sphere(sphere &&other) noexcept;`

### GetNextLine/gnl_stream.cpp

- `gnl_stream::gnl_stream() noexcept : _read_callback(ft_nullptr) , _user_data(ft_nullptr) , _file_descriptor(-1) , _file_handle(ft_nullptr) , _close_on_reset(false) , _error_code(FT_ERR_SUCCESSS) , _mutex()`

### GetNextLine/gnl_stream.hpp

- `gnl_stream() noexcept;`
- `gnl_stream(const gnl_stream &other) = delete;`
- `gnl_stream(gnl_stream &&other) = delete;`

### HTML/document.hpp

- `html_document() noexcept;`
- `html_document(const html_document &) = delete;`
- `html_document(html_document &&) = delete;`

### HTML/html_document.cpp

- `html_document::html_document() noexcept : _root(ft_nullptr), _mutex(ft_nullptr), _thread_safe_enabled(false), _operation_errors(`

### JSon/document.hpp

- `json_document() noexcept;`

### JSon/json_document.cpp

- `json_document::json_document() noexcept : _groups(ft_nullptr) , _error_code(FT_ERR_SUCCESSS) , _mutex()`

### JSon/json_stream_reader.cpp

- `json_stream_reader_error_guard() {`
- `json_stream_reader_error_guard(int *value) : code(value) {`

### Logger/logger.cpp

- `ft_logger::ft_logger(const char *path, size_t max_size, t_log_level level) noexcept : _mutex(ft_nullptr), _thread_safe_enabled(false), _alloc_logging(false), _api_logging(false), _error_code(FT_ERR_SUCCESSS)`
- `ft_logger::thread_guard::thread_guard(const ft_logger *logger) noexcept : _logger(logger), _lock_acquired(false), _status(0)`

### Logger/logger_internal.hpp

- `s_log_sink() : mutex(ft_nullptr), thread_safe_enabled(false), function(ft_nullptr), user_data(ft_nullptr) {`

### Logger/logger_log_add_sink.cpp

- `s_json_sink_field() : key(), value(), has_value(false), value_is_json(false) {`

### Logger/logger_log_context_guard.cpp

- `ft_log_context_guard::ft_log_context_guard(const s_log_field *fields, size_t field_count) noexcept : _pushed_count(0), _active(false), _error_code(FT_ERR_SUCCESSS)`
- `ft_log_context_guard::ft_log_context_guard(ft_log_context_guard &&other) noexcept : _pushed_count(other._pushed_count), _active(other._active), _error_code(other._error_code)`

### Logger/logger_log_health.cpp

- `s_log_remote_health_state() : sink(ft_nullptr), host(), port(0), use_tcp(false), reachable(false), last_check(0), last_error(FT_ERR_INVALID_STATE) {`

### Math/linear_algebra.cpp

- `matrix2::matrix2(const matrix2 &other) : _m(), _operation_errors(`
- `matrix2::matrix2(matrix2 &&other) : _m(), _operation_errors(`
- `matrix3::matrix3(const matrix3 &other) : _m(), _operation_errors(`
- `matrix3::matrix3(matrix3 &&other) : _m(), _operation_errors(`
- `matrix4::matrix4(const matrix4 &other) : _m(), _operation_errors(`
- `matrix4::matrix4(matrix4 &&other) : _m(), _operation_errors(`

### Math/linear_algebra.hpp

- `vector2();`
- `vector2(const vector2 &other);`
- `vector2(double x, double y);`
- `vector2(vector2 &&other);`

### Math/linear_algebra_constructors.cpp

- `matrix2::matrix2()`
- `matrix2::matrix2(double m00, double m01, double m10, double m11)`
- `matrix3::matrix3()`
- `matrix3::matrix3(double m00, double m01, double m02, double m10, double m11, double m12, double m20, double m21, double m22)`
- `matrix4::matrix4()`
- `matrix4::matrix4(double m00, double m01, double m02, double m03, double m10, double m11, double m12, double m13, double m20, double m21, double m22, double m23, double m30, double m31, double m32, double m33)`
- `vector2::vector2(double x, double y)`
- `vector3::vector3()`
- `vector3::vector3(double x, double y, double z)`
- `vector4::vector4()`
- `vector4::vector4(double x, double y, double z, double w)`

### Math/linear_algebra_quaternion.cpp

- `quaternion::quaternion()`
- `quaternion::quaternion(const quaternion &other)`
- `quaternion::quaternion(double w, double x, double y, double z)`
- `quaternion::quaternion(quaternion &&other) noexcept`

### Math/linear_algebra_quaternion.hpp

- `quaternion();`
- `quaternion(const quaternion &other);`
- `quaternion(double w, double x, double y, double z);`
- `quaternion(quaternion &&other) noexcept;`

### Math/linear_algebra_vector2.cpp

- `vector2::vector2(const vector2 &other) : _x(0.0), _y(0.0), _operation_errors(`
- `vector2::vector2(vector2 &&other) : _x(0.0), _y(0.0), _operation_errors(`

### Math/linear_algebra_vector3.cpp

- `vector3::vector3(const vector3 &other) : _x(0.0), _y(0.0), _z(0.0), _mutex()`
- `vector3::vector3(vector3 &&other) : _x(0.0), _y(0.0), _z(0.0), _mutex()`

### Math/linear_algebra_vector4.cpp

- `vector4::vector4(const vector4 &other) : _x(0.0), _y(0.0), _z(0.0), _w(0.0), _operation_errors(`
- `vector4::vector4(vector4 &&other) : _x(0.0), _y(0.0), _z(0.0), _w(0.0), _operation_errors(`

### Math/math_autodiff.cpp

- `ft_dual_number::ft_dual_number() noexcept : _value(0.0) , _derivative(0.0) , _error_code(FT_ERR_SUCCESSS) , _operation_errors(`
- `ft_dual_number::ft_dual_number(const ft_dual_number &other) noexcept : _value(0.0) , _derivative(0.0) , _error_code(FT_ERR_SUCCESSS) , _operation_errors(`
- `ft_dual_number::ft_dual_number(double value, double derivative) noexcept : _value(value) , _derivative(derivative) , _error_code(FT_ERR_SUCCESSS) , _operation_errors(`
- `ft_dual_number::ft_dual_number(ft_dual_number &&other) noexcept : _value(0.0) , _derivative(0.0) , _error_code(FT_ERR_SUCCESSS) , _operation_errors(`

### Math/math_autodiff.hpp

- `ft_dual_number (*math_autodiff_multivariate_function)(const ft_vector<ft_dual_number> &input, void *user_data);`
- `ft_dual_number (*math_autodiff_univariate_function)(const ft_dual_number &input, void *user_data);`
- `ft_dual_number() noexcept;`
- `ft_dual_number(const ft_dual_number &other) noexcept;`
- `ft_dual_number(double value, double derivative) noexcept;`
- `ft_dual_number(ft_dual_number &&other) noexcept;`

### Math/math_polynomial.cpp

- `ft_cubic_spline::ft_cubic_spline() noexcept : _error_code(FT_ERR_SUCCESSS) , _operation_errors(`
- `ft_cubic_spline::ft_cubic_spline(ft_cubic_spline &&other) noexcept : _error_code(FT_ERR_SUCCESSS) , _operation_errors(`

### Math/math_polynomial.hpp

- `ft_cubic_spline() noexcept;`
- `ft_cubic_spline(const ft_cubic_spline &other) = delete;`
- `ft_cubic_spline(ft_cubic_spline &&other) noexcept;`

### Networking/http2_client.cpp

- `http2_frame::http2_frame() noexcept : _type(0), _flags(0), _stream_identifier(0), _payload(), _error_code(FT_ERR_SUCCESSS), _thread_safe_enabled(false), _mutex(ft_nullptr)`
- `http2_frame::http2_frame(const http2_frame &other) noexcept : _type(0), _flags(0), _stream_identifier(0), _payload(), _error_code(FT_ERR_SUCCESSS), _thread_safe_enabled(false), _mutex(ft_nullptr)`
- `http2_frame::http2_frame(http2_frame &&other) noexcept : _type(0), _flags(0), _stream_identifier(0), _payload(), _error_code(FT_ERR_SUCCESSS), _thread_safe_enabled(false), _mutex(ft_nullptr)`
- `http2_header_field::http2_header_field() noexcept : _name(), _value(), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr)`
- `http2_header_field::http2_header_field(const http2_header_field &other) noexcept : _name(), _value(), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr)`
- `http2_header_field::http2_header_field(http2_header_field &&other) noexcept : _name(), _value(), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr)`
- `http2_settings_state::http2_settings_state() noexcept : _header_table_size(4096), _enable_push(true), _max_concurrent_streams(0xFFFFFFFFu), _initial_local_window(65535), _initial_remote_window(65535), _max_frame_size(16384), _max_header_list_size(0), _error_code(FT_ERR_SUCCESSS)`
- `http2_stream_manager::http2_stream_manager() noexcept : _streams(), _stream_identifiers(), _initial_remote_window(65535), _initial_local_window(65535), _connection_remote_window(65535), _connection_local_window(65535), _error_code(FT_ERR_SUCCESSS), _thread_safe_enabled(false), _mutex(ft_nullptr)`
- `http2_stream_state::http2_stream_state() noexcept : buffer(), dependency_identifier(0), weight(16), exclusive_dependency(false), remote_window(65535), local_window(65535)`

### Networking/http2_client.hpp

- `http2_header_field() noexcept;`
- `http2_header_field(const http2_header_field &other) noexcept;`
- `http2_header_field(http2_header_field &&other) noexcept;`

### Networking/http_server.hpp

- `ft_http_server();`

### Networking/networking.cpp

- `SocketConfig::SocketConfig(SocketConfig&& other) noexcept : _error_code(FT_ERR_SUCCESSS), _thread_safe_enabled(false), _mutex(ft_nullptr), _type(SocketType::SERVER), _ip("127.0.0.1"), _port(8080), _backlog(10), _protocol(IPPROTO_TCP), _address_family(AF_INET), _reuse_address(true), _non_blocking(false), _recv_timeout(5000), _send_timeout(5000), _multicast_group(""), _multicast_interface("")`
- `SocketConfig::SocketConfig(const SocketConfig& other) noexcept : _error_code(FT_ERR_SUCCESSS), _thread_safe_enabled(false), _mutex(ft_nullptr), _type(SocketType::SERVER), _ip("127.0.0.1"), _port(8080), _backlog(10), _protocol(IPPROTO_TCP), _address_family(AF_INET), _reuse_address(true), _non_blocking(false), _recv_timeout(5000), _send_timeout(5000), _multicast_group(""), _multicast_interface("")`

### Networking/networking_dns_resolver.cpp

- `networking_dns_cache_entry() noexcept : addresses(), expiration_ms(0) {`
- `networking_dns_cache_entry() noexcept {`
- `networking_dns_cache_entry(const networking_dns_cache_entry&) = delete;`
- `networking_dns_cache_entry(networking_dns_cache_entry&& other) noexcept : addresses(ft_move(other.addresses)), expiration_ms(other.expiration_ms) {`

### Networking/networking_quic_experimental.cpp

- `quic_datagram_plaintext::quic_datagram_plaintext() noexcept`
- `quic_experimental_session::quic_experimental_session() noexcept`
- `quic_feature_configuration::quic_feature_configuration() noexcept`

### Networking/networking_quic_experimental.hpp

- `quic_feature_configuration() noexcept;`

### Networking/networking_socket_class.cpp

- `ft_socket::ft_socket() : _address(), _connected(), _socket_fd(-1), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_socket::ft_socket(const SocketConfig &config) : _address(), _connected(), _socket_fd(-1), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_socket::ft_socket(ft_socket &&other) noexcept : _address(), _connected(), _socket_fd(-1), _error_code(FT_ERR_SUCCESSS), _mutex()`
- `ft_socket::ft_socket(int fd, const sockaddr_storage &addr) : _address(), _connected(), _socket_fd(-1), _error_code(FT_ERR_SUCCESSS), _mutex()`

### Networking/socket_class.hpp

- `ft_socket();`
- `ft_socket(const SocketConfig &config);`
- `ft_socket(const ft_socket &other) = delete;`
- `ft_socket(ft_socket &&other) noexcept;`
- `ft_socket(int fd, const sockaddr_storage &addr);`

### Networking/socket_handle.cpp

- `ft_socket_handle::ft_socket_handle() : _socket_fd(-1), _error_code(FT_ERR_SUCCESSS)`
- `ft_socket_handle::ft_socket_handle(ft_socket_handle &&other) noexcept : _socket_fd(other._socket_fd), _error_code(other._error_code)`
- `ft_socket_handle::ft_socket_handle(int socket_fd) : _socket_fd(-1), _error_code(FT_ERR_SUCCESSS)`

### Networking/socket_handle.hpp

- `ft_socket_handle();`
- `ft_socket_handle(const ft_socket_handle &other) = delete;`
- `ft_socket_handle(ft_socket_handle &&other) noexcept;`
- `ft_socket_handle(int socket_fd);`

### Networking/udp_socket.hpp

- `udp_socket();`

### Networking/websocket_client.cpp

- `ft_websocket_client::ft_websocket_client() : _socket(), _error_code(FT_ERR_SUCCESSS), _mutex()`

### Networking/websocket_client.hpp

- `ft_websocket_client();`

### Networking/websocket_server.cpp

- `ft_websocket_server::ft_websocket_server() : _server_socket(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex()`

### Networking/websocket_server.hpp

- `ft_websocket_server();`

### PThread/condition.hpp

- `pt_condition_variable();`
- `pt_condition_variable(const pt_condition_variable&) = delete;`

### PThread/lock_guard.hpp

- `ft_lock_guard() {`
- `ft_lock_guard();`
- `ft_lock_guard(MutexType &mutex) : _mutex(&mutex), _owns_lock(false), _error_code(FT_ERR_SUCCESSS) {`
- `ft_lock_guard(MutexType &mutex);`
- `ft_lock_guard(const ft_lock_guard &) = delete;`

### PThread/mutex.hpp

- `pt_mutex();`
- `pt_mutex(const pt_mutex&) = delete;`
- `pt_mutex(pt_mutex&&) = delete;`

### PThread/pthread_condition_variable.cpp

- `pt_condition_variable::pt_condition_variable() : _condition(), _mutex(), _condition_initialized(false), _mutex_initialized(false), _error_code(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`

### PThread/pthread_errno_guard.hpp

- `pt_errno_guard() noexcept {`
- `pt_errno_guard() noexcept;`
- `pt_errno_guard(GuardType &first_guard, GuardType &second_guard) noexcept : _first_guard(&first_guard) , _second_guard(&second_guard) , _previous_error(ft_global_error_stack_peek_last_error()) {`
- `pt_errno_guard(GuardType &first_guard, GuardType &second_guard) noexcept;`

### PThread/pthread_lock_tracking.cpp

- `pt_lock_tracking::pt_lock_tracking()`

### PThread/pthread_lock_tracking.hpp

- `pt_system_allocator();`
- `pt_system_allocator(const pt_system_allocator<t_other> &other);`

### PThread/pthread_mutex.cpp

- `pt_mutex::pt_mutex() : _owner(0), _lock(false), _native_initialized(false), _state_mutex(ft_nullptr), _operation_errors(`

### PThread/pthread_recursive_mutex.cpp

- `pt_recursive_mutex::pt_recursive_mutex() : _owner(0), _lock(false), _lock_depth(0), _native_initialized(false), _state_mutex(ft_nullptr)`

### PThread/pthread_task_scheduler.cpp

- `ft_scheduled_task_handle::ft_scheduled_task_handle() : _state(), _scheduler(ft_nullptr), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`
- `ft_scheduled_task_handle::ft_scheduled_task_handle(const ft_scheduled_task_handle &other) : _state(), _scheduler(ft_nullptr), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`
- `ft_scheduled_task_handle::ft_scheduled_task_handle(ft_task_scheduler *scheduler, const ft_sharedptr<ft_scheduled_task_state> &state) : _state(state), _scheduler(scheduler), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`
- `ft_scheduled_task_state::ft_scheduled_task_state() : _cancelled(false), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`
- `ft_task_scheduler::ft_task_scheduler(size_t thread_count) : _queue(), _workers(), _timer_thread(), _scheduled(), _scheduled_mutex(), _scheduled_condition(), _running(true), _queue_metrics_mutex(), _worker_metrics_mutex(), _queue_size_counter(0), _scheduled_size_counter(0), _worker_active_counter(0), _worker_idle_counter(0), _worker_total_count(0), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`

### PThread/pthread_thread.cpp

- `ft_thread::ft_thread() : _thread(), _joinable(false), _error_code(FT_ERR_SUCCESSS), _start_payload(), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`
- `ft_thread::ft_thread(ft_thread &&other) : _thread(), _joinable(false), _error_code(FT_ERR_SUCCESSS), _start_payload(), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`

### PThread/recursive_mutex.hpp

- `pt_recursive_mutex();`
- `pt_recursive_mutex(const pt_recursive_mutex&) = delete;`
- `pt_recursive_mutex(pt_recursive_mutex&&) = delete;`

### PThread/task_scheduler.hpp

- `ft_blocking_queue() : _mutex(), _condition(), _shutdown(false), _storage(), _state_mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_blocking_queue() {`
- `ft_blocking_queue();`
- `ft_blocking_queue(const ft_blocking_queue&) = delete;`

### PThread/thread.hpp

- `ft_thread();`
- `ft_thread(FunctionType function, Args... args) : _thread(), _joinable(false), _error_code(FT_ERR_SUCCESSS), _start_payload(), _state_mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_thread(FunctionType function, Args... args);`
- `ft_thread(const ft_thread &) = delete;`
- `ft_thread(ft_thread &&other);`
- `template <typename FunctionType, typename... Args> ft_thread::ft_thread(FunctionType function, Args... args) : _thread(), _joinable(false), _error_code(FT_ERR_SUCCESSS), _start_payload(), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`

### PThread/unique_lock.hpp

- `ft_unique_lock() : _mutex(ft_nullptr) , _owns_lock(false) {`
- `ft_unique_lock() {`
- `ft_unique_lock();`
- `ft_unique_lock(MutexType &mutex) : _mutex(&mutex) , _owns_lock(false) {`
- `ft_unique_lock(MutexType &mutex);`
- `ft_unique_lock(const ft_unique_lock &) = delete;`
- `ft_unique_lock(ft_unique_lock &&other) : _mutex(ft_nullptr) , _owns_lock(false) {`
- `ft_unique_lock(ft_unique_lock &&other);`

### Parser/document_backend.hpp

- `ft_document_source() noexcept;`
- `ft_document_source();`

### Parser/dom.cpp

- `ft_dom_document::ft_dom_document() noexcept : _root(ft_nullptr), _mutex(ft_nullptr), _thread_safe_enabled(false), _error_code(FT_ERR_SUCCESSS)`
- `ft_dom_document::thread_guard::thread_guard(const ft_dom_document *document) noexcept : _document(document), _lock_acquired(false), _status(0)`
- `ft_dom_node::ft_dom_node() noexcept : _error_code(FT_ERR_SUCCESSS), _type(FT_DOM_NODE_NULL), _name(), _value(), _children(), _attribute_keys(), _attribute_values(), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `ft_dom_schema::ft_dom_schema() noexcept : _rules(), _error_code(FT_ERR_SUCCESSS)`
- `ft_dom_schema_rule::ft_dom_schema_rule() noexcept : path(), type(FT_DOM_NODE_NULL), required(false)`
- `ft_dom_validation_error::ft_dom_validation_error() noexcept : path(), message()`
- `ft_dom_validation_report::ft_dom_validation_report() noexcept : _valid(true), _errors(), _error_code(FT_ERR_SUCCESSS)`

### Parser/dom.hpp

- `ft_dom_node() noexcept;`
- `ft_dom_node(const ft_dom_node &) = delete;`
- `ft_dom_node(ft_dom_node &&) = delete;`

### Parser/parser_document_backend.cpp

- `ft_document_sink::ft_document_sink() noexcept : _error_code(FT_ERR_SUCCESSS)`
- `ft_file_document_sink::ft_file_document_sink(const char *file_path) noexcept : _path()`
- `ft_file_document_source::ft_file_document_source(const char *file_path) noexcept : _path()`
- `ft_http_document_sink::ft_http_document_sink() noexcept : _host(), _path(), _port(), _use_ssl(false)`
- `ft_http_document_sink::ft_http_document_sink(const char *host, const char *path, bool use_ssl, const char *port) noexcept : _host(), _path(), _port(), _use_ssl(use_ssl)`
- `ft_http_document_source::ft_http_document_source() noexcept : _host(), _path(), _port(), _use_ssl(false)`
- `ft_http_document_source::ft_http_document_source(const char *host, const char *path, bool use_ssl, const char *port) noexcept : _host(), _path(), _port(), _use_ssl(use_ssl)`
- `ft_memory_document_sink::ft_memory_document_sink() noexcept : _storage_pointer(ft_nullptr)`
- `ft_memory_document_sink::ft_memory_document_sink(ft_string *storage_pointer) noexcept : _storage_pointer(storage_pointer)`
- `ft_memory_document_source::ft_memory_document_source() noexcept : _data_pointer(ft_nullptr), _data_length(0)`
- `ft_memory_document_source::ft_memory_document_source(const char *data_pointer, size_t data_length) noexcept : _data_pointer(data_pointer), _data_length(data_length)`

### RNG/deck.hpp

- `ft_deck() noexcept : ft_vector<ElementType*>() , _mutex() {`
- `ft_deck() noexcept {`
- `ft_deck() noexcept;`
- `ft_deck(const ft_deck&) = delete;`
- `ft_deck(ft_deck&&) = delete;`

### RNG/loot_table.hpp

- `ft_loot_entry() noexcept : _item(ft_nullptr) , _weight(1) , _rarity(0) , _error_code(FT_ERR_SUCCESSS) , _mutex() {`
- `ft_loot_entry() noexcept {`
- `ft_loot_entry() noexcept;`
- `ft_loot_entry(ElementType *item, int weight, int rarity) noexcept : _item(item) , _weight(1) , _rarity(0) , _error_code(FT_ERR_SUCCESSS) , _mutex() {`
- `ft_loot_entry(ElementType *item, int weight, int rarity) noexcept;`
- `ft_loot_entry(const ft_loot_entry &other) noexcept;`
- `ft_loot_entry(const ft_loot_entry<ElementType> &other) noexcept : _item(ft_nullptr) , _weight(1) , _rarity(0) , _error_code(FT_ERR_SUCCESSS) , _mutex() {`

### RNG/rng_stream.cpp

- `rng_stream::rng_stream(const rng_stream &other)`
- `rng_stream::rng_stream(rng_stream &&other) noexcept`
- `rng_stream::rng_stream(uint32_t seed_value)`

### RNG/rng_stream.hpp

- `rng_stream();`
- `rng_stream(const rng_stream &other);`
- `rng_stream(rng_stream &&other) noexcept;`
- `rng_stream(uint32_t seed_value);`

### Storage/storage_kv_store_constructor.cpp

- `kv_store::kv_store(const char *file_path, const char *encryption_key, bool enable_encryption) : _data() , _file_path() , _encryption_key() , _encryption_enabled(false) , _backend_type(KV_STORE_BACKEND_JSON) , _background_thread_active(false) , _background_stop_requested(false) , _background_interval_seconds(0) , _background_thread() , _background_mutex() , _error_code(FT_ERR_SUCCESSS) , _mutex() , _metrics_set_operations(0) , _metrics_delete_operations(0) , _metrics_get_hits(0) , _metrics_get_misses(0) , _metrics_prune_operations(0) , _metrics_pruned_entries(0) , _metrics_total_prune_duration_ms(0) , _metrics_last_prune_duration_ms(0) , _replication_sinks() , _replication_mutex()`

### Storage/storage_kv_store_entry.cpp

- `kv_store_entry::kv_store_entry() noexcept : _value() , _has_expiration(false) , _expiration_timestamp(0) , _error_code(FT_ERR_SUCCESSS) , _mutex()`
- `kv_store_entry::kv_store_entry(const kv_store_entry &other) noexcept : _value() , _has_expiration(false) , _expiration_timestamp(0) , _error_code(FT_ERR_SUCCESSS) , _mutex()`
- `kv_store_entry::kv_store_entry(kv_store_entry &&other) noexcept : _value() , _has_expiration(false) , _expiration_timestamp(0) , _error_code(FT_ERR_SUCCESSS) , _mutex()`

### Template/bitset.hpp

- `ft_bitset() {`
- `ft_bitset();`
- `ft_bitset(const ft_bitset&) = delete;`
- `ft_bitset(ft_bitset&& other) noexcept : _size(0), _blockCount(0), _data(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_bitset(ft_bitset&& other) noexcept;`
- `ft_bitset(size_t bits = 0);`
- `ft_bitset(size_t bits) : _size(bits), _blockCount((bits + BITS_PER_BLOCK - 1) / BITS_PER_BLOCK), _data(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `inline ft_bitset::ft_bitset(ft_bitset&& other) noexcept : _size(0), _blockCount(0), _data(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`
- `inline ft_bitset::ft_bitset(size_t bits) : _size(bits), _blockCount((bits + BITS_PER_BLOCK - 1) / BITS_PER_BLOCK), _data(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false)`

### Template/cancellation.hpp

- `ft_cancellation_state() noexcept;`
- `ft_cancellation_state(const ft_cancellation_state&) = delete;`
- `ft_cancellation_token() noexcept : _state(), _error_code(FT_ERR_SUCCESSS) {`
- `ft_cancellation_token() noexcept {`
- `ft_cancellation_token() noexcept;`
- `ft_cancellation_token();`
- `ft_cancellation_token(const ft_cancellation_token &other) noexcept : _state(other._state), _error_code(FT_ERR_SUCCESSS) {`
- `ft_cancellation_token(const ft_cancellation_token &other) noexcept;`
- `ft_cancellation_token(ft_cancellation_token &&other) noexcept : _state(ft_move(other._state)), _error_code(FT_ERR_SUCCESSS) {`
- `ft_cancellation_token(ft_cancellation_token &&other) noexcept;`
- `inline ft_cancellation_source::ft_cancellation_source() noexcept : _state(), _error_code(FT_ERR_SUCCESSS)`
- `inline ft_cancellation_source::ft_cancellation_source(const ft_cancellation_source &other) noexcept : _state(other._state), _error_code(FT_ERR_SUCCESSS)`
- `inline ft_cancellation_source::ft_cancellation_source(ft_cancellation_source &&other) noexcept : _state(ft_move(other._state)), _error_code(FT_ERR_SUCCESSS)`
- `inline ft_cancellation_token::ft_cancellation_token() noexcept : _state(), _error_code(FT_ERR_SUCCESSS)`
- `inline ft_cancellation_token::ft_cancellation_token(const ft_cancellation_token &other) noexcept : _state(other._state), _error_code(FT_ERR_SUCCESSS)`
- `inline ft_cancellation_token::ft_cancellation_token(ft_cancellation_token &&other) noexcept : _state(ft_move(other._state)), _error_code(FT_ERR_SUCCESSS)`

### Template/circular_buffer.hpp

- `ft_circular_buffer() {`
- `ft_circular_buffer();`
- `ft_circular_buffer(const ft_circular_buffer&) = delete;`
- `ft_circular_buffer(ft_circular_buffer&& other) noexcept : _buffer(ft_nullptr), _capacity(0), _head(0), _tail(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_circular_buffer(ft_circular_buffer&& other) noexcept;`
- `ft_circular_buffer(size_t capacity) : _buffer(ft_nullptr), _capacity(capacity), _head(0), _tail(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_circular_buffer(size_t capacity);`

### Template/deque.hpp

- `ft_deque() : _front(ft_nullptr), _back(ft_nullptr), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_deque() {`
- `ft_deque();`
- `ft_deque(const ft_deque&) = delete;`
- `ft_deque(ft_deque&& other) noexcept : _front(ft_nullptr), _back(ft_nullptr), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_deque(ft_deque&& other) noexcept;`

### Template/event_emitter.hpp

- `ft_event_emitter() {`
- `ft_event_emitter();`
- `ft_event_emitter(const ft_event_emitter&) = delete;`
- `ft_event_emitter(ft_event_emitter&& other) noexcept : _listeners(ft_nullptr), _capacity(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex() {`
- `ft_event_emitter(ft_event_emitter&& other) noexcept;`
- `ft_event_emitter(size_t initial_capacity = 0);`
- `ft_event_emitter(size_t initial_capacity) : _listeners(ft_nullptr), _capacity(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex() {`

### Template/function.hpp

- `ft_function() : _callable(ft_nullptr), _invoke(ft_nullptr), _destroy(ft_nullptr), _clone(ft_nullptr) {`
- `ft_function() {`
- `ft_function();`
- `ft_function(FunctionType function) : _callable(ft_nullptr), _invoke(ft_nullptr), _destroy(ft_nullptr), _clone(ft_nullptr) {`
- `ft_function(FunctionType function);`
- `ft_function(const ft_function &other) : _callable(ft_nullptr), _invoke(ft_nullptr), _destroy(ft_nullptr), _clone(ft_nullptr) {`
- `ft_function(const ft_function &other);`
- `ft_function(ft_function &&other) noexcept : _callable(other._callable), _invoke(other._invoke), _destroy(other._destroy), _clone(other._clone) {`
- `ft_function(ft_function &&other) noexcept;`

### Template/future.hpp

- `ft_future() : _promise(ft_nullptr), _shared_promise(), _operation_errors({`
- `ft_future() {`
- `ft_future();`
- `ft_future(const ft_future &other);`
- `ft_future(const ft_future<ValueType> &other) : _promise(ft_nullptr), _shared_promise(), _operation_errors({`
- `ft_future(const ft_future<void> &other) : _promise(ft_nullptr), _shared_promise(), _operation_errors({`
- `ft_future(ft_future &&other);`
- `ft_future(ft_future<ValueType> &&other) : _promise(ft_nullptr), _shared_promise(), _operation_errors({`
- `ft_future(ft_future<void> &&other) : _promise(ft_nullptr), _shared_promise(), _operation_errors({`
- `ft_future(ft_promise<ValueType>& promise) : _promise(&promise), _shared_promise(), _operation_errors({`
- `ft_future(ft_promise<ValueType>& promise);`
- `ft_future(ft_promise<void>& promise) : _promise(&promise), _shared_promise(), _operation_errors({`
- `ft_future(ft_promise<void>& promise);`
- `ft_future(ft_sharedptr<ft_promise<ValueType> > promise_pointer) : _promise(promise_pointer.get()), _shared_promise(promise_pointer), _operation_errors({`
- `ft_future(ft_sharedptr<ft_promise<ValueType> > promise_pointer);`
- `ft_future(ft_sharedptr<ft_promise<void> > promise_pointer) : _promise(promise_pointer.get()), _shared_promise(promise_pointer), _operation_errors({`
- `ft_future(ft_sharedptr<ft_promise<void> > promise_pointer);`

### Template/graph.hpp

- `ft_graph() {`
- `ft_graph();`
- `ft_graph(const ft_graph&) = delete;`
- `ft_graph(ft_graph&& other) noexcept : _nodes(ft_nullptr), _capacity(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _operation_errors({`
- `ft_graph(ft_graph&& other) noexcept;`
- `ft_graph(size_t initialCapacity = 0);`
- `ft_graph(size_t initialCapacity) : _nodes(ft_nullptr), _capacity(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _operation_errors({`

### Template/iterator.hpp

- `Iterator() {`
- `Iterator();`
- `Iterator(Iterator&& other) noexcept : _ptr(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `Iterator(Iterator&& other) noexcept;`
- `Iterator(ValueType* ptr) noexcept : _ptr(ptr), _error_code(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `Iterator(ValueType* ptr) noexcept;`
- `Iterator(const Iterator& other) noexcept : _ptr(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `Iterator(const Iterator& other) noexcept;`

### Template/map.hpp

- `ft_map() {`
- `ft_map();`
- `ft_map(const ft_map& other);`
- `ft_map(const ft_map<Key, MappedType>& other) : _data(ft_nullptr), _capacity(0), _size(0), _operation_errors({`
- `ft_map(ft_map&& other) noexcept;`
- `ft_map(ft_map<Key, MappedType>&& other) noexcept : _data(ft_nullptr), _capacity(0), _size(0), _operation_errors({`
- `ft_map(size_t initial_capacity = 10);`
- `ft_map(size_t initial_capacity) : _data(ft_nullptr), _capacity(initial_capacity), _size(0), _operation_errors({`

### Template/matrix.hpp

- `ft_matrix() {`
- `ft_matrix();`
- `ft_matrix(const ft_matrix&) = delete;`
- `ft_matrix(ft_matrix&& other) noexcept : _data(ft_nullptr), _rows(0), _cols(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_matrix(ft_matrix&& other) noexcept;`
- `ft_matrix(size_t rows = 0, size_t cols = 0);`
- `ft_matrix(size_t rows, size_t cols) : _data(ft_nullptr), _rows(0), _cols(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`

### Template/optional.hpp

- `ft_optional() : _value(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex() {`
- `ft_optional() {`
- `ft_optional();`
- `ft_optional(T&& value) : _value(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex() {`
- `ft_optional(T&& value);`
- `ft_optional(const T& value) : _value(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex() {`
- `ft_optional(const T& value);`
- `ft_optional(const ft_optional&) = delete;`
- `ft_optional(ft_optional&& other) noexcept : _value(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex() {`
- `ft_optional(ft_optional&& other) noexcept;`

### Template/pair.hpp

- `Pair() : key(), value() {`
- `Pair() {`
- `Pair();`
- `Pair(Pair &&other) : key(ft_move(other.key)), value(ft_move(other.value)) {`
- `Pair(Pair &&other);`
- `Pair(const KeyType &input_key, ValueType &&input_value) : key(input_key), value(ft_move(input_value)) {`
- `Pair(const KeyType &input_key, ValueType &&input_value);`
- `Pair(const KeyType &input_key, const ValueType &input_value) : key(input_key), value(input_value) {`
- `Pair(const KeyType &input_key, const ValueType &input_value);`
- `Pair(const Pair &other) : key(other.key), value(other.value) {`
- `Pair(const Pair &other);`

### Template/pool.hpp

- `Pool() : _buffer() , _freeIndices() , _error_code(FT_ERR_SUCCESSS) , _state_mutex(ft_nullptr) , _thread_safe_enabled(false) {`
- `Pool() {`
- `Pool();`
- `Pool(Pool&& other) : _buffer() , _freeIndices() , _error_code(FT_ERR_SUCCESSS) , _state_mutex(ft_nullptr) , _thread_safe_enabled(false) {`
- `Pool(Pool&& other);`
- `Pool(const Pool&) = delete;`
- `template<typename T> Pool<T>::Object::Object() noexcept : _pool(ft_nullptr) , _idx(0) , _ptr(ft_nullptr) , _error_code(FT_ERR_SUCCESSS) , _state_mutex(ft_nullptr) , _thread_safe_enabled(false)`
- `template<typename T> Pool<T>::Object::Object(Object&& o) noexcept : _pool(o._pool) , _idx(o._idx) , _ptr(o._ptr) , _error_code(o._error_code) , _state_mutex(o._state_mutex) , _thread_safe_enabled(o._thread_safe_enabled)`
- `template<typename T> Pool<T>::Object::Object(Pool<T>* pool, size_t idx, T* ptr) noexcept : _pool(pool) , _idx(idx) , _ptr(ptr) , _error_code(FT_ERR_SUCCESSS) , _state_mutex(ft_nullptr) , _thread_safe_enabled(false)`

### Template/priority_queue.hpp

- `ft_priority_queue() {`
- `ft_priority_queue();`
- `ft_priority_queue(const ft_priority_queue&) = delete;`
- `ft_priority_queue(ft_priority_queue&& other) noexcept : _data(other._data), _capacity(other._capacity), _size(other._size), _comp(other._comp), _error_code(other._error_code), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_priority_queue(ft_priority_queue&& other) noexcept;`
- `ft_priority_queue(size_t initialCapacity = 0, const Compare& comp = Compare());`
- `ft_priority_queue(size_t initialCapacity, const Compare& comp) : _data(ft_nullptr), _capacity(0), _size(0), _comp(comp), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`

### Template/promise.hpp

- `ft_promise() : _ready(false), _error_code(FT_ERR_SUCCESSS), _thread_safe_enabled(false), _operation_errors({`
- `ft_promise() : _value(), _ready(false), _error_code(FT_ERR_SUCCESSS), _thread_safe_enabled(false), _operation_errors({`
- `ft_promise() {`
- `ft_promise();`
- `ft_promise(const ft_promise&) = delete;`
- `ft_promise(ft_promise&&) = delete;`

### Template/queue.hpp

- `ft_queue() : _front(ft_nullptr), _rear(ft_nullptr), _size(0), _error_code(FT_ERR_SUCCESSS), _operation_errors({`
- `ft_queue() {`
- `ft_queue();`
- `ft_queue(const ft_queue&) = delete;`
- `ft_queue(ft_queue&& other) noexcept : _front(ft_nullptr), _rear(ft_nullptr), _size(0), _error_code(FT_ERR_SUCCESSS), _operation_errors({`
- `ft_queue(ft_queue&& other) noexcept;`

### Template/set.hpp

- `ft_set() {`
- `ft_set();`
- `ft_set(const ft_set&) = delete;`
- `ft_set(ft_set&& other) noexcept : _data(ft_nullptr), _capacity(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_set(ft_set&& other) noexcept;`
- `ft_set(size_t initial_capacity = 0);`
- `ft_set(size_t initial_capacity) : _data(ft_nullptr), _capacity(0), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`

### Template/shared_ptr.hpp

- `ft_sharedptr() : _managedPointer(ft_nullptr), _referenceCount(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr) {`
- `ft_sharedptr() {`
- `ft_sharedptr();`
- `ft_sharedptr(Args&&... args) : _managedPointer(ft_nullptr), _referenceCount(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr) {`
- `ft_sharedptr(Args&&... args) requires (!is_single_convertible_to_size_t<Args...>::value && ft_constructible_from<ManagedType, Args&&...>) : _managedPointer(ft_nullptr), _referenceCount(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr) {`
- `ft_sharedptr(Args&&... args) requires (!is_single_convertible_to_size_t<Args...>::value && ft_constructible_from<ManagedType, Args&&...>);`
- `ft_sharedptr(Args&&... args);`
- `ft_sharedptr(ManagedType* pointer, bool isArray = false, size_t arraySize = 1);`
- `ft_sharedptr(ManagedType* pointer, bool isArray, size_t arraySize) : _managedPointer(pointer), _referenceCount(ft_nullptr), _arraySize(isArray ? arraySize : (pointer ? 1 : 0)), _isArrayType(isArray), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr) {`
- `ft_sharedptr(const ft_sharedptr<ManagedType>& other) : _managedPointer(ft_nullptr), _referenceCount(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr) {`
- `ft_sharedptr(const ft_sharedptr<ManagedType>& other);`
- `ft_sharedptr(const ft_sharedptr<Other>& other) : _managedPointer(ft_nullptr), _referenceCount(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr) {`
- `ft_sharedptr(const ft_sharedptr<Other>& other) requires ft_convertible_to<Other*, ManagedType*> : _managedPointer(ft_nullptr), _referenceCount(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr) {`
- `ft_sharedptr(const ft_sharedptr<Other>& other) requires ft_convertible_to<Other*, ManagedType*>;`
- `ft_sharedptr(const ft_sharedptr<Other>& other);`
- `ft_sharedptr(ft_sharedptr<ManagedType>&& other) noexcept : _managedPointer(ft_nullptr), _referenceCount(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr) {`
- `ft_sharedptr(ft_sharedptr<ManagedType>&& other) noexcept;`
- `ft_sharedptr(ft_sharedptr<Other>&& other) noexcept : _managedPointer(ft_nullptr), _referenceCount(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr) {`
- `ft_sharedptr(ft_sharedptr<Other>&& other) noexcept requires ft_convertible_to<Other*, ManagedType*> : _managedPointer(ft_nullptr), _referenceCount(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr) {`
- `ft_sharedptr(ft_sharedptr<Other>&& other) noexcept requires ft_convertible_to<Other*, ManagedType*>;`
- `ft_sharedptr(ft_sharedptr<Other>&& other) noexcept;`
- `ft_sharedptr(size_t size) : _managedPointer(ft_nullptr), _referenceCount(ft_nullptr), _arraySize(size), _isArrayType(true), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false), _shared_thread_safe_flag(ft_nullptr) {`
- `ft_sharedptr(size_t size);`

### Template/stack.hpp

- `ft_stack() : _top(ft_nullptr), _size(0), _mutex(ft_nullptr), _thread_safe_enabled(false), _operation_errors({`
- `ft_stack() {`
- `ft_stack();`
- `ft_stack(const ft_stack&) = delete;`
- `ft_stack(ft_stack&& other) noexcept : _top(ft_nullptr), _size(0), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_stack(ft_stack&& other) noexcept;`

### Template/string_view.hpp

- `ft_string_view() : _data(ft_nullptr), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex() {`
- `ft_string_view() {`
- `ft_string_view();`
- `ft_string_view(const CharType* string) : _data(string), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex() {`
- `ft_string_view(const CharType* string);`
- `ft_string_view(const CharType* string, size_t size) : _data(string), _size(size), _error_code(FT_ERR_SUCCESSS), _mutex() {`
- `ft_string_view(const CharType* string, size_t size);`
- `ft_string_view(const ft_string_view& other) : _data(ft_nullptr), _size(0), _error_code(FT_ERR_SUCCESSS), _mutex() {`
- `ft_string_view(const ft_string_view& other);`

### Template/thread_pool.hpp

- `ft_thread_pool() {`
- `ft_thread_pool();`
- `ft_thread_pool(const ft_thread_pool&) = delete;`
- `ft_thread_pool(ft_thread_pool&&) = delete;`
- `ft_thread_pool(size_t thread_count = 0, size_t max_tasks = 0);`
- `ft_thread_pool(size_t thread_count, size_t max_tasks) : _workers(), _tasks(), _max_tasks(max_tasks), _stop(false), _active(0), _error_code(FT_ERR_SUCCESSS), _mutex(), _cond(), _mutex_initialized(false), _cond_initialized(false), _external_mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `inline ft_thread_pool::ft_thread_pool(size_t thread_count, size_t max_tasks) : _workers(), _tasks(), _max_tasks(max_tasks), _stop(false), _active(0), _error_code(FT_ERR_SUCCESSS), _mutex(), _cond(), _mutex_initialized(false), _cond_initialized(false), _external_mutex(ft_nullptr), _thread_safe_enabled(false)`

### Template/trie.hpp

- `ft_trie() : _data(ft_nullptr), _children(), _error_code(FT_ERR_SUCCESSS), _last_error(FT_ERR_SUCCESSS), _state_mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_trie() {`
- `ft_trie();`
- `ft_trie(const ft_trie &other) = delete;`
- `ft_trie(ft_trie &&other) = delete;`

### Template/tuple.hpp

- `ft_tuple() : _data(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_tuple() {`
- `ft_tuple();`
- `ft_tuple(Args&&... args) : _data(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_tuple(Args&&... args);`
- `ft_tuple(const ft_tuple&) = delete;`
- `ft_tuple(ft_tuple&& other) noexcept : _data(ft_nullptr), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_tuple(ft_tuple&& other) noexcept;`

### Template/unique_ptr.hpp

- `ft_uniqueptr() : _managedPointer(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_uniqueptr() {`
- `ft_uniqueptr();`
- `ft_uniqueptr(Args&&... args) : _managedPointer(new (std::nothrow) ManagedType(std::forward<Args>(args)...)), _arraySize(1), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_uniqueptr(Args&&... args) requires (!is_single_convertible_to_size_t<Args...>::value && ft_constructible_from<ManagedType, Args&&...>) : _managedPointer(new (std::nothrow) ManagedType(std::forward<Args>(args)...)), _arraySize(1), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_uniqueptr(Args&&... args) requires (!is_single_convertible_to_size_t<Args...>::value && ft_constructible_from<ManagedType, Args&&...>);`
- `ft_uniqueptr(Args&&... args);`
- `ft_uniqueptr(ManagedType* pointer, bool isArray = false, size_t arraySize = 1);`
- `ft_uniqueptr(ManagedType* pointer, bool isArray, size_t arraySize) : _managedPointer(pointer), _arraySize(arraySize), _isArrayType(isArray), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_uniqueptr(const ft_uniqueptr&) = delete;`
- `ft_uniqueptr(ft_uniqueptr&& other) noexcept : _managedPointer(ft_nullptr), _arraySize(0), _isArrayType(false), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_uniqueptr(ft_uniqueptr&& other) noexcept;`
- `ft_uniqueptr(size_t size) : _managedPointer(new (std::nothrow) ManagedType[size]), _arraySize(size), _isArrayType(true), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false) {`
- `ft_uniqueptr(size_t size);`

### Template/unordered_map.hpp

- `ft_pair() : first(), second() {`
- `ft_pair();`
- `ft_pair(const Key& k, const MappedType& m) : first(k), second(m) {`
- `ft_pair(const Key& k, const MappedType& m);`
- `template <typename Key, typename MappedType> ft_unordered_map<Key, MappedType>::const_iterator::const_iterator(const const_iterator& other) : _data(other._data), _occupied(other._occupied), _index(other._index), _capacity(other._capacity), _error_code(other._error_code), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename Key, typename MappedType> ft_unordered_map<Key, MappedType>::const_iterator::const_iterator(const ft_pair<Key, MappedType>* data, const bool* occ, size_t idx, size_t cap) : _data(data), _occupied(occ), _index(idx), _capacity(cap), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename Key, typename MappedType> ft_unordered_map<Key, MappedType>::const_iterator::const_iterator(const_iterator&& other) noexcept : _data(other._data), _occupied(other._occupied), _index(other._index), _capacity(other._capacity), _error_code(other._error_code), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename Key, typename MappedType> ft_unordered_map<Key, MappedType>::iterator::iterator(const iterator& other) : _data(other._data), _occupied(other._occupied), _index(other._index), _capacity(other._capacity), _error_code(other._error_code), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename Key, typename MappedType> ft_unordered_map<Key, MappedType>::iterator::iterator(ft_pair<Key, MappedType>* data, bool* occ, size_t idx, size_t cap) : _data(data), _occupied(occ), _index(idx), _capacity(cap), _error_code(FT_ERR_SUCCESSS), _mutex(ft_nullptr), _thread_safe_enabled(false)`
- `template <typename Key, typename MappedType> ft_unordered_map<Key, MappedType>::iterator::iterator(iterator&& other) noexcept : _data(other._data), _occupied(other._occupied), _index(other._index), _capacity(other._capacity), _error_code(other._error_code), _mutex(ft_nullptr), _thread_safe_enabled(false)`

### Test/Test/test_cma_global_new.cpp

- `alignas(128) aligned_large_type {`

### Test/Test/test_cpp_class_istream_copy_move.cpp

- `ft_test_timed_istream(char fill_character, bool slow) noexcept : ft_istream() , _fill_character(fill_character) , _slow(slow) {`

### Test/Test/test_cpp_class_istream_thread_safety.cpp

- `ft_test_counter_istream(std::size_t total_count, char fill_character) noexcept : ft_istream() , _remaining(total_count) , _fill_character(fill_character) {`

### Test/Test/test_cpp_class_stream_mutex.cpp

- `ft_test_simple_istream(char fill_character) noexcept : ft_istream() , _fill_character(fill_character) {`

### Test/Test/test_networking_quic.cpp

- `quic_test_tls_pair() noexcept {`

### Test/Test/test_pathfinding_thread_safety.cpp

- `path_step_update_args();`

### Test/Test/test_template.cpp

- `vector_destructor_tracker() : _value(0), _error_code(FT_ERR_SUCCESSS) {`
- `vector_destructor_tracker() {`
- `vector_destructor_tracker();`
- `vector_destructor_tracker(1));`
- `vector_destructor_tracker(2));`
- `vector_destructor_tracker(3));`
- `vector_destructor_tracker(const vector_destructor_tracker &other) : _value(other._value), _error_code(FT_ERR_SUCCESSS) {`
- `vector_destructor_tracker(const vector_destructor_tracker &other);`
- `vector_destructor_tracker(int value) : _value(value), _error_code(FT_ERR_SUCCESSS) {`
- `vector_destructor_tracker(int value);`
- `vector_destructor_tracker(vector_destructor_tracker &&other) noexcept : _value(other._value), _error_code(FT_ERR_SUCCESSS) {`
- `vector_destructor_tracker(vector_destructor_tracker &&other) noexcept;`
- `vector_destructor_tracker::vector_destructor_tracker() : _value(0), _error_code(FT_ERR_SUCCESSS)`
- `vector_destructor_tracker::vector_destructor_tracker(const vector_destructor_tracker &other) : _value(other._value), _error_code(FT_ERR_SUCCESSS)`
- `vector_destructor_tracker::vector_destructor_tracker(int value) : _value(value), _error_code(FT_ERR_SUCCESSS)`
- `vector_destructor_tracker::vector_destructor_tracker(vector_destructor_tracker &&other) noexcept : _value(other._value), _error_code(FT_ERR_SUCCESSS)`

### Test/Test/test_template_concepts.cpp

- `shared_ptr_base_type::shared_ptr_base_type() : _marker(0), _error_code(FT_ERR_SUCCESSS)`
- `shared_ptr_base_type::shared_ptr_base_type(const shared_ptr_base_type &other) : _marker(other._marker), _error_code(other._error_code)`
- `shared_ptr_base_type::shared_ptr_base_type(int marker) : _marker(marker), _error_code(FT_ERR_SUCCESSS)`
- `shared_ptr_derived_type::shared_ptr_derived_type() : shared_ptr_base_type(), _error_code(FT_ERR_SUCCESSS)`
- `shared_ptr_derived_type::shared_ptr_derived_type(const shared_ptr_derived_type &other) : shared_ptr_base_type(other), _error_code(other._error_code)`
- `shared_ptr_derived_type::shared_ptr_derived_type(int marker) : shared_ptr_base_type(marker), _error_code(FT_ERR_SUCCESSS)`
- `variadic_constructible() : _first(0), _second(0.0), _error_code(FT_ERR_SUCCESSS) {`
- `variadic_constructible() {`
- `variadic_constructible();`
- `variadic_constructible(const variadic_constructible &other) : _first(other._first), _second(other._second), _error_code(other._error_code) {`
- `variadic_constructible(const variadic_constructible &other);`
- `variadic_constructible(int first, double second) : _first(first), _second(second), _error_code(FT_ERR_SUCCESSS) {`
- `variadic_constructible(int first, double second);`
- `variadic_constructible::variadic_constructible() : _first(0), _second(0.0), _error_code(FT_ERR_SUCCESSS)`
- `variadic_constructible::variadic_constructible(const variadic_constructible &other) : _first(other._first), _second(other._second), _error_code(other._error_code)`
- `variadic_constructible::variadic_constructible(int first, double second) : _first(first), _second(second), _error_code(FT_ERR_SUCCESSS)`

### Test/Test/test_template_function_copy_move.cpp

- `counter_callable(0));`
- `counter_callable(5));`
- `counter_callable(9));`
- `counter_callable(const counter_callable &other) : _value(other._value) {`
- `counter_callable(int initial_value) : _value(initial_value) {`

### Test/Test/test_template_optional.cpp

- `no_default_optional_value() {`
- `no_default_optional_value();`
- `no_default_optional_value(42));`
- `no_default_optional_value(64));`
- `no_default_optional_value(const no_default_optional_value &other) : _value(other._value), _error_code(other._error_code) {`
- `no_default_optional_value(const no_default_optional_value &other);`
- `no_default_optional_value(int value) : _value(value), _error_code(FT_ERR_SUCCESSS) {`
- `no_default_optional_value(int value);`
- `no_default_optional_value::no_default_optional_value(const no_default_optional_value &other) : _value(other._value), _error_code(other._error_code)`
- `no_default_optional_value::no_default_optional_value(int value) : _value(value), _error_code(FT_ERR_SUCCESSS)`

### Time/fps.hpp

- `time_fps();`
- `time_fps(long frames_per_second);`

### Time/timer.hpp

- `time_timer() noexcept;`

### XML/xml.hpp

- `xml_node() noexcept;`
- `xml_node(const xml_node &other) noexcept = delete;`
- `xml_node(xml_node &&other) noexcept = delete;`

### XML/xml_document.cpp

- `xml_document::thread_guard::thread_guard(const xml_document *document) noexcept : _document(document), _lock_acquired(false), _status(0)`
- `xml_document::xml_document() noexcept : _root(ft_nullptr), _mutex(ft_nullptr), _thread_safe_enabled(false), _error_code(FT_ERR_SUCCESSS)`
- `xml_namespace_entry();`
- `xml_node::xml_node() noexcept : mutex(ft_nullptr), thread_safe_enabled(false), name(ft_nullptr), namespace_prefix(ft_nullptr), local_name(ft_nullptr), namespace_uri(ft_nullptr), namespace_bindings(ft_nullptr), text(ft_nullptr), children(), attributes()`

### YAML/yaml.hpp

- `yaml_value() noexcept;`
- `yaml_value(const yaml_value &) = delete;`
- `yaml_value(yaml_value &&) = delete;`

### YAML/yaml_value.cpp

- `yaml_value::thread_guard::thread_guard(const yaml_value *value) noexcept : _value(value), _lock_acquired(false), _status(0)`
- `yaml_value::yaml_value() noexcept`

## Destructors

### API/api_connection_pool_handle.cpp

- `api_connection_pool_handle::~api_connection_pool_handle()`
- `api_connection_pool_handle_lock_guard::~api_connection_pool_handle_lock_guard()`

### API/api_retry_policy.cpp

- `api_retry_policy::~api_retry_policy()`

### API/api_streaming_handler.cpp

- `api_streaming_handler::~api_streaming_handler()`

### API/api_tls_client.cpp

- `api_tls_client::~api_tls_client()`

### CMA/cma_alloc_limit_guard.cpp

- `cma_alloc_limit_guard::~cma_alloc_limit_guard()`

### CMA/cma_allocation_guard.cpp

- `cma_allocation_guard::~cma_allocation_guard()`

### CMA/cma_allocator_guard.cpp

- `cma_allocator_guard::~cma_allocator_guard()`

### CPP_class/cpp_class_big_number.cpp

- `ft_big_number::~ft_big_number() noexcept`

### CPP_class/cpp_class_data_buffer.cpp

- `DataBuffer::~DataBuffer() noexcept`

### CPP_class/cpp_class_fd_istream.cpp

- `ft_fd_istream::~ft_fd_istream() noexcept`

### CPP_class/cpp_class_file.cpp

- `ft_file::~ft_file() noexcept`

### CPP_class/cpp_class_istream.cpp

- `ft_istream::~ft_istream() noexcept`

### CPP_class/cpp_class_istringstream.cpp

- `ft_istringstream::~ft_istringstream() noexcept`

### CPP_class/cpp_class_nullptr.cpp

- `ft_nullptr_t::~ft_nullptr_t() noexcept`

### CPP_class/cpp_class_ofstream.cpp

- `ft_ofstream::~ft_ofstream() noexcept`

### CPP_class/cpp_class_string_constructors.cpp

- `ft_string::~ft_string()`

### CPP_class/cpp_class_string_methods.cpp

- `ft_string::mutex_guard::~mutex_guard()`

### CPP_class/cpp_class_stringbuf.cpp

- `ft_stringbuf::~ft_stringbuf() noexcept`

### Compression/compression_stream.cpp

- `t_compress_stream_options::~t_compress_stream_options(void)`

### Config/config_flag_parser.cpp

- `cnfg_flag_parser::~cnfg_flag_parser()`

### DUMB/dumb_render.cpp

- `ft_render_window::~ft_render_window(void)`

### DUMB/dumb_sound.cpp

- `ft_sound_device::~ft_sound_device(void)`

### DUMB/dumb_sound_clip.cpp

- `ft_sound_clip::~ft_sound_clip(void)`

### Encryption/encryption_aead.cpp

- `encryption_aead_context::~encryption_aead_context()`

### Errno/errno_code.cpp

- `ft_errno_mutex_wrapper::~ft_errno_mutex_wrapper(void)`

### File/file_watch.cpp

- `ft_file_watch::~ft_file_watch()`

### Game/game_achievement.cpp

- `ft_achievement::~ft_achievement() noexcept`
- `ft_goal::~ft_goal() noexcept`

### Game/game_behavior_table.cpp

- `ft_behavior_table::~ft_behavior_table() noexcept`

### Game/game_behavior_tree.cpp

- `ft_behavior_action::~ft_behavior_action() noexcept`
- `ft_behavior_composite::~ft_behavior_composite() noexcept`
- `ft_behavior_context::~ft_behavior_context() noexcept`
- `ft_behavior_node::~ft_behavior_node() noexcept`
- `ft_behavior_selector::~ft_behavior_selector() noexcept`
- `ft_behavior_sequence::~ft_behavior_sequence() noexcept`
- `ft_behavior_tree::~ft_behavior_tree() noexcept`

### Game/game_character_constructor.cpp

- `ft_character::~ft_character() noexcept`

### Game/game_data_catalog.cpp

- `ft_data_catalog::~ft_data_catalog() noexcept`

### Game/game_dialogue_line.cpp

- `ft_dialogue_line::~ft_dialogue_line() noexcept`

### Game/game_dialogue_script.cpp

- `ft_dialogue_script::~ft_dialogue_script() noexcept`

### Game/game_dialogue_table.cpp

- `ft_dialogue_table::~ft_dialogue_table() noexcept`

### Game/game_economy_table.cpp

- `ft_economy_table::~ft_economy_table() noexcept`

### Game/game_event.cpp

- `ft_event::~ft_event() noexcept`

### Game/game_event_scheduler.cpp

- `ft_event_scheduler::~ft_event_scheduler()`

### Game/game_experience_table.cpp

- `ft_experience_table::~ft_experience_table()`

### Game/game_hooks.cpp

- `ft_game_hooks::~ft_game_hooks() noexcept`

### Game/game_map3d.cpp

- `ft_map3d::~ft_map3d()`

### Game/game_pathfinding.cpp

- `ft_path_step::~ft_path_step() noexcept`
- `ft_pathfinding::~ft_pathfinding()`

### Game/game_progress_tracker.cpp

- `ft_progress_tracker::~ft_progress_tracker() noexcept`

### Game/game_quest.cpp

- `ft_quest::~ft_quest() noexcept`

### Game/game_region_definition.cpp

- `ft_region_definition::~ft_region_definition() noexcept`

### Game/game_resistance.cpp

- `ft_resistance::~ft_resistance() noexcept`

### Game/game_scripting_bridge.cpp

- `ft_game_script_bridge::~ft_game_script_bridge() noexcept`
- `ft_game_script_context::~ft_game_script_context() noexcept`

### Game/game_server.cpp

- `ft_game_server::~ft_game_server()`

### Game/game_skill.cpp

- `ft_skill::~ft_skill() noexcept`

### Game/game_state.cpp

- `ft_game_state::~ft_game_state() noexcept`

### Game/game_upgrade.cpp

- `ft_upgrade::~ft_upgrade() noexcept`

### Game/game_world_region.cpp

- `ft_world_region::~ft_world_region() noexcept`

### Game/game_world_registry.cpp

- `ft_world_registry::~ft_world_registry() noexcept`

### Game/game_world_replay.cpp

- `ft_world_replay_session::~ft_world_replay_session() noexcept`

### Geometry/geometry_aabb.cpp

- `aabb::~aabb()`

### Geometry/geometry_circle.cpp

- `circle::~circle()`

### Geometry/geometry_sphere.cpp

- `sphere::~sphere()`

### GetNextLine/gnl_stream.cpp

- `gnl_stream::~gnl_stream() noexcept`

### HTML/html_document.cpp

- `html_document::thread_guard::~thread_guard() noexcept`
- `html_document::~html_document() noexcept`

### JSon/json_document.cpp

- `json_document::~json_document() noexcept`

### Logger/logger.cpp

- `ft_logger::thread_guard::~thread_guard() noexcept`
- `ft_logger::~ft_logger() noexcept`

### Logger/logger_log_context_guard.cpp

- `ft_log_context_guard::~ft_log_context_guard() noexcept`

### Math/linear_algebra_constructors.cpp

- `matrix2::~matrix2()`
- `matrix3::~matrix3()`
- `matrix4::~matrix4()`
- `vector2::~vector2()`
- `vector3::~vector3()`
- `vector4::~vector4()`

### Math/linear_algebra_quaternion.cpp

- `quaternion::~quaternion()`

### Math/math_autodiff.cpp

- `ft_dual_number::~ft_dual_number() noexcept`

### Math/math_polynomial.cpp

- `ft_cubic_spline::~ft_cubic_spline() noexcept`

### Networking/http2_client.cpp

- `http2_frame::~http2_frame() noexcept`
- `http2_header_field::~http2_header_field() noexcept`
- `http2_settings_state::~http2_settings_state() noexcept`
- `http2_stream_manager::~http2_stream_manager() noexcept`
- `http2_stream_state::~http2_stream_state() noexcept`

### Networking/http_server.cpp

- `ft_http_server::~ft_http_server()`

### Networking/networking.cpp

- `SocketConfig::~SocketConfig()`

### Networking/networking_quic_experimental.cpp

- `quic_datagram_plaintext::~quic_datagram_plaintext() noexcept`
- `quic_experimental_session::~quic_experimental_session() noexcept`
- `quic_feature_configuration::~quic_feature_configuration() noexcept`

### Networking/networking_setup_udp.cpp

- `udp_socket::~udp_socket()`

### Networking/networking_socket_class.cpp

- `ft_socket::~ft_socket()`

### Networking/socket_handle.cpp

- `ft_socket_handle::~ft_socket_handle()`

### Networking/websocket_client.cpp

- `ft_websocket_client::~ft_websocket_client()`

### Networking/websocket_server.cpp

- `ft_websocket_server::~ft_websocket_server()`

### PThread/pthread_condition_variable.cpp

- `pt_condition_variable::~pt_condition_variable()`

### PThread/pthread_lock_tracking.cpp

- `pt_lock_tracking::~pt_lock_tracking()`

### PThread/pthread_mutex.cpp

- `pt_mutex::~pt_mutex()`

### PThread/pthread_recursive_mutex.cpp

- `pt_recursive_mutex::~pt_recursive_mutex()`

### PThread/pthread_task_scheduler.cpp

- `ft_scheduled_task_handle::~ft_scheduled_task_handle()`
- `ft_scheduled_task_state::~ft_scheduled_task_state()`
- `ft_task_scheduler::~ft_task_scheduler()`

### PThread/pthread_thread.cpp

- `ft_thread::start_payload::~start_payload()`
- `ft_thread::~ft_thread()`

### Parser/dom.cpp

- `ft_dom_document::thread_guard::~thread_guard() noexcept`
- `ft_dom_document::~ft_dom_document() noexcept`
- `ft_dom_node::thread_guard::~thread_guard() noexcept`
- `ft_dom_node::~ft_dom_node() noexcept`
- `ft_dom_schema::~ft_dom_schema() noexcept`
- `ft_dom_schema_rule::~ft_dom_schema_rule() noexcept`
- `ft_dom_validation_error::~ft_dom_validation_error() noexcept`
- `ft_dom_validation_report::~ft_dom_validation_report() noexcept`

### Parser/parser_document_backend.cpp

- `ft_document_sink::~ft_document_sink()`
- `ft_document_source::~ft_document_source()`
- `ft_file_document_sink::~ft_file_document_sink()`
- `ft_file_document_source::~ft_file_document_source()`
- `ft_http_document_sink::~ft_http_document_sink()`
- `ft_http_document_source::~ft_http_document_source()`
- `ft_memory_document_sink::~ft_memory_document_sink()`
- `ft_memory_document_source::~ft_memory_document_source()`

### RNG/rng_stream.cpp

- `rng_stream::~rng_stream()`

### ReadLine/readline_state.cpp

- `s_readline_state::~s_readline_state(void)`

### Storage/storage_kv_store_constructor.cpp

- `kv_store::~kv_store()`

### Storage/storage_kv_store_entry.cpp

- `kv_store_entry::~kv_store_entry() noexcept`

### Template/bitset.hpp

- `inline ft_bitset::~ft_bitset()`

### Template/cancellation.hpp

- `inline ft_cancellation_source::~ft_cancellation_source() noexcept`
- `inline ft_cancellation_token::~ft_cancellation_token() noexcept`

### Template/pool.hpp

- `template<typename T> Pool<T>::Object::~Object() noexcept`

### Template/thread_pool.hpp

- `inline ft_thread_pool::~ft_thread_pool()`

### Template/unordered_map.hpp

- `template <typename Key, typename MappedType> ft_unordered_map<Key, MappedType>::const_iterator::~const_iterator()`
- `template <typename Key, typename MappedType> ft_unordered_map<Key, MappedType>::iterator::~iterator()`

### Test/Test/test_template.cpp

- `vector_destructor_tracker::~vector_destructor_tracker()`

### Test/Test/test_template_concepts.cpp

- `shared_ptr_base_type::~shared_ptr_base_type()`
- `shared_ptr_derived_type::~shared_ptr_derived_type()`
- `variadic_constructible::~variadic_constructible()`

### Test/Test/test_template_optional.cpp

- `no_default_optional_value::~no_default_optional_value()`

### Time/time_fps.cpp

- `time_fps::~time_fps()`

### Time/time_timer.cpp

- `time_timer::~time_timer() noexcept`

### XML/xml_document.cpp

- `xml_document::thread_guard::~thread_guard() noexcept`
- `xml_document::~xml_document() noexcept`
- `xml_node::~xml_node() noexcept`

### YAML/yaml_value.cpp

- `yaml_value::thread_guard::~thread_guard() noexcept`
- `yaml_value::~yaml_value() noexcept`

## Operator Overloads

### API/api_connection_pool.cpp

- `static void *operator new(size_t size) noexcept`
- `static void *operator new(size_t size, const std::nothrow_t&) noexcept`
- `static void operator delete(void *pointer) noexcept`
- `static void operator delete(void *pointer, const std::nothrow_t&) noexcept`

### API/api_connection_pool_handle.cpp

- `api_connection_pool_handle &api_connection_pool_handle::operator=( api_connection_pool_handle &&other)`

### API/api_retry_policy.cpp

- `api_retry_policy &api_retry_policy::operator=( const api_retry_policy &other) noexcept`
- `api_retry_policy &api_retry_policy::operator=(api_retry_policy &&other) noexcept`

### API/api_streaming_handler.cpp

- `api_streaming_handler &api_streaming_handler::operator=( api_streaming_handler &&other) noexcept`
- `api_streaming_handler &api_streaming_handler::operator=( const api_streaming_handler &other) noexcept`

### CMA/cma_alloc_limit_guard.cpp

- `cma_alloc_limit_guard &cma_alloc_limit_guard::operator=(cma_alloc_limit_guard &&other) noexcept`

### CMA/cma_allocation_guard.cpp

- `cma_allocation_guard &cma_allocation_guard::operator=(cma_allocation_guard &&other) noexcept`

### CMA/cma_global_overloads.cpp

- `void operator delete(void* ptr) noexcept`
- `void operator delete(void* ptr, const std::nothrow_t&) noexcept`
- `void operator delete(void* ptr, std::align_val_t) noexcept`
- `void operator delete(void* ptr, std::align_val_t, const std::nothrow_t&) noexcept`
- `void operator delete(void* ptr, std::size_t) noexcept`
- `void operator delete(void* ptr, std::size_t, std::align_val_t) noexcept`
- `void operator delete[](void* ptr) noexcept`
- `void operator delete[](void* ptr, const std::nothrow_t&) noexcept`
- `void operator delete[](void* ptr, std::align_val_t) noexcept`
- `void operator delete[](void* ptr, std::align_val_t, const std::nothrow_t&) noexcept`
- `void operator delete[](void* ptr, std::size_t) noexcept`
- `void operator delete[](void* ptr, std::size_t, std::align_val_t) noexcept`
- `void* operator new(std::size_t size)`
- `void* operator new(std::size_t size, const std::nothrow_t&) noexcept`
- `void* operator new(std::size_t size, std::align_val_t alignment)`
- `void* operator new(std::size_t size, std::align_val_t alignment, const std::nothrow_t&) noexcept`
- `void* operator new[](std::size_t size)`
- `void* operator new[](std::size_t size, const std::nothrow_t&) noexcept`
- `void* operator new[](std::size_t size, std::align_val_t alignment)`
- `void* operator new[](std::size_t size, std::align_val_t alignment, const std::nothrow_t&) noexcept`

### CPP_class/class_data_buffer.hpp

- `DataBuffer& operator<<(size_t len);`
- `DataBuffer& operator>>(size_t& len);`
- `explicit operator bool() const noexcept;`
- `template<typename T> DataBuffer& DataBuffer::operator<<(const T& value)`
- `template<typename T> DataBuffer& DataBuffer::operator>>(T& value)`
- `template<typename T> DataBuffer& operator<<(const T& value);`
- `template<typename T> DataBuffer& operator>>(T& value);`

### CPP_class/class_file.hpp

- `operator int() const;`

### CPP_class/class_istringstream.hpp

- `ft_istringstream &operator>>(ft_istringstream &input, ft_string &value);`
- `ft_istringstream &operator>>(ft_istringstream &input, int &value);`

### CPP_class/class_nullptr.hpp

- `private: void operator&() const;`
- `template <typename ClassType, typename MemberType> inline ft_nullptr_t::operator MemberType ClassType::*() const noexcept`
- `template <typename ClassType, typename MemberType> operator MemberType ClassType::*() const noexcept;`
- `template <typename PointerType> operator PointerType*() const noexcept;`

### CPP_class/class_string.hpp

- `bool operator<(const char* left_value, const ft_string &right_value) noexcept;`
- `bool operator<(const ft_string &left_value, const char* right_value) noexcept;`
- `bool operator<(const ft_string &left_value, const ft_string &right_value) noexcept;`
- `bool operator>(const char* left_value, const ft_string &right_value) noexcept;`
- `bool operator>(const ft_string &left_value, const char* right_value) noexcept;`
- `bool operator>(const ft_string &left_value, const ft_string &right_value) noexcept;`
- `friend ft_string operator+(char left_character, const ft_string &right_value) noexcept;`
- `friend ft_string operator+(const char *left_value, const ft_string &right_value) noexcept;`
- `friend ft_string operator+(const ft_string &left_value, char right_character) noexcept;`
- `friend ft_string operator+(const ft_string &left_value, const char *right_value) noexcept;`
- `friend ft_string operator+(const ft_string &left_value, const ft_string &right_value) noexcept;`
- `operator const char*() const noexcept;`
- `static void operator delete(void* pointer) noexcept;`
- `static void operator delete[](void* pointer) noexcept;`
- `static void* operator new(size_t size) noexcept;`
- `static void* operator new[](size_t size) noexcept;`

### CPP_class/cpp_class_big_number.cpp

- `bool ft_big_number::operator!=(const ft_big_number& other) const noexcept`
- `bool ft_big_number::operator<(const ft_big_number& other) const noexcept`
- `bool ft_big_number::operator<=(const ft_big_number& other) const noexcept`
- `bool ft_big_number::operator==(const ft_big_number& other) const noexcept`
- `bool ft_big_number::operator>(const ft_big_number& other) const noexcept`
- `bool ft_big_number::operator>=(const ft_big_number& other) const noexcept`
- `ft_big_number ft_big_number::operator%(const ft_big_number& other) const noexcept`
- `ft_big_number ft_big_number::operator*(const ft_big_number& other) const noexcept`
- `ft_big_number ft_big_number::operator+(const ft_big_number& other) const noexcept`
- `ft_big_number ft_big_number::operator-(const ft_big_number& other) const noexcept`
- `ft_big_number ft_big_number::operator/(const ft_big_number& other) const noexcept`
- `ft_big_number& ft_big_number::operator=(const ft_big_number& other) noexcept`
- `ft_big_number& ft_big_number::operator=(ft_big_number&& other) noexcept`

### CPP_class/cpp_class_data_buffer.cpp

- `DataBuffer &DataBuffer::operator<<(size_t len)`
- `DataBuffer &DataBuffer::operator=(DataBuffer &&other) noexcept`
- `DataBuffer &DataBuffer::operator=(const DataBuffer &other) noexcept`
- `DataBuffer &DataBuffer::operator>>(size_t &len)`
- `DataBuffer::operator bool() const noexcept`

### CPP_class/cpp_class_fd_istream.cpp

- `ft_fd_istream &ft_fd_istream::operator=(const ft_fd_istream &other) noexcept`
- `ft_fd_istream &ft_fd_istream::operator=(ft_fd_istream &&other) noexcept`

### CPP_class/cpp_class_file.cpp

- `ft_file& ft_file::operator=(ft_file&& other) noexcept`
- `ft_file::operator int() const`

### CPP_class/cpp_class_istream.cpp

- `ft_istream &ft_istream::operator=(const ft_istream &other) noexcept`
- `ft_istream &ft_istream::operator=(ft_istream &&other) noexcept`

### CPP_class/cpp_class_istringstream.cpp

- `ft_istringstream &operator>>(ft_istringstream &input, ft_string &value)`
- `ft_istringstream &operator>>(ft_istringstream &input, int &value)`

### CPP_class/cpp_class_nullptr.cpp

- `ft_nullptr_t &ft_nullptr_t::operator=(const ft_nullptr_t &other) noexcept`
- `void ft_nullptr_t::operator&() const`

### CPP_class/cpp_class_string_constructors.cpp

- `ft_string& ft_string::operator=(const char* other) noexcept`
- `ft_string& ft_string::operator=(const ft_string& other) noexcept`
- `ft_string& ft_string::operator=(ft_string&& other) noexcept`
- `void *ft_string::operator new(size_t size) noexcept`
- `void *ft_string::operator new[](size_t size) noexcept`
- `void ft_string::operator delete(void* pointer) noexcept`
- `void ft_string::operator delete[](void* pointer) noexcept`

### CPP_class/cpp_class_string_methods.cpp

- `bool operator<(const char* left_value, const ft_string &right_value) noexcept`
- `bool operator<(const ft_string &left_value, const char* right_value) noexcept`
- `bool operator<(const ft_string &left_value, const ft_string &right_value) noexcept`
- `bool operator>(const char* left_value, const ft_string &right_value) noexcept`
- `bool operator>(const ft_string &left_value, const char* right_value) noexcept`
- `bool operator>(const ft_string &left_value, const ft_string &right_value) noexcept`
- `ft_string operator+(char left_character, const ft_string &right_value) noexcept`
- `ft_string operator+(const char *left_value, const ft_string &right_value) noexcept`
- `ft_string operator+(const ft_string &left_value, char right_character) noexcept`
- `ft_string operator+(const ft_string &left_value, const char *right_value) noexcept`
- `ft_string operator+(const ft_string &left_value, const ft_string &right_value) noexcept`
- `ft_string& ft_string::operator+=(char character) noexcept`
- `ft_string& ft_string::operator+=(const char* string_value) noexcept`
- `ft_string& ft_string::operator+=(const ft_string& other) noexcept`
- `ft_string::mutex_guard &ft_string::mutex_guard::operator=(mutex_guard &&other) noexcept`
- `ft_string::operator const char*() const noexcept`

### CPP_class/cpp_class_stringbuf.cpp

- `ft_stringbuf &ft_stringbuf::operator=(const ft_stringbuf &other) noexcept`
- `ft_stringbuf &ft_stringbuf::operator=(ft_stringbuf &&other) noexcept`

### Encryption/encryption_aead.cpp

- `encryption_aead_context &encryption_aead_context::operator=(encryption_aead_context &&other) noexcept`

### Game/game_achievement.cpp

- `ft_achievement &ft_achievement::operator=(const ft_achievement &other) noexcept`
- `ft_achievement &ft_achievement::operator=(ft_achievement &&other) noexcept`
- `ft_goal &ft_goal::operator=(const ft_goal &other) noexcept`
- `ft_goal &ft_goal::operator=(ft_goal &&other) noexcept`

### Game/game_behavior_action.cpp

- `ft_behavior_action &ft_behavior_action::operator=(const ft_behavior_action &other) noexcept`
- `ft_behavior_action &ft_behavior_action::operator=(ft_behavior_action &&other) noexcept`

### Game/game_behavior_profile.cpp

- `ft_behavior_profile &ft_behavior_profile::operator=(const ft_behavior_profile &other) noexcept`
- `ft_behavior_profile &ft_behavior_profile::operator=(ft_behavior_profile &&other) noexcept`

### Game/game_behavior_table.cpp

- `ft_behavior_table &ft_behavior_table::operator=(const ft_behavior_table &other) noexcept`
- `ft_behavior_table &ft_behavior_table::operator=(ft_behavior_table &&other) noexcept`

### Game/game_behavior_tree.cpp

- `ft_behavior_action &ft_behavior_action::operator=(const ft_behavior_action &other) noexcept`
- `ft_behavior_composite &ft_behavior_composite::operator=(const ft_behavior_composite &other) noexcept`
- `ft_behavior_context &ft_behavior_context::operator=(const ft_behavior_context &other) noexcept`
- `ft_behavior_node &ft_behavior_node::operator=(const ft_behavior_node &other) noexcept`
- `ft_behavior_selector &ft_behavior_selector::operator=(const ft_behavior_selector &other) noexcept`
- `ft_behavior_sequence &ft_behavior_sequence::operator=(const ft_behavior_sequence &other) noexcept`
- `ft_behavior_tree &ft_behavior_tree::operator=(const ft_behavior_tree &other) noexcept`

### Game/game_buff.cpp

- `ft_buff &ft_buff::operator=(const ft_buff &other) noexcept`
- `ft_buff &ft_buff::operator=(ft_buff &&other) noexcept`

### Game/game_character_constructor.cpp

- `ft_character &ft_character::operator=(const ft_character &other) noexcept`
- `ft_character &ft_character::operator=(ft_character &&other) noexcept`

### Game/game_crafting.cpp

- `ft_crafting &ft_crafting::operator=(const ft_crafting &other) noexcept`
- `ft_crafting &ft_crafting::operator=(ft_crafting &&other) noexcept`
- `ft_crafting_ingredient &ft_crafting_ingredient::operator=(const ft_crafting_ingredient &other) noexcept`
- `ft_crafting_ingredient &ft_crafting_ingredient::operator=(ft_crafting_ingredient &&other) noexcept`

### Game/game_currency_rate.cpp

- `ft_currency_rate &ft_currency_rate::operator=(const ft_currency_rate &other) noexcept`
- `ft_currency_rate &ft_currency_rate::operator=(ft_currency_rate &&other) noexcept`

### Game/game_data_catalog.cpp

- `ft_data_catalog &ft_data_catalog::operator=(const ft_data_catalog &other) noexcept`
- `ft_data_catalog &ft_data_catalog::operator=(ft_data_catalog &&other) noexcept`
- `ft_item_definition &ft_item_definition::operator=(const ft_item_definition &other) noexcept`
- `ft_item_definition &ft_item_definition::operator=(ft_item_definition &&other) noexcept`
- `ft_loadout_blueprint &ft_loadout_blueprint::operator=(const ft_loadout_blueprint &other) noexcept`
- `ft_loadout_blueprint &ft_loadout_blueprint::operator=(ft_loadout_blueprint &&other) noexcept`
- `ft_loadout_entry &ft_loadout_entry::operator=(const ft_loadout_entry &other) noexcept`
- `ft_loadout_entry &ft_loadout_entry::operator=(ft_loadout_entry &&other) noexcept`
- `ft_recipe_blueprint &ft_recipe_blueprint::operator=(const ft_recipe_blueprint &other) noexcept`
- `ft_recipe_blueprint &ft_recipe_blueprint::operator=(ft_recipe_blueprint &&other) noexcept`

### Game/game_debuff.cpp

- `ft_debuff &ft_debuff::operator=(const ft_debuff &other) noexcept`
- `ft_debuff &ft_debuff::operator=(ft_debuff &&other) noexcept`

### Game/game_dialogue_line.cpp

- `ft_dialogue_line &ft_dialogue_line::operator=(const ft_dialogue_line &other) noexcept`
- `ft_dialogue_line &ft_dialogue_line::operator=(ft_dialogue_line &&other) noexcept`

### Game/game_dialogue_script.cpp

- `ft_dialogue_script &ft_dialogue_script::operator=(const ft_dialogue_script &other) noexcept`
- `ft_dialogue_script &ft_dialogue_script::operator=(ft_dialogue_script &&other) noexcept`

### Game/game_dialogue_table.cpp

- `ft_dialogue_table &ft_dialogue_table::operator=(const ft_dialogue_table &other) noexcept`
- `ft_dialogue_table &ft_dialogue_table::operator=(ft_dialogue_table &&other) noexcept`

### Game/game_economy_table.cpp

- `ft_economy_table &ft_economy_table::operator=(const ft_economy_table &other) noexcept`
- `ft_economy_table &ft_economy_table::operator=(ft_economy_table &&other) noexcept`

### Game/game_equipment.cpp

- `ft_equipment &ft_equipment::operator=(const ft_equipment &other) noexcept`
- `ft_equipment &ft_equipment::operator=(ft_equipment &&other) noexcept`

### Game/game_event.cpp

- `ft_event &ft_event::operator=(const ft_event &other) noexcept`
- `ft_event &ft_event::operator=(ft_event &&other) noexcept`

### Game/game_event_scheduler.cpp

- `bool ft_event_compare_ptr::operator()(const ft_sharedptr<ft_event> &left, const ft_sharedptr<ft_event> &right) const noexcept`
- `ft_event_scheduler &ft_event_scheduler::operator=(const ft_event_scheduler &other) noexcept`
- `ft_event_scheduler &ft_event_scheduler::operator=(ft_event_scheduler &&other) noexcept`

### Game/game_experience_table.cpp

- `ft_experience_table &ft_experience_table::operator=(const ft_experience_table &other) noexcept`
- `ft_experience_table &ft_experience_table::operator=(ft_experience_table &&other) noexcept`

### Game/game_hooks.cpp

- `ft_game_hooks &ft_game_hooks::operator=(const ft_game_hooks &other) noexcept`
- `ft_game_hooks &ft_game_hooks::operator=(ft_game_hooks &&other) noexcept`

### Game/game_inventory.cpp

- `ft_inventory &ft_inventory::operator=(const ft_inventory &other) noexcept`
- `ft_inventory &ft_inventory::operator=(ft_inventory &&other) noexcept`

### Game/game_item.cpp

- `ft_item &ft_item::operator=(const ft_item &other) noexcept`
- `ft_item &ft_item::operator=(ft_item &&other) noexcept`
- `ft_item_modifier &ft_item_modifier::operator=(const ft_item_modifier &other) noexcept`
- `ft_item_modifier &ft_item_modifier::operator=(ft_item_modifier &&other) noexcept`

### Game/game_map3d.cpp

- `ft_map3d &ft_map3d::operator=(const ft_map3d &other)`
- `ft_map3d &ft_map3d::operator=(ft_map3d &&other) noexcept`

### Game/game_pathfinding.cpp

- `ft_path_step &ft_path_step::operator=(const ft_path_step &other) noexcept`
- `ft_path_step &ft_path_step::operator=(ft_path_step &&other) noexcept`
- `ft_pathfinding &ft_pathfinding::operator=(const ft_pathfinding &other) noexcept`
- `ft_pathfinding &ft_pathfinding::operator=(ft_pathfinding &&other) noexcept`

### Game/game_price_definition.cpp

- `ft_price_definition &ft_price_definition::operator=(const ft_price_definition &other) noexcept`
- `ft_price_definition &ft_price_definition::operator=(ft_price_definition &&other) noexcept`

### Game/game_progress_tracker.cpp

- `ft_progress_tracker &ft_progress_tracker::operator=(const ft_progress_tracker &other) noexcept`
- `ft_progress_tracker &ft_progress_tracker::operator=(ft_progress_tracker &&other) noexcept`

### Game/game_quest.cpp

- `ft_quest &ft_quest::operator=(const ft_quest &other) noexcept`
- `ft_quest &ft_quest::operator=(ft_quest &&other) noexcept`

### Game/game_rarity_band.cpp

- `ft_rarity_band &ft_rarity_band::operator=(const ft_rarity_band &other) noexcept`
- `ft_rarity_band &ft_rarity_band::operator=(ft_rarity_band &&other) noexcept`

### Game/game_region_definition.cpp

- `ft_region_definition &ft_region_definition::operator=(const ft_region_definition &other) noexcept`
- `ft_region_definition &ft_region_definition::operator=(ft_region_definition &&other) noexcept`

### Game/game_reputation.cpp

- `ft_reputation &ft_reputation::operator=(const ft_reputation &other) noexcept`
- `ft_reputation &ft_reputation::operator=(ft_reputation &&other) noexcept`

### Game/game_resistance.cpp

- `ft_resistance &ft_resistance::operator=(const ft_resistance &other) noexcept`
- `ft_resistance &ft_resistance::operator=(ft_resistance &&other) noexcept`

### Game/game_scripting_bridge.cpp

- `ft_game_script_bridge &ft_game_script_bridge::operator=(const ft_game_script_bridge &other) noexcept`
- `ft_game_script_bridge &ft_game_script_bridge::operator=(ft_game_script_bridge &&other) noexcept`
- `ft_game_script_context &ft_game_script_context::operator=(const ft_game_script_context &other) noexcept`

### Game/game_server.cpp

- `ft_game_server &ft_game_server::operator=(const ft_game_server &other) noexcept`
- `ft_game_server &ft_game_server::operator=(ft_game_server &&other) noexcept`

### Game/game_skill.cpp

- `ft_skill &ft_skill::operator=(const ft_skill &other) noexcept`
- `ft_skill &ft_skill::operator=(ft_skill &&other) noexcept`

### Game/game_state.cpp

- `ft_game_state &ft_game_state::operator=(const ft_game_state &other) noexcept`
- `ft_game_state &ft_game_state::operator=(ft_game_state &&other) noexcept`

### Game/game_upgrade.cpp

- `ft_upgrade &ft_upgrade::operator=(const ft_upgrade &other) noexcept`
- `ft_upgrade &ft_upgrade::operator=(ft_upgrade &&other) noexcept`

### Game/game_vendor_profile.cpp

- `ft_vendor_profile &ft_vendor_profile::operator=(const ft_vendor_profile &other) noexcept`
- `ft_vendor_profile &ft_vendor_profile::operator=(ft_vendor_profile &&other) noexcept`

### Game/game_world.cpp

- `ft_world &ft_world::operator=(const ft_world &other) noexcept`
- `ft_world &ft_world::operator=(ft_world &&other) noexcept`

### Game/game_world_region.cpp

- `ft_world_region &ft_world_region::operator=(const ft_world_region &other) noexcept`
- `ft_world_region &ft_world_region::operator=(ft_world_region &&other) noexcept`

### Game/game_world_registry.cpp

- `ft_world_registry &ft_world_registry::operator=(const ft_world_registry &other) noexcept`
- `ft_world_registry &ft_world_registry::operator=(ft_world_registry &&other) noexcept`

### Game/game_world_replay.cpp

- `ft_world_replay_session &ft_world_replay_session::operator=(const ft_world_replay_session &other) noexcept`
- `ft_world_replay_session &ft_world_replay_session::operator=(ft_world_replay_session &&other) noexcept`

### Geometry/geometry_aabb.cpp

- `aabb &aabb::operator=(aabb &&other) noexcept`
- `aabb &aabb::operator=(const aabb &other)`

### Geometry/geometry_circle.cpp

- `circle &circle::operator=(circle &&other) noexcept`
- `circle &circle::operator=(const circle &other)`

### Geometry/geometry_sphere.cpp

- `sphere &sphere::operator=(const sphere &other)`
- `sphere &sphere::operator=(sphere &&other) noexcept`

### Logger/logger_log_context_guard.cpp

- `ft_log_context_guard &ft_log_context_guard::operator=(ft_log_context_guard &&other) noexcept`

### Math/linear_algebra.cpp

- `matrix2 &matrix2::operator=(const matrix2 &other)`
- `matrix2 &matrix2::operator=(matrix2 &&other)`
- `matrix3 &matrix3::operator=(const matrix3 &other)`
- `matrix3 &matrix3::operator=(matrix3 &&other)`
- `matrix4 &matrix4::operator=(const matrix4 &other)`
- `matrix4 &matrix4::operator=(matrix4 &&other)`

### Math/linear_algebra_quaternion.cpp

- `quaternion &quaternion::operator=(const quaternion &other)`
- `quaternion &quaternion::operator=(quaternion &&other) noexcept`

### Math/linear_algebra_vector2.cpp

- `vector2 &vector2::operator=(const vector2 &other)`
- `vector2 &vector2::operator=(vector2 &&other)`

### Math/linear_algebra_vector3.cpp

- `vector3 &vector3::operator=(const vector3 &other)`
- `vector3 &vector3::operator=(vector3 &&other)`

### Math/linear_algebra_vector4.cpp

- `vector4 &vector4::operator=(const vector4 &other)`
- `vector4 &vector4::operator=(vector4 &&other)`

### Math/math_autodiff.cpp

- `ft_dual_number &ft_dual_number::operator=(const ft_dual_number &other) noexcept`
- `ft_dual_number &ft_dual_number::operator=(ft_dual_number &&other) noexcept`
- `ft_dual_number ft_dual_number::operator*(const ft_dual_number &other) const noexcept`
- `ft_dual_number ft_dual_number::operator+(const ft_dual_number &other) const noexcept`
- `ft_dual_number ft_dual_number::operator-(const ft_dual_number &other) const noexcept`
- `ft_dual_number ft_dual_number::operator/(const ft_dual_number &other) const noexcept`

### Math/math_autodiff.hpp

- `ft_dual_number operator*(const ft_dual_number &other) const noexcept;`
- `ft_dual_number operator+(const ft_dual_number &other) const noexcept;`
- `ft_dual_number operator-(const ft_dual_number &other) const noexcept;`
- `ft_dual_number operator/(const ft_dual_number &other) const noexcept;`

### Math/math_polynomial.cpp

- `ft_cubic_spline &ft_cubic_spline::operator=(ft_cubic_spline &&other) noexcept`

### Networking/http2_client.cpp

- `http2_frame &http2_frame::operator=(const http2_frame &other) noexcept`
- `http2_frame &http2_frame::operator=(http2_frame &&other) noexcept`
- `http2_header_field &http2_header_field::operator=(const http2_header_field &other) noexcept`
- `http2_header_field &http2_header_field::operator=(http2_header_field &&other) noexcept`

### Networking/networking.cpp

- `SocketConfig& SocketConfig::operator=(SocketConfig&& other) noexcept`
- `SocketConfig& SocketConfig::operator=(const SocketConfig& other) noexcept`

### Networking/networking_socket_class.cpp

- `ft_socket &ft_socket::operator=(ft_socket &&other) noexcept`

### Networking/socket_handle.cpp

- `ft_socket_handle &ft_socket_handle::operator=(ft_socket_handle &&other) noexcept`

### PThread/pthread_task_scheduler.cpp

- `ft_scheduled_task_handle &ft_scheduled_task_handle::operator=(const ft_scheduled_task_handle &other)`

### PThread/pthread_thread.cpp

- `ft_thread &ft_thread::operator=(ft_thread &&other)`

### PThread/unique_lock.hpp

- `template <typename MutexType> ft_unique_lock<MutexType> &ft_unique_lock<MutexType>::operator=(ft_unique_lock &&other)`

### RNG/loot_table.hpp

- `template<typename ElementType> ft_loot_entry<ElementType> &ft_loot_entry<ElementType>::operator=(const ft_loot_entry<ElementType> &other) noexcept`

### RNG/rng_stream.cpp

- `rng_stream &rng_stream::operator=(const rng_stream &other)`
- `rng_stream &rng_stream::operator=(rng_stream &&other) noexcept`

### SCMA/SCMA.hpp

- `template <typename TValue> inline TValue &scma_handle_accessor_element_proxy<TValue>::operator*(void)`
- `template <typename TValue> inline TValue *scma_handle_accessor_element_proxy<TValue>::operator->(void)`
- `template <typename TValue> inline const TValue &scma_handle_accessor_const_element_proxy<TValue>::operator*(void) const`
- `template <typename TValue> inline const TValue *scma_handle_accessor_const_element_proxy<TValue>::operator->(void) const`
- `template <typename TValue> inline scma_handle_accessor_const_element_proxy<TValue> &scma_handle_accessor_const_element_proxy<TValue>::operator=(scma_handle_accessor_const_element_proxy &&other)`
- `template <typename TValue> inline scma_handle_accessor_const_element_proxy<TValue> scma_handle_accessor<TValue>::operator*(void) const`
- `template <typename TValue> inline scma_handle_accessor_const_element_proxy<TValue> scma_handle_accessor<TValue>::operator->(void) const`
- `template <typename TValue> inline scma_handle_accessor_const_element_proxy<TValue> scma_handle_accessor<TValue>::operator[](ft_size_t element_index) const`
- `template <typename TValue> inline scma_handle_accessor_const_element_proxy<TValue>::operator TValue(void) const`
- `template <typename TValue> inline scma_handle_accessor_element_proxy<TValue> &scma_handle_accessor_element_proxy<TValue>::operator=(const TValue &source)`
- `template <typename TValue> inline scma_handle_accessor_element_proxy<TValue> &scma_handle_accessor_element_proxy<TValue>::operator=(scma_handle_accessor_element_proxy &&other)`
- `template <typename TValue> inline scma_handle_accessor_element_proxy<TValue> scma_handle_accessor<TValue>::operator*(void)`
- `template <typename TValue> inline scma_handle_accessor_element_proxy<TValue> scma_handle_accessor<TValue>::operator->(void)`
- `template <typename TValue> inline scma_handle_accessor_element_proxy<TValue> scma_handle_accessor<TValue>::operator[](ft_size_t element_index)`
- `template <typename TValue> inline scma_handle_accessor_element_proxy<TValue>::operator TValue(void) const`

### Storage/storage_kv_store_entry.cpp

- `kv_store_entry &kv_store_entry::operator=(const kv_store_entry &other) noexcept`
- `kv_store_entry &kv_store_entry::operator=(kv_store_entry &&other) noexcept`

### Template/bitset.hpp

- `inline ft_bitset& ft_bitset::operator=(ft_bitset&& other) noexcept`

### Template/cancellation.hpp

- `inline ft_cancellation_source &ft_cancellation_source::operator=(const ft_cancellation_source &other) noexcept`
- `inline ft_cancellation_source &ft_cancellation_source::operator=(ft_cancellation_source &&other) noexcept`
- `inline ft_cancellation_token &ft_cancellation_token::operator=(const ft_cancellation_token &other) noexcept`
- `inline ft_cancellation_token &ft_cancellation_token::operator=(ft_cancellation_token &&other) noexcept`

### Template/circular_buffer.hpp

- `template <typename ElementType> ft_circular_buffer<ElementType>& ft_circular_buffer<ElementType>::operator=(ft_circular_buffer&& other) noexcept`

### Template/deque.hpp

- `template <typename ElementType> ft_deque<ElementType>& ft_deque<ElementType>::operator=(ft_deque&& other) noexcept`

### Template/event_emitter.hpp

- `template <typename EventType, typename... Args> ft_event_emitter<EventType, Args...>& ft_event_emitter<EventType, Args...>::operator=(ft_event_emitter&& other) noexcept`

### Template/future.hpp

- `inline ft_future<void> &ft_future<void>::operator=(const ft_future<void> &other)`
- `inline ft_future<void> &ft_future<void>::operator=(ft_future<void> &&other)`
- `template <typename ValueType> ft_future<ValueType> &ft_future<ValueType>::operator=(const ft_future<ValueType> &other)`
- `template <typename ValueType> ft_future<ValueType> &ft_future<ValueType>::operator=(ft_future<ValueType> &&other)`

### Template/graph.hpp

- `template <typename VertexType> ft_graph<VertexType>& ft_graph<VertexType>::operator=(ft_graph&& other) noexcept`

### Template/iterator.hpp

- `Iterator operator++() noexcept;`
- `ValueType& operator*() const noexcept;`
- `template <typename ValueType> Iterator<ValueType> Iterator<ValueType>::operator++() noexcept`
- `template <typename ValueType> Iterator<ValueType>& Iterator<ValueType>::operator=(Iterator&& other) noexcept`
- `template <typename ValueType> Iterator<ValueType>& Iterator<ValueType>::operator=(const Iterator& other) noexcept`
- `template <typename ValueType> ValueType& Iterator<ValueType>::operator*() const noexcept`
- `template <typename ValueType> bool Iterator<ValueType>::operator!=(const Iterator& other) const noexcept`

### Template/map.hpp

- `template <typename Key, typename MappedType> ft_map<Key, MappedType>& ft_map<Key, MappedType>::operator=(const ft_map<Key, MappedType>& other)`
- `template <typename Key, typename MappedType> ft_map<Key, MappedType>& ft_map<Key, MappedType>::operator=(ft_map<Key, MappedType>&& other) noexcept`

### Template/matrix.hpp

- `template <typename ElementType> ft_matrix<ElementType>& ft_matrix<ElementType>::operator=(ft_matrix&& other) noexcept`

### Template/optional.hpp

- `template <typename T> ft_optional<T>& ft_optional<T>::operator=(ft_optional&& other) noexcept`

### Template/pair.hpp

- `template <typename KeyType, typename ValueType> Pair<KeyType, ValueType> &Pair<KeyType, ValueType>::operator=(Pair &&other)`
- `template <typename KeyType, typename ValueType> Pair<KeyType, ValueType> &Pair<KeyType, ValueType>::operator=(const Pair &other)`

### Template/pool.hpp

- `template<typename T> Pool<T>& Pool<T>::operator=(Pool&& other)`
- `template<typename T> Pool<T>::Object::operator bool() const noexcept`
- `template<typename T> T* Pool<T>::Object::operator->() const noexcept`
- `template<typename T> typename Pool<T>::Object& Pool<T>::Object::operator=(Object&& o) noexcept`

### Template/priority_queue.hpp

- `template <typename ElementType, typename Compare> ft_priority_queue<ElementType, Compare>& ft_priority_queue<ElementType, Compare>::operator=(ft_priority_queue&& other) noexcept`

### Template/queue.hpp

- `template <typename ElementType> ft_queue<ElementType>& ft_queue<ElementType>::operator=(ft_queue&& other) noexcept`

### Template/set.hpp

- `template <typename ElementType> ft_set<ElementType>& ft_set<ElementType>::operator=(ft_set&& other) noexcept`

### Template/shared_ptr.hpp

- `ManagedType& operator[](size_t index);`
- `const ManagedType& operator*() const;`
- `const ManagedType& operator[](size_t index) const;`
- `explicit operator bool() const noexcept;`
- `template <typename ManagedType> ManagedType& ft_sharedptr<ManagedType>::operator[](size_t index)`
- `template <typename ManagedType> ManagedType* ft_sharedptr<ManagedType>::operator->()`
- `template <typename ManagedType> const ManagedType& ft_sharedptr<ManagedType>::operator*() const`
- `template <typename ManagedType> const ManagedType& ft_sharedptr<ManagedType>::operator[](size_t index) const`
- `template <typename ManagedType> const ManagedType* ft_sharedptr<ManagedType>::operator->() const`
- `template <typename ManagedType> ft_sharedptr<ManagedType>& ft_sharedptr<ManagedType>::operator=(const ft_sharedptr<ManagedType>& other)`
- `template <typename ManagedType> ft_sharedptr<ManagedType>& ft_sharedptr<ManagedType>::operator=(ft_sharedptr<ManagedType>&& other) noexcept`
- `template <typename ManagedType> ft_sharedptr<ManagedType>::operator bool() const noexcept`

### Template/stack.hpp

- `template <typename ElementType> ft_stack<ElementType>& ft_stack<ElementType>::operator=(ft_stack&& other) noexcept`

### Template/string_view.hpp

- `CharType operator[](size_t index) const;`
- `template <typename CharType> CharType ft_string_view<CharType>::operator[](size_t index) const`
- `template <typename CharType> ft_string_view<CharType>& ft_string_view<CharType>::operator=(const ft_string_view& other)`

### Template/tuple.hpp

- `template <typename... Types> ft_tuple<Types...>& ft_tuple<Types...>::operator=(ft_tuple&& other) noexcept`

### Template/unique_ptr.hpp

- `ManagedType& operator*();`
- `ManagedType& operator[](size_t index);`
- `const ManagedType& operator*() const;`
- `const ManagedType& operator[](size_t index) const;`
- `explicit operator bool() const noexcept;`
- `template <typename ManagedType> ManagedType& ft_uniqueptr<ManagedType>::operator*()`
- `template <typename ManagedType> ManagedType& ft_uniqueptr<ManagedType>::operator[](size_t index)`
- `template <typename ManagedType> ManagedType* ft_uniqueptr<ManagedType>::operator->()`
- `template <typename ManagedType> const ManagedType& ft_uniqueptr<ManagedType>::operator*() const`
- `template <typename ManagedType> const ManagedType& ft_uniqueptr<ManagedType>::operator[](size_t index) const`
- `template <typename ManagedType> const ManagedType* ft_uniqueptr<ManagedType>::operator->() const`
- `template <typename ManagedType> ft_uniqueptr<ManagedType>& ft_uniqueptr<ManagedType>::operator=(ft_uniqueptr&& other) noexcept`
- `template <typename ManagedType> ft_uniqueptr<ManagedType>::operator bool() const noexcept`

### Template/unordered_map.hpp

- `template <typename Key, typename MappedType> MappedType& ft_unordered_map<Key, MappedType>::operator[](const Key& key)`
- `template <typename Key, typename MappedType> bool ft_unordered_map<Key, MappedType>::const_iterator::operator!=(const const_iterator& other) const`
- `template <typename Key, typename MappedType> bool ft_unordered_map<Key, MappedType>::const_iterator::operator==(const const_iterator& other) const`
- `template <typename Key, typename MappedType> bool ft_unordered_map<Key, MappedType>::iterator::operator!=(const iterator& other) const`
- `template <typename Key, typename MappedType> bool ft_unordered_map<Key, MappedType>::iterator::operator==(const iterator& other) const`
- `template <typename Key, typename MappedType> const ft_pair<Key, MappedType>& ft_unordered_map<Key, MappedType>::const_iterator::operator*() const`
- `template <typename Key, typename MappedType> const ft_pair<Key, MappedType>* ft_unordered_map<Key, MappedType>::const_iterator::operator->() const`
- `template <typename Key, typename MappedType> ft_pair<Key, MappedType>& ft_unordered_map<Key, MappedType>::iterator::operator*() const`
- `template <typename Key, typename MappedType> ft_pair<Key, MappedType>* ft_unordered_map<Key, MappedType>::iterator::operator->() const`
- `template <typename Key, typename MappedType> ft_unordered_map<Key, MappedType>& ft_unordered_map<Key, MappedType>::operator=(const ft_unordered_map<Key, MappedType>& other)`
- `template <typename Key, typename MappedType> ft_unordered_map<Key, MappedType>& ft_unordered_map<Key, MappedType>::operator=(ft_unordered_map<Key, MappedType>&& other) noexcept`
- `template <typename Key, typename MappedType> typename ft_unordered_map<Key, MappedType>::const_iterator& ft_unordered_map<Key, MappedType>::const_iterator::operator++()`
- `template <typename Key, typename MappedType> typename ft_unordered_map<Key, MappedType>::const_iterator& ft_unordered_map<Key, MappedType>::const_iterator::operator=(const const_iterator& other)`
- `template <typename Key, typename MappedType> typename ft_unordered_map<Key, MappedType>::const_iterator& ft_unordered_map<Key, MappedType>::const_iterator::operator=(const_iterator&& other) noexcept`
- `template <typename Key, typename MappedType> typename ft_unordered_map<Key, MappedType>::iterator& ft_unordered_map<Key, MappedType>::iterator::operator++()`
- `template <typename Key, typename MappedType> typename ft_unordered_map<Key, MappedType>::iterator& ft_unordered_map<Key, MappedType>::iterator::operator=(const iterator& other)`
- `template <typename Key, typename MappedType> typename ft_unordered_map<Key, MappedType>::iterator& ft_unordered_map<Key, MappedType>::iterator::operator=(iterator&& other) noexcept`

### Template/variant.hpp

- `template <typename... Types> ft_variant<Types...>& ft_variant<Types...>::operator=(ft_variant&& other) noexcept`

### Template/vector.hpp

- `ElementType& operator[](size_t index);`
- `const ElementType& operator[](size_t index) const;`
- `template <typename ElementType> ElementType& ft_vector<ElementType>::operator[](size_t index)`
- `template <typename ElementType> const ElementType& ft_vector<ElementType>::operator[](size_t index) const`
- `template <typename ElementType> ft_vector<ElementType>& ft_vector<ElementType>::operator=(ft_vector<ElementType>&& other) noexcept`

### Test/Test/test_template.cpp

- `vector_destructor_tracker &vector_destructor_tracker::operator=(const vector_destructor_tracker &other)`
- `vector_destructor_tracker &vector_destructor_tracker::operator=(vector_destructor_tracker &&other) noexcept`

### Test/Test/test_template_concepts.cpp

- `shared_ptr_base_type &shared_ptr_base_type::operator=(const shared_ptr_base_type &other)`
- `shared_ptr_derived_type &shared_ptr_derived_type::operator=(const shared_ptr_derived_type &other)`
- `variadic_constructible &variadic_constructible::operator=(const variadic_constructible &other)`

### Test/Test/test_template_function_copy_move.cpp

- `int operator()() const`

### Test/Test/test_template_optional.cpp

- `no_default_optional_value &no_default_optional_value::operator=(const no_default_optional_value &other)`

Document regenerated via `build_signature_catalog.py`.
