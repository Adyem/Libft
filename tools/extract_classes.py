#!/usr/bin/env python3
"""List every class and struct defined in the repository."""

from __future__ import annotations

import argparse
import re
from collections import defaultdict
from pathlib import Path
from typing import DefaultDict, Iterable, Sequence, Set


SOURCE_EXTENSIONS: Set[str] = {
    ".c",
    ".cc",
    ".cpp",
    ".cxx",
    ".hh",
    ".hpp",
    ".h",
    ".ipp",
}

EXCLUDED_DIRS: Set[str] = {"Docs", "tools", ".git"}


def collect_sources(root: Path) -> Sequence[Path]:
    sources: list[Path] = []
    for candidate in root.rglob("*"):
        if not candidate.is_file():
            continue
        if candidate.suffix.lower() not in SOURCE_EXTENSIONS:
            continue
        if EXCLUDED_DIRS & set(candidate.parts):
            continue
        sources.append(candidate)
    return sorted(sources)


def strip_comments(text: str) -> str:
    text = re.sub(r"/\*.*?\*/", "", text, flags=re.DOTALL)
    text = re.sub(r"//.*", "", text)
    return text


def enumerate_classes(text: str) -> Iterable[str]:
    text = strip_comments(text)
    pattern = re.compile(
        r"\b(class|struct)\s+([A-Za-z_]\w*)(?:\s*<[^>{;]+>)?(?:\s*[^;{]*)?\{",
        flags=re.MULTILINE,
    )
    for match in pattern.finditer(text):
        yield match.group(2)


def build_document(
    root: Path,
    classes: DefaultDict[Path, Set[str]],
    script: Path,
) -> str:
    lines = [
        "# Class Index",
        "",
        "Generated by `tools/extract_classes.py`.",
        "",
        "Each entry lists the class or struct name introduced in that translation unit.",
        "",
    ]
    for path in sorted(classes):
        class_names = classes[path]
        if not class_names:
            continue
        rel = path.relative_to(root)
        lines.append(f"## {rel.as_posix()}")
        lines.append("")
        for name in sorted(class_names):
            lines.append(f"- `{name}`")
        lines.append("")
    lines.append(f"Document regenerated via `{script.name}`.")
    return "\n".join(lines)


def main() -> int:
    parser = argparse.ArgumentParser(description="Enumerate class definitions.")
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("Docs").resolve() / "class_index.md",
        help="Destination for the generated document.",
    )
    args = parser.parse_args()

    repo_root = Path(__file__).resolve().parents[1]
    classes: DefaultDict[Path, Set[str]] = defaultdict(set)
    for source in collect_sources(repo_root):
        text = source.read_text(encoding="utf-8")
        for class_name in enumerate_classes(text):
            classes[source].add(class_name)

    args.output.write_text(
        build_document(repo_root, classes, Path(__file__)),
        encoding="utf-8",
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
