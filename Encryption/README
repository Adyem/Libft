# Encryption

## Security Rationale

`be_getEncryptionKey` reads entropy from the operating system to avoid
predictable keys. On Unix systems the function pulls random bytes from
`/dev/urandom`; on Windows it uses `CryptGenRandom`. If these sources are
unavailable, it falls back to `ft_random_seed` to preserve variability.
Mapping bytes to alphabetic characters maintains compatibility with the
existing interface while ensuring keys differ across runs.

## SHA-256

`sha256_hash` computes the SHA-256 digest of arbitrary data. The function
accepts a pointer to the data, its length in bytes and a 32 byte output buffer.

### Usage

```
const char *message = "hello";
unsigned char digest[32];
sha256_hash(message, 5, digest);
```

### Warning

SHA-256 provides collision resistance for modern systems, but hashing alone
does not secure passwords or sensitive data. Apply a keyed construction such as
HMAC or use dedicated password hashing algorithms for authentication.

## HMAC-SHA-256

`hmac_sha256` computes a keyed hash using SHA-256. The function accepts a key,
its length, a pointer to the data, the data length and a 32 byte output buffer.

### Usage

```
const char *message = "hello";
const unsigned char key[] = "secret";
unsigned char digest[32];
hmac_sha256(key, 6, message, 5, digest);
```

## RSA

Basic RSA helpers generate a key pair and perform modular exponentiation for
encrypting and decrypting small integers.

### Usage

```
uint64_t public_key;
uint64_t private_key;
uint64_t modulus;
rsa_generate_key_pair(&public_key, &private_key, &modulus, 32);
uint64_t encrypted = rsa_encrypt(42, public_key, modulus);
uint64_t decrypted = rsa_decrypt(encrypted, private_key, modulus);
```

### Warning

This implementation uses small primes for demonstration and relies on 64-bit
arithmetic. Large key sizes drastically slow down operations and may exceed
the limits of this module. For real-world security, use keys of at least 2048
bits and a vetted cryptographic library.

