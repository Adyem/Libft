# Encryption

## Security Rationale

`be_getEncryptionKey` reads entropy from the operating system to avoid
predictable keys. On Unix systems the function pulls random bytes from
`/dev/urandom`; on Windows it uses `CryptGenRandom`. If these sources are
unavailable, it falls back to `ft_random_seed` to preserve variability.
Mapping bytes to alphabetic characters maintains compatibility with the
existing interface while ensuring keys differ across runs.

## Secure memory wiping

`encryption_secure_wipe` clears arbitrary buffers without being optimized out
by the compiler. The helper funnels operating-system specific primitives
through `cmp_secure_memzero`, falling back to volatile writes when no dedicated
API is available. `encryption_secure_wipe_string` erases null-terminated
strings, including the terminator byte, so secrets retrieved with
`be_getEncryptionKey` can be scrubbed once they are no longer required.

## Key management helpers

`encryption_fill_secure_buffer` writes cryptographically secure random bytes
into an existing buffer and returns explicit error codes on failure. The helper is
used by `encryption_generate_symmetric_key` and
`encryption_generate_initialization_vector`, which allocate CMA-backed buffers
that are automatically filled with secure randomness before being returned to
the caller. Always wipe the buffers with `encryption_secure_wipe` and release
them with `cma_free` once the key material is no longer required.

### Best practices

- Generate a unique symmetric key and initialization vector for every
  encryption session instead of reusing values across messages.
- Store keys encrypted at rest and restrict access controls so only processes
  that require the material can read it.
- Rotate keys on a schedule and immediately after detecting suspicious
  activity, revoking old credentials as soon as possible.
- Prefer secure key exchanges (such as an authenticated Diffie-Hellman
  handshake) over embedding long-lived keys in configuration files.
- Always zero buffers with `encryption_secure_wipe` before freeing them or
  returning them to object pools.

## SHA-256

`sha256_hash` computes the SHA-256 digest of arbitrary data. The function
accepts a pointer to the data, its length in bytes and a 32 byte output buffer.

### Usage

```
const char *message = "hello";
unsigned char digest[32];
sha256_hash(message, 5, digest);
```

### Warning

SHA-256 provides collision resistance for modern systems, but hashing alone
does not secure passwords or sensitive data. Apply a keyed construction such as
HMAC or use dedicated password hashing algorithms for authentication.

## HMAC-SHA-256

`hmac_sha256` computes a keyed hash using SHA-256. The function accepts a key,
its length, a pointer to the data, the data length and a 32 byte output buffer.

### Usage

```
const char *message = "hello";
const unsigned char key[] = "secret";
unsigned char digest[32];
hmac_sha256(key, 6, message, 5, digest);
```

## RSA

Basic RSA helpers generate a key pair and perform modular exponentiation for
encrypting and decrypting small integers.

### Usage

```
uint64_t public_key;
uint64_t private_key;
uint64_t modulus;
rsa_generate_key_pair(&public_key, &private_key, &modulus, 32);
uint64_t encrypted = rsa_encrypt(42, public_key, modulus);
uint64_t decrypted = rsa_decrypt(encrypted, private_key, modulus);
```

### Warning

This implementation uses small primes for demonstration and relies on 64-bit
arithmetic. Large key sizes drastically slow down operations and may exceed
the limits of this module. For real-world security, use keys of at least 2048
bits and a vetted cryptographic library.
